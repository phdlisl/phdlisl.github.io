{"./":{"url":"./","title":"首页","keywords":"","body":" 欢迎来到我的主页 本站作为个人档案馆，包括作者的技术博客、教学笔记、教学视频等索引，欢迎关注（star/watch）。 欢迎关注：公众号（计算机科学实验室），B站（C语言实验室） 任何问题，欢迎来到Issues交流。 教学相关 C语言程序设计 数据结构与算法 集合（零散教学） 笔记 集合 密码学 技术指南 Gitbook使用指南 C语言 数据结构 MIRACL使用指南 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-20 "},"teachClang/intro.html":{"url":"teachClang/intro.html","title":"C语言程序设计","keywords":"","body":"C语言程序设计 记录《C语言程序设计》课程的教学内容，关于C语言的使用教程，参考C语言使用指南。 根据课程持续更新。。。 CLion安装教程 CLion上开发OpenSSL项目的配置 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-27 "},"teachClang/basic/clion.html":{"url":"teachClang/basic/clion.html","title":"CLion安装教程","keywords":"","body":"Clion安装和配置 CLion是由JetBrains公司开发的跨平台集成开发环境（IDE），专为C/C++语言开发者设计，支持Windows、MacOS和Linux操作系统。从官方地址下载安装包，根据需要选择不同版本。 软件安装 下载好安装包之后，执行安装命令 ./clion.sh 即可进行安装，下面是在macOS系统上安装之后的设置。 在【Plugins】搜索中文汉化插件，可获取中文支持。 【Setting → Appearance → Theme】，设置背景颜色。 创建C语言项目，选择【C语言可执行文件】，C语言版本选择C99 首次创建项目可能会弹出项目向导，用于安装基本的编译器，选择默认已捆绑的编译器即可 软件可能会要求注册之后使用，或者要求输入激活码等，可以先用试用版。关于软件激活不做过多说明，支持正版。 测试安装环境 一个C语言项目只能有一个main函数 在新建文件的时候，根据需要选择是否添加到项目目标，如果勾选则会在CMakeLists.txt文件的可执行目标中添加该文件名 CMakeLists.txt文件用于管理C语言项目文件，只要修改该文件，将可以自动为每个main函数的文件添加独立的项目目标，各自识别为一个独立程序 修改CMakeLists.txt文件的代码，每次添加文件之后，点击刷新该文件的按钮或者在【文件】里面选择【重新加载CMake项目】 中文乱码：【settings→Editor→File Encodings】[Global Encoding:UTF8]、[Project Encoding:UTF8]、[Create UTF8 files: with no BOM] # 按照书本要求设定C语言和C++版本 set(CMAKE_C_STANDARD 99) set(CMAKE_CXX_STANDARD 20) # 设定构建运行路径，避免污染根目录 set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/.archive) set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/.library) set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/.runtime) set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/.runtime) set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/.library) #include_directories(${PROJECT_SOURCE_DIR}/src) include_directories(${PROJECT_SOURCE_DIR}) # 遍历项目src目录下所有的 .c 文件，自动添加 #file(GLOB_RECURSE files src/**.c src/**.cpp) file(GLOB_RECURSE files **.c **.cpp) foreach (file ${files}) # 遍历所有发现的文件 get_filename_component(name ${file} NAME) # 获取文件名 add_executable(${name} ${file}) # 添加可执行文件 endforeach () # 遍历结束 # -------------------------------------------------------------- # >----------------------------------------------------------------------- # 本文件是一个自动化的CMakeList，有以下功能： # - 自动遍历 src 目录下的所有 .c 和 .cpp 文件，并将其编译为可执行文件。 # - 将可执行文件(即编译结果)输出到项目根目录下的 .runtime/ 目录中。 # - 将库文件输出到项目根目录下的 .library/ 目录中。 # - 将中间文件输出到项目根目录下的 .archive/ 目录中。 # >----------------------------------------------------------------------- # 使用此CMakeList时，若要新建C/C++语言文件，请按照以下步骤： # 1. 右键src目录(如果没有src目录，请先创建)——新建——C/C++源文件 # 2. 在弹出的对话框中，输入文件名(仅允许英文小写及下划线，不要出现空格)， # 后缀为 \".c(C语言文件)\"或\".cpp(C++文件)\"，切记不要勾选“添加到目标”，点击确定。 # 3. 点击 左上角横线——文件——重新加载CMake项目 。 # 注：未重载前，进入文件可能会有“不属于任何项目目标”的警告，重载后即会消失。 # 若此警告未消失，请检查文件是否在src目录下，以及文件名是否符合规范。 # >----------------------------------------------------------------------- # 使用此CMakeList时，若运行 main() 函数代码，请直接点击函数前的绿色三角形按钮。 # 右上角的运行按钮会自动运行最近一次运行的程序，因此可能不是你想要的结果。 # ------------------------------------------------------------------------ © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-27 "},"teachClang/basic/openssl2Clion.html":{"url":"teachClang/basic/openssl2Clion.html","title":"CLion上开发OpenSSL项目的配置","keywords":"","body":"CLion上开发OpenSSL项目的配置 编译OpenSSL库 首先在OpenSSL官网下载源码，然后进入到openssl目录，执行配置命令和编译命令。 git clone https://github.com/openssl/openssl.git 执行配置命令 ./Configure 和编译命令 make，执行配置命令 ./Configure 的时候，可以配置路径和环境变量，也可以不配置，选择其中一条执行即可。执行编译命令 make的时候，可能会涉及到权限不够的情况，需要加 sudo 提升权限。 cd openssl ./Configure ./Configure --prefix=/youpath/sslx --openssldir=/youpath/sslx ./Configure --prefix=/youpath/sslx --openssldir=/youpath/sslx '-Wl,-rpath,$(LIBRPATH)' make install sudo make install Clion上开发项目 关于Clion的环境配置参考Clion安装和配置，不再赘述。 创建C语言项目，修改CMakeLists.txt文件的配置，将OpenSSL加入到项目中。在 OPENSSL_ROOT_DIR 配置OpenSSL库文件路径，如果添加了环境变量就可以直接查询。 cmake_minimum_required(VERSION 4.0) project(openssltest C) set(CMAKE_C_STANDARD 99) # 设置OpenSSL路径（使用Homebrew的安装路径） set(OPENSSL_ROOT_DIR \"/youpath/sslx\") # Intel Mac # set(OPENSSL_ROOT_DIR \"/opt/homebrew/opt/openssl\") # Apple Silicon Mac # 告诉CMake在哪里查找 find_package(OpenSSL REQUIRED) if(OpenSSL_FOUND) message(STATUS \"Found OpenSSL ${OPENSSL_VERSION}\") message(STATUS \"Include dir: ${OPENSSL_INCLUDE_DIR}\") message(STATUS \"Libraries: ${OPENSSL_LIBRARIES}\") else() message(FATAL_ERROR \"OpenSSL not found\") endif() add_executable(openssltest main.c) # 现代CMake方式：使用导入的目标 target_link_libraries(openssltest OpenSSL::SSL OpenSSL::Crypto) 在 main.c 中添加测试项目。 #include #include #include int main() { printf(\"OpenSSL测试程序\\n\"); // 检查OpenSSL版本 printf(\"OpenSSL版本: %s\\n\", OpenSSL_version(OPENSSL_VERSION)); // 简单的摘要测试 EVP_MD_CTX *mdctx; const EVP_MD *md; OpenSSL_add_all_digests(); md = EVP_get_digestbyname(\"SHA256\"); if (!md) { printf(\"未知的摘要算法\\n\"); return 1; } mdctx = EVP_MD_CTX_new(); if (!mdctx) { printf(\"创建上下文失败\\n\"); return 1; } if (EVP_DigestInit_ex(mdctx, md, NULL) != 1) { printf(\"初始化摘要失败\\n\"); EVP_MD_CTX_free(mdctx); return 1; } printf(\"OpenSSL初始化成功！\\n\"); EVP_MD_CTX_free(mdctx); EVP_cleanup(); return 0; } © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-27 "},"teachDatastruct/intro.html":{"url":"teachDatastruct/intro.html","title":"数据结构与算法","keywords":"","body":"数据结构与算法 记录《数据结构与算法》课程的教学内容，关于《数据结构与算法》的使用教程，参考数据结构与算法使用指南。 根据课程持续更新。。。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"teachNote/intro.html":{"url":"teachNote/intro.html","title":"集合（零散）","keywords":"","body":"教学集合（零散课程） 没有系统整理的教学笔记，放在这个目录下面。 搭建个人博客（笔记）网站 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-19 "},"teachNote/gitbook2github.html":{"url":"teachNote/gitbook2github.html","title":"搭建个人博客（笔记）网站","keywords":"","body":"搭建个人博客（笔记）网站 有没有想过设计一个在线笔记本，或者个人博客？ 解决两个问题：不会写代码能不能搭建自己的网站？没有服务器和域名怎么部署发布自己的网站？ 环境需要 开发环境：MacOS / Linux / Windows 编译网站源码：node.js 编辑网站源码：Gitbook。解决不会写代码的问题，编辑文本也能做网站。 部署网站：GitHub。解决没有服务器和域名的问题，直接免费部署发布网站。 工具准备 为了方便编辑文件，这里推荐两款好用的编辑工具，一个是vscode，一个是sublime text，下面是各自的安装的过程。 安装vscode 根据自己电脑的操作系统，选择不同的版本下载，然后安装。在vscode官网官网下载安装包，然后双击安装，根据安装指引以此操作即可。 vscode是一个非常强大的编辑器，可以集成很多工具一起使用，非常方便，推荐使用vscode作为编辑器。 安装sublime text sublime text也是一款不错的编辑器，但是没有vscode那般强大，如果只是为了gitbook项目的话，还是绰绰有余的。 进入Sublime Text 的官网，根据操作系统选择下载安装程序。 Ubuntu安装编辑器Sublime Text 4 环境准备 根据自己电脑的操作系统，选择安装不同版本的node.js和Gitbook。因为Gitbook环境需要Nodejs支持，所以需要配置node.js环境。Gitbook配置教程，快速搭建个人博客，制作个人电子书、帮助（说明）文档 配置node.js环境 进入node.js官网，点击下载安装程序，这里建议选择18.20.2LTS版本，下载好安装程序就可以双击安装。 安装过程不需要有特殊设置和选择，直接选择【确定】下一步即可。 [!NOTE] 根据操作系统不同，选择不同的版本，本文教程用的操作系统是MacOS M1 12.2。 完成安装之后，可查看安装是否成功。 % node -v % which node 第一个命令查看安装版本，如果能够输出版本信息，表示安装成功。 第二个命令可查看安装路径。 [!NOTE] Windows用户可以进入应用程序中查看是否安装成功，或者在配置好环境变量PATH路径的情况下，可以用CMD命令打开命令行终端，用上面的命令查看版本信息。为了方便Gitbook安装，建议配置好环境变量。 配置Gitbook环境 [!NOTE] Gitbook环境需要Nodejs支持，配置过程中，可能出现两个重要错误，都与nodejs版本相关。 在nodejs的配置中，已经默认配置了npm，只需要用npm安装Gitbook即可。 % npm install -g gitbook-cli 这里可能出现安装失败，提示错误信息如下 npm ERR! [Error: EACCES: permission denied, mkdir 这个错误提示很简单，就是没有权限，只需要在命令前面加上sudo即可 % sudo npm install -g gitbook-cli 配置完成，即可查看版本信息，如果有正确版本信息，表示安装成功。 % gitbook --version 键入上述命令，将进入Gitbook相关包下载安装时间，只需要等待。但如果选择的nodejs版本过高，可能会出现下面的错误提示。 Installing GitBook 3.2.3 /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (node:fs:205:5) Node.js v20.12.2 根据错误提示信息，找到/usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js文件，将下面三行代码注释掉，再次尝试即可顺利完成。 // fs.stat = statFix(fs.stat) // fs.fstat = statFix(fs.fstat) // fs.lstat = statFix(fs.lstat) [!NOTE] 这个错误提示及解决办法，在后面的配置过程中，可能还会用到。 再次看出版本信息，将可以看到Gitbook版本信息。 % gitbook --version CLI version: 2.3.2 GitBook version: 3.2.3 初始化Gitbook项目 完成上述过程之后，就可以初始化Gitbook项目。在磁盘新建文件夹，然后在该文件目录下初始化一个Gitbook项目。gitbook快速搭建第一个个人博客项目 % pwd /Documents/ehandlebook/ebook % gitbook init 此时，可能出现如下错误提示。 TypeError [ERR_INVALID_ARG_TYPE]: The \"data\" argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received an instance of Promise 这是版本不兼容导致，下面有两个处理办法，本文采用第二个解决方案。 版本不兼容解决方案 1、卸载nodejs，更换低版本。 先查看nodejs的安装路径，然后卸载掉已经安装的gitbook，然后将nodejs相关的文件删除。删除完nodejs之后，再次查看其版本信息，是找不到版本信息的。 % which node /usr/local/bin/node % sudo npm uninstall -g gitbook % sudo npm uninstall -g gitbook-cli % sudo rm -rf /usr/local/bin/npm % sudo rm -rf /usr/local/share/man/man1/node.1 % sudo rm -rf /usr/local/lib/dtrace/node.d % sudo rm -rf /usr/local/lib/node_modules/...与node相关 % sudo rm -rf ~/.npm % sudo rm -rf ~/.node-gyp % sudo rm /usr/local/bin/node 完成卸载之后，重新下载低版本nodejs安装，安装过程与之前的一样。完成所有的环境配置之后，再次创建gitbook项目，可能还是会出现这个错误，那就再换版本安装。 2、不卸载重装，进入gitbook安装文件，修改相关代码。 用gitbook的debug命令，找到下面版本文件。在版本文件下，找到\\3.2.3\\lib\\init.js文件，将该文件的其中一行代码替换掉。 % gitbook init --debug /Users/.../.gitbook/versions/3.2.3/ 原代码行和替换的代码行 // return fs.writeFile(filePath, summary.toText(extension)); return summary.toText(extension).then(stx=>{return fs.writeFile(filePath, stx);}); 完成之后，再次初始化项目，应该可以正常创建。 % gitbook init warn: no summary file in this book info: create SUMMARY.md info: initialization is finished 测试 最初采用Sublime Text编辑器管理gitbook项目，它的弊端是不能实时更新网页内容，很多人推荐使用Typora，读者自行尝试吧。后来采用VS code编辑器管理gitbook项目，更加方便，只需要在VS code中加入markdown插件即可。 为了方便对gitbook项目的管理，在gitbook项目中创建npm项目。在gitbook项目的文件目录下，创建npm项目。这里有很多选项，直接回车即可，最后选择yes。 % npm init 类似如下输出，这个过程中会有很多选项，直接回车或者输入相应信息，或者选择yes。 This utility will walk you through creating a package.json file. It only covers the most common items, and tries to guess sensible defaults. See `npm help init` for definitive documentation on these fields and exactly what they do. Use `npm install ` afterwards to install a package and save it as a dependency in the package.json file. Press ^C at any time to quit. package name: (ebook) version: (1.0.0) description: entry point: (index.js) test command: git repository: keywords: author: license: (ISC) About to write to /Documents/ehandlebook/ebook/package.json: { \"name\": \"ebook\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\": \"\", \"license\": \"ISC\" } Is this OK? (yes) 完成npm项目配置之后，项目中会得到一个package.json文件。 启动项目有两种方式，第一种方式是用gitbook的启动命令。还是在该项目目录下，启动项目。 % gitbook serve Live reload server started on port: 35729 Press CTRL+C to quit ... /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 很遗憾，可能启动不成功，提示的错误，与前面出现的错误类型一致，找到/usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js文件，将下面三行代码注释掉，再次尝试即可顺利完成。 // fs.stat = statFix(fs.stat) // fs.fstat = statFix(fs.fstat) // fs.lstat = statFix(fs.lstat) 再次启动，启动之后，会出现一个目录_book，浏览器访问 http://localhost:4000 。 % gitbook serve > ebook@1.0.0 serve > gitbook serve Live reload server started on port: 35729 Press CTRL+C to quit ... info: 7 plugins are installed info: loading plugin \"livereload\"... OK info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 1 pages info: found 1 asset files info: >> generation finished with success in 0.1s ! Starting server ... Serving book on http://localhost:4000 第二种启动方式，在package.json中配置启动项。 { \"name\": \"ebook\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"serve\": \"gitbook serve\", \"build\": \"gitbook build\" }, \"author\": \"\", \"license\": \"ISC\" } 启动命令为 % npm run serve 构建项目的命令为 % npm run build 构建项目服务器不会开启，只是对项目进行了最小化和最优化的构建，所以不能通过 http://localhost:4000 访问。 添加必要文件 在项目中添加必要文件 % touch book.js % touch .bookignore 其中book.js暂时放入下面的内容。 module.exports = { // 书籍信息 title: 'Gitbook应用教程', description: 'Gitbook快速建立个人博客', author: '计算机科学实验室', lang: 'zh-cn', // 插件列表 plugins: [ ], // 插件全局配置 pluginsConfig: { }, // 模板变量 variables: { // 自定义 }, }; 其中.bookignore暂时放入下面的内容。 package.json package-lock.json .bookignore gitbook依次读取.gitignore，.bookignore和.ignore文件，将这些文件里面配置的一些文件和目录排除。用户创建.bookignore文件，在里面可以配置需要忽略的内容。 到这里，就已经完成了Gitbook项目的基本创建，启动服务，已经可以通过http://localhost:4000访问看到网站效果，然后就是丰富网站内容了。 MarkDown 语法 GitBook 默认使用MarkDown语法。MarkDown是一种轻量级标记语言，语法简洁，让作者更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与 HTML 混编，可导出 HTML、PDF 以及.md格式的文件。Github、Wikipedia 等网站都有使用MarkDown文本。 标题 markdown支持6级标题，每一级标题根据#号个数确定，以#号开头。 级别 markdown形式 html形式 一级标题 # 标题 标题 二级标题 ## 标题 标题 三级标题 ### 标题 标题 四级标题 #### 标题 标题 五级标题 ##### 标题 标题 六级标题 ###### 标题 标题 段落 markdown以空行作为段落的分段标志。 第一段 第二段 粗体 单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）可实现文本加粗，例如“加粗”就是由“**加粗**”实现，“加粗”就是由“__加粗__”实现。这些都是MarkDown的语法，在HTML中，可以用标签“”实现。 类别 代码 效果 MarkDown语法 **加粗** 或 __加粗__ 加粗 或 加粗 HTML语法 加粗 加粗 MarkDown和HTML两种语法，GitBook都能认识。 斜体 用星号*或下划线_可以设计斜体。 类别 代码 效果 MarkDown语法 *斜体* 或 _斜体_ 斜体 或 斜体 HTML语法 斜体或 斜体 斜体 或 斜体 斜体+粗体 类别 代码 效果 MarkDown语法 ***斜体+粗体*** 或 ___斜体___ 斜体+粗体 或 斜体 HTML语法 斜体或 斜体 斜体 或 斜体 删除线 类别 代码 效果 MarkDown语法 ~~删除线~~ 删除线 HTML语法 斜体 删除线 表格 MarkDown 的表格设置语法比较简单，例如下面的表格及其代码。 第一列 第二列 第三列 第四列 第二行 第二行 第二行 第二行 第三行 第三行 第三行 第三行 第四行 第四行 第四行 第四行 | 第一列 | 第二列 | 第三列 | 第四列 | | ---- | ---- | ---- | ---- | | 第二行 | 第二行 | 第二行 | 第二行 | | 第三行 | 第三行 | 第三行 | 第三行 | | 第四行 | 第四行 | 第四行 | 第四行 | |、-、:之间的多余空格会被忽略，不影响布局。 默认标题栏居中对齐，内容居左对齐。 -:表示内容和标题栏居右对齐，:-表示内容和标题栏居左对齐，:-:表示内容和标题栏居中对齐。 内容和|之间的多余空格会被忽略，每行第一个|和最后一个|可以省略，-的数量至少一个。 第一列 第二列 第三列 第四列 第二行第一列 第二行第二列 第二行第三列 第二行第四列 第三行 第三行 第三行 第三行 第四行 第四行 第四行 第四行 | 第一列 | 第二列 | 第三列 | 第四列 | | ---: | :--- | ---- | ---- | | 第二行第一列 | 第二行第二列 | 第二行第三列 | 第二行第四列 | | 第三行 | 第三行 | 第三行 | 第三行 | | 第四行 | 第四行 | 第四行 | 第四行 | 列表 Gitbook可以建立两种列表，分别是有序列表和无序列表。 有序列表 有序列表以数字 1. 起始，每个列表项以数字加英文句点开始，数字不必按顺序排列。 类别 代码 效果 MarkDown语法 1. 第一项 3. 第二项 5. 第三项 1. 第一项 3. 第二项 5. 第三项 HTML语法 第一项第二项第三项 第一项第二项第三项 [!NOTE] 在表格中，如果需要用到列表，每一项的后面需要添加换行符使之能够换行，形成列表项。在正常文本中，是不需要换行符的，只需要正常空行就行。 无序列表 无序列表以破折号 (-)、星号 (*) 或加号 (+)开头，一个或多个缩进，可形成嵌套列表。 类别 代码 效果 MarkDown语法 - 第一项 - 第二项 - 第三项 - 第一项 - 第二项 - 第三项 HTML语法 第一项第二项第三项 第一项第二项第三项 [!NOTE] 在表格中，如果需要用到列表，每一项的后面需要添加换行符使之能够换行，形成列表项。在正常文本中，是不需要换行符的，只需要正常空行就行。 公式 \\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N Γ(n)=(n−1)!∀n∈N\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb NΓ(n)=(n−1)!∀n∈N Gitbook的插件配置 npm为Gitbook提供了很多插件，只需要在Gitbook项目配置npm项目，就可以下载相关插件使用。 [!NOTE] 插件应该在项目目录下安装，也就是说在当前项目文件下安装，才会出现在package.json文件中。 搜索插件 插件gitbook-plugin-search-pro支持中文搜索，详情参考官方文档，首先在项目中安装该插件 npm i gitbook-plugin-search-pro 然后在book.js文件中添加配置项 { \"plugins\": [ \"-lunr\", \"-search\", \"search-pro\" ] } 该插件能够搜索到全文匹配字符，搜索能力非常强。 代码插件 插件gitbook-plugin-code用于排版代码，详情参考官方文档，首先在项目中安装该插件 npm i gitbook-plugin-code 然后在book.js文件中添加配置项 \"plugins\" : [ \"code\" ], \"pluginsConfig\": { \"code\": { \"copyButtons\": false } } 代码高亮 插件npm i gitbook-plugin-prism用于处理代码高亮，参考官方文档，首先在项目中安装该插件。 npm i gitbook-plugin-prism 然后在book.js文件中添加配置项，以下是其中一种配置方式，更多配置参数，可查看官方文档。 { \"plugins\": [\"prism\", \"-highlight\"] } \"pluginsConfig\": { \"prism\": { \"css\": [\"prismjs/themes/prism-solarizedlight.css\"], \"lang\": {\"flow\": \"typescript\"}, \"ignore\": [\"mermaid\",\"eval-js\"] }, } 在使用的时候，需要指定编程语言，例如上面采用的是json。 隐藏Gitbook默认设置 Gitbook页面有诸如“Published with GitBook”的默认设置，可用插件gitbook-plugin-hide-element使之隐藏。 插件gitbook-plugin-hide-element的官方文档，首先在项目中安装该插件 npm i gitbook-plugin-hide-element 然后在book.js文件中添加配置项 { \"plugins\": [ \"hide-element\" ], \"pluginsConfig\": { \"hide-element\": { \"elements\": [\".gitbook-link\"] } } } 完成上述配置，就可以将“Published with GitBook”的默认设置去掉。 添加提示、警告等提示框 插件gitbook-plugin-flexible-alerts用于添加提示、警告等提示框，参考官方文档，首先在项目中安装该插件 npm i gitbook-plugin-flexible-alerts 然后在book.js文件中添加配置项，以下是其中一种配置方式，更多配置参数，可查看官方文档。 { \"plugins\": [ \"flexible-alerts\" ], \"pluginsConfig\": { \"flexible-alerts\": { \"style\": \"flat\" } } } 例如给出具体的样式配置 \"flexible-alerts\": { // \"style\": \"flat\", \"note\": {\"label\" : \"注意\"}, \"tip\": {\"label\" : \"提示\"}, \"warning\": { \"label\": \"warning\" }, \"danger\": { \"label\": \"危险\" } } 使用方式如下，> [!NOTE]给出“提示”，后面跟着相关文本；其他提示框也类似，例如下面的“TIPs”。 > [!NOTE] > 文本 [!NOTE] An alert of type 'tip' using alert specific style 'flat' which overrides global style 'callout'. In addition, this alert uses an own heading and hides specific icon. > [!TIP] > An alert of type 'tip' using alert specific style 'flat' which overrides global style 'callout'. > In addition, this alert uses an own heading and hides specific icon. [!TIP] An alert of type 'tip' using alert specific style 'flat' which overrides global style 'callout'. In addition, this alert uses an own heading and hides specific icon. 更多高级用法，参考官方文档。 菜单折叠 插件gitbook-plugin-expandable-chapters用于折叠菜单，参考官方文档，首先在项目中安装该插件。 npm i gitbook-plugin-expandable-chapters 然后在book.js文件中添加配置项 { plugins: [\"expandable-chapters\"], \"pluginsConfig\": { \"expandable-chapters\":{} } } 页内导航与返回顶部 插件gitbook-plugin-anchor-navigation-ex用于页内导航和返回顶部，参考官方文档，首先在项目中安装该插件。 npm i gitbook-plugin-anchor-navigation-ex 然后在book.js文件中添加配置项 { \"plugins\": [ \"anchor-navigation-ex\" ] } 该插件解决了插件gitbook-plugin-page-toc的问题，合并了插件gitbook-plugin-back-to-top-button和插件gitbook-plugin-page-toc的功能。该插件更详细的配置如下 \"anchor-navigation-ex\":{ \"showLevel\": true, \"associatedWithSummary\": true, \"printLog\": false, \"multipleH1\": true, \"mode\": \"pageTop\", // pageTop or float \"showGoTop\":true, \"float\": {//悬浮在右上角 \"floatIcon\": \"fa fa-navicon\", \"showLevelIcon\": false, \"level1Icon\": \"fa fa-hand-o-right\", \"level2Icon\": \"fa fa-hand-o-right\", \"level3Icon\": \"fa fa-hand-o-right\" }, \"pageTop\": {//页面底部插入 \"showLevelIcon\": false, \"level1Icon\": \"fa fa-hand-o-right\", \"level2Icon\": \"fa fa-hand-o-right\", \"level3Icon\": \"fa fa-hand-o-right\" } } 插件gitbook-plugin-page-toc的返回顶部按钮固定不变，有些呆板，可以设置参数showGoTop为false，然后用插件gitbook-plugin-back-to-top-button设置返回顶部按钮。 TeX 公式 插件gitbook-plugin-katex用于处理 TEX 公式，参考官方文档，首先在项目中安装该插件。 npm i gitbook-plugin-katex 然后在book.js文件中添加配置项，以下是其中一种配置方式，更多配置参数，可查看官方文档。 { \"plugins\": [\"katex\"] } 例如，下面的代码，放在两个 $$ 之间，与latex的语法格式相同，编译之后就是latex公式。 Inline math: {% math %}\\int_{-\\infty}^\\infty g(x) dx{% endmath %} Block math: {% math %} \\int_{-\\infty}^\\infty g(x) dx {% endmath %} Inline math: ∫−∞∞g(x)dx\\int_{-\\infty}^\\infty g(x) dx∫​−∞​∞​​g(x)dx Block math: ∫−∞∞g(x)dx \\int_{-\\infty}^\\infty g(x) dx ∫​−∞​∞​​g(x)dx $$ 在gitbook中有特殊含义，表示数学公式的开始，要打印 $$，可以用转义的方式，如 \\$\\$。 搭建免费个人网站 目标：基于GitHub服务用Gitbook搭建免费个人网站，私有库备份源码，公有库作为个人网站。 1、创建两个github仓库，一个私有仓库，一个公有仓库，公有仓库的名称必须是usename.github.io，其中usename就是GitHub的用户名。 2、将本地项目同步到私有仓库，关于私有仓库、公有仓库创建、同步等操作，参考本地同步上传、下载、新建github项目，一步到位，主要命令 git init git remote add origin xxxx git add . git commit -m \"message\" git push origin main 在输入上述命令之前，先做以下操作： 在Gitbook项目中，需要加载很多组件，在同步项目到github的时候，可以去除这些组件，只需要在gitbook项目中，创建一个新的文件“.gitignore”，然后在文件中加入 node_modules/ 这样，在上传项目的时候，就不会把node_modules目录添加到github上。 [!TIP] 一个笔记网站中，可能会涉及到非常多的子项目，部分子项目可能还处于更新阶段，或者处于保密阶段，不适合直接公开。这时候可以通过配置“.gitignore”，避免将所有文件公开出去。例如在文件中添加 _book/xxx/ 那么_book/xxx/中的html文件将不会上传到公有库，但是xxx的源码会被更新到私有库，从而完成统一备份。有意思的是，在本地调试的时候，不会受到影响，仍然可以通过浏览器正常访问未公开的部分。也就是说，这个设置只是没有将保密的部分提交到公有库，本地仓库不会受影响。 在clone项目之后，就需要重新安装相关的模块，否则无法编译通过。需要安装的模块在book.js文件的plugins插件列表中查看，可以通过插件官网查询对应的插件，并用对应的命令安装，例如 npm install package 参考gitbook美化代码格式化排版，代码高亮设置 3、将本地gitbook编译好的项目上传到github，这时候只需要上传项目中_book文件夹里面的所有文件即可，github仓库也只能通过静态页面展示个人网站内容，非静态页面无法展示。 git remote add public xxxxx git subtree push --prefix=_book public main 首先添加公有仓库的地址xxxx，然后用subtree将项目推送到github，这样就完成了个人网站的部署工作，部署完成之后，只需要通过usename.github.io就可以访问到个人网站。 4、当个人网站项目再次更新之后，需要重新推送到github，只需要重复上述命令即可 npm run build git add . git commit -m \"message\" git push origin main git subtree push --prefix=_book public main 第一条命令是编译打包项目，使得markdown文件编译为html静态网页。后面几条命令是提交到私有仓库，最后一条命令是将静态页面提交到公有仓库。 下面是更详细的步骤 GitHub仓库建立和更新 1、创建github账号，没有github账号，就不能进入后台。 2、创建一个仓库：点击右上角的图标，选择仓库，就可以进入相应的界面，然后新建一个仓库。 新建仓库的时候，可以选择仓库是私有的还是公有的，私有仓库只能自己可见，或者加入到仓库里面的管理者可见，公有仓库所有人可见 添加一个仓库名称，选择是否添加readme.md文件，对项目进行简单描述等 3、在本地配置github账号信息 首先应该下载安装好github，这个比较简单，不再赘述，下面配置用户名和邮箱，用户名就是github上账号的名称 git config user.name \"新用户名\" git config --global user.email \"新的邮箱地址\" 查看配置信息，将会看到配置好的用户名和邮箱 cat ~/.gitconfig 配置SSH密钥，这一步非常重要，等下上传下载项目的时候就需要，这里的邮箱就是账号的注册邮箱 ssh-keygen -t rsa -b 4096 -C \"新的邮箱地址\" 完成这个步骤，将会在本地看到github生成的公私钥对，默认在 ~/.ssh/ 实际的存储位置，在执行密钥生成命令的时候，会进行选择，如果选择默认，就会在.ssh目录下。 完成这个步骤，就可以在GitHub上面添加公钥：进入setting选项，找到SSH密钥位置，选择添加新密钥，这个密钥就是本地生成的公钥。 4、本地项目与github同步 第一次使用的时候，如果在github上面没有添加内容，把本地项目上传到github，基本操作如下 git init git add README.md git commit -m \"first commit\" git branch -M main git remote add origin 地址 git push -u origin main 这里的地址就是项目地址，选择SSH地址，因为前面配置了SSH密钥 如果已经有相关的内容，那就需要更新本地仓库 git remote add origin 地址 git branch -M main git push -u origin main 需要注意的是，GitHub每次操作的目录，就是当前目录 完成第一次连接之后，以后的操作相对简单 更新文件之前，先拉取项目，这个方式拉取项目，跟git clone拉取项目是不一样的，最明显的区别就是目录层级 git pull origin main 提交代码到GitHub git add . git commit -m \"更新内容\" git push origin main 以上操作都是在操作私有库，要将静态文件的代码提交到公有库，还需要执行下面命令 git remote add public xxxxx git subtree push --prefix=_book public main 首先添加公有仓库的地址xxxx，然后用subtree将项目推送到github，这样就完成了个人网站的部署工作，部署完成之后，只需要通过usename.github.io就可以访问到个人网站。 当个人网站项目再次更新之后，需要重新推送到github，只需要重复上述命令即可 npm run build git add . git commit -m \"message\" git push origin main git subtree push --prefix=_book public main 网站美化和完善 本文的简洁版参考基于GitHub服务用Gitbook搭建免费个人网站 Gitbook项目不需要写代码就能完成网站建设，是基于它提供的强大插件基础实现的，一个原始的Gitbook项目编译之后得到的网站并不好看，需要不断美化和完整。 关于网站美化以及其他需要完善的部分参考Gitbook操作指南。 除去网站美化之外，就是网站本身的内容建设。Gitbook是一个文本编辑工具，只需要掌握简单的MarkDown语法就可以使用，关于MarkDown的使用技巧参考MarkDown使用指南。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-20 "},"note/intro.html":{"url":"note/intro.html","title":"集合（零散）","keywords":"","body":"笔记 学习、科研过程中整理的笔记，比较零散，没有分类。 资源集合 基于GitHub服务用Gitbook搭建免费个人网站 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-16 "},"note/source.html":{"url":"note/source.html","title":"资源集合","keywords":"","body":"资源 非常丰富好用的图标，不需要下载，直接复制即可，且免费。 英文论文写作的语法校验工具grammarly。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-29 "},"note/gitbook-github.html":{"url":"note/gitbook-github.html","title":"基于GitHub服务用Gitbook搭建免费个人网站","keywords":"","body":"基于GitHub服务用Gitbook搭建免费个人网站 搭建个人免费网站，需要解决几个关键问题，第一个问题是做一个个人网站，用什么工具做个人网站？第二个问题是个人网站部署在哪里，最重要的是免费。 第一个问题，选择Gitbook设计网站，相对简单，只需要掌握简单的语法规则，文档全部用markdown来写，关于Gitbook设计网站的教程，参考gitbook快速搭建第一个个人博客项目 第二个问题，哪里有免费的服务器可以部署个人网站？GitHub就提供了这样的服务，选择GitHub有几个优先：第一，免费，长期有效；第二，同步代码，代码备份。 本文将用Github部署个人网站，有两点要求，一是Gitbook项目源码私有（private），二是GitHub部署Gitbook打包的个人网站，必须公有（public）。 0、准备一个gitbook项目，关于gitbook项目的创建，参考Gitbook配置教程，快速搭建个人博客，制作个人电子书、帮助（说明）文档和gitbook快速搭建第一个个人博客项目 1、创建两个github仓库，一个私有仓库，一个公有仓库，公有仓库的名称必须是usename.github.io，其中usename就是GitHub的用户名。 2、将本地项目同步到私有仓库，关于私有仓库、公有仓库创建、同步等操作，参考本地同步上传、下载、新建github项目，一步到位，主要命令 git init git remote add origin xxxx git add . git commit -m \"message\" git push origin main 在输入上述命令之前，先做以下操作： 在Gitbook项目中，需要加载很多组件，在同步项目到github的时候，可以去除这些组件，只需要在gitbook项目中，创建一个新的文件“.gitignore”，然后在文件中加入 node_modules/ 这样，在上传项目的时候，就不会把node_modules目录添加到github上。 在clone项目之后，就需要重新安装相关的模块，否则无法编译通过。需要安装的模块在book.js文件的plugins插件列表中查看，可以通过插件官网查询对应的插件，并用对应的命令安装，例如 npm install package 参考gitbook美化代码格式化排版，代码高亮设置 3、将本地gitbook编译好的项目上传到github，这时候只需要上传项目中_book文件夹里面的所有文件即可，github仓库也只能通过静态页面展示个人网站内容，非静态页面无法展示。 git remote add public xxxxx git subtree push --prefix=_book public main 首先添加公有仓库的地址xxxx，然后用subtree将项目推送到github，这样就完成了个人网站的部署工作，部署完成之后，只需要通过usename.github.io就可以访问到个人网站。 4、当个人网站项目再次更新之后，需要重新推送到github，只需要重复上述命令即可 npm run serve git add . git commit -m \"message\" git push origin main git subtree push --prefix=_book public main 第一条命令是编译项目，使得markdown文件编译为html静态网页。后面几条命令是提交到私有仓库，最后一条命令是将静态页面提交到公有仓库。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-20 "},"crypto/intro.html":{"url":"crypto/intro.html","title":"密码学","keywords":"","body":"密码学 这部分是密码学相关的学习笔记，主要介绍经典密码算法。 AES加密算法C/C++实现 用指令集实现AES © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-18 "},"crypto/AES/intro.html":{"url":"crypto/AES/intro.html","title":"AES加密算法C/C++实现","keywords":"","body":"AES 加密算法C/C++实现 这部分介绍AES加密算法的实现，从最简单的用标准C语言实现，到用GPU等处理器实现，对比各种实现方式的优势。 待补充。。。 XTS 模式、HCTR 模式、XCB 模式和 EME2 模式四种加密方案入选国内或国际标准，《可调加密方案的软件优化实现》用指令集实现了这四种加密方案，论文的代码参考GitHub。本文在实现AES加密的时候，参考该方案的源码。 用指令集实现AES（XTS 模式） © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-19 "},"crypto/AES/instruct.html":{"url":"crypto/AES/instruct.html","title":"用指令集实现AES（XTS 模式）","keywords":"","body":"用指令集实现AES加密算法（XTS 模式） 本文不再讨论实现方案的性能表现，只做技术解析。本文针对XTS模式，用简单的案例重新编排源码，逐步分析AES加密过程，方便读者理解代码结构和实现的功能。 初始化项目和预备工作 创建一个简单的C语言程序，程序从main()开始，作为项目初始化。 #include #include #include int main(){ return 0; } 声明创建文件函数 准备一个文件夹，方便加密之后的结果存储。 #include void createFolder(char *foldername) { struct stat st = {0}; if (stat(foldername, &st) == -1) { mkdir(foldername, 0777); printf(\"create done.\"); } return; } 调用createFolder()，可以创建一个文件夹，且该文件夹可读可写（0777，由stat()设置）。 代码解析： sys/stat.h是 Unix/Linux 系统中的一个标准头文件，主要用于文件状态信息的获取和文件操作。 #include // 文件状态函数 // 通过文件路径获取文件状态 int stat(const char *pathname, struct stat *statbuf); // 通过文件描述符获取文件状态 int fstat(int fd, struct stat *statbuf); // 对于符号链接，获取链接本身的信息而不是指向的文件 int lstat(const char *pathname, struct stat *statbuf); // 文件操作函数 int chmod(const char *pathname, mode_t mode); int mkdir(const char *pathname, mode_t mode); struct stat 包含了文件的详细信息，不同系统可能略有差异，但通常包含： struct stat { dev_t st_dev; /* 文件所在设备的ID */ ino_t st_ino; /* inode编号 */ mode_t st_mode; /* 文件类型和权限 */ nlink_t st_nlink; /* 硬链接数 */ uid_t st_uid; /* 所有者的用户ID */ gid_t st_gid; /* 所有者的组ID */ dev_t st_rdev; /* 设备ID（如果是特殊文件） */ off_t st_size; /* 文件大小（字节） */ blksize_t st_blksize; /* 文件系统I/O的块大小 */ blkcnt_t st_blocks; /* 分配的512B块数量 */ /* 时间戳 */ time_t st_atime; /* 最后访问时间 */ time_t st_mtime; /* 最后修改时间 */ time_t st_ctime; /* 最后状态改变时间 */ }; 声明相关变量 声明AES加密将会用到的一些必要变量，并对变量进行初始化。在main()开始的时候，就调用了createFolder()创建文件夹result。 typedef unsigned char u8; #define ALIGN(n) __attribute__((aligned(n))) int main(){ createFolder(\"result\"); //linux，创建一个文件夹 unsigned int ui; ALIGN(16) u8 key[32]; ALIGN(16) u8 pt[4096] = {0}; ALIGN(16) u8 tag[16]; u8 tweak[16]; unsigned long long clock1, clock2; // 用于时间统计 double cpb[101]; // init for (int i = 0; i 代码解析： 定义一个__attribute__((aligned(n)))的别名ALIGN(n)，这是一个带参的宏定义，利用__attribute__设置变量属性，aligned 属性用于指定变量或类型的内存对齐要求，确保数据在内存中的地址符合特定的对齐边界。 这里定义了unsigned char类型变量key、pt、tag、tweak，分别用于存储轮密钥、可调密钥、标识、可调值，其中要求变量key、pt、tag为16字节对齐。 内存创建 定义ae_allocate()，根据系统类型创建内存。 #include struct _ae_ctx { uint8_t K1[16 * 15]; // 240字节的密钥数组 uint8_t K2[16 * 15]; // 240字节的密钥数组 }; typedef struct _ae_ctx ae_ctx; #define USE_MM_MALLOC ((__SSE2__ || _M_IX86_FP >= 2) && !(_M_X64 || __x86_64__)) #define USE_POSIX_MEMALIGN (__ALTIVEC__ && __GLIBC__ && !__PPC64__) ae_ctx *ae_allocate(void *misc) { void *p; (void)misc; /* misc unused in this implementation，显式忽略未使用参数 */ #if USE_MM_MALLOC // 使用 Intel 内在函数的分配器 p = _mm_malloc(sizeof(ae_ctx), 16); #elif USE_POSIX_MEMALIGN // 使用 POSIX 标准对齐分配 if (posix_memalign(&p, 16, sizeof(ae_ctx)) != 0) p = NULL; #else p = malloc(sizeof(ae_ctx)); #endif return (ae_ctx *)p; } #define USE_MM_MALLOC ((__SSE2__ || _M_IX86_FP >= 2) && !(_M_X64 || __x86_64__))用于检测是否可以使用 _mm_malloc 进行对齐内存分配，主要针对 x86/x64 架构的 SIMD 指令集支持情况进行判断。 #define USE_POSIX_MEMALIGN (__ALTIVEC__ && __GLIBC__ && !__PPC64__)用于检测是否可以使用 posix_memalign 进行对齐内存分配，主要针对 PowerPC 架构的 Altivec (VMX) 指令集支持情况进行判断。 本文在实验的时候用的是Linux系统，所以会执行malloc(sizeof(ae_ctx));创建内存单元，这是一种基础的内存申请方式。 内存释放 与内存创建对应的是内存释放，在动态申请内存之后，如果长期不释放内存，将导致内存资源耗尽。 void ae_free(ae_ctx *ctx) { #if USE_MM_MALLOC _mm_free(ctx); #else free(ctx); #endif } 在main()中调用上述函数。 int main(){ createFolder(\"result\"); //linux，创建一个文件夹 unsigned int ui; ALIGN(16) u8 key[32]; ALIGN(16) u8 pt[4096] = {0}; ALIGN(16) u8 tag[16]; u8 tweak[16]; unsigned long long clock1, clock2; double cpb[101]; // init for (int i = 0; i AES密钥生成函数 AES加密需要多轮加密，每一轮都需要一个密钥，定义密钥生成函数。 #include #include #define MAX_KEY_BYTES 16 typedef struct { __m128i rd_key[7 + MAX_KEY_BYTES / 4]; // random key set } AES_KEY; // 使用SIMD指令实现的128位数据处理函数，主要用于某种加密或哈希算法的辅助计算。 static __m128i assist128(__m128i a, __m128i b) { // 将128位寄存器整体左移指定字节数，左移4字节（32位） __m128i tmp = _mm_slli_si128(a, 0x04); // a = a ^ tmp a = _mm_xor_si128(a, tmp); // 将原始 a 与左移后的 tmp 进行按位异或 tmp = _mm_slli_si128(tmp, 0x04); a = _mm_xor_si128(_mm_xor_si128(a, tmp), _mm_slli_si128(tmp, 0x04)); // _mm_shuffle_epi32: fill 128 bits with hightest 32 bits，将 b 的最高32位复制到整个128位寄存器 return _mm_xor_si128(a, _mm_shuffle_epi32(b, 0xff)); } static void AES_set_encrypt_key(const unsigned char *userKey, const int bits, AES_KEY *key) { __m128i *sched = key->rd_key; (void)bits; /* Supress \"unused\" warning */ sched[0] = _mm_loadu_si128((__m128i *)userKey); // _mm_aeskeygenassist_si128 辅助生成 AES 算法的轮密钥 sched[1] = assist128(sched[0], _mm_aeskeygenassist_si128(sched[0], 0x1)); sched[2] = assist128(sched[1], _mm_aeskeygenassist_si128(sched[1], 0x2)); sched[3] = assist128(sched[2], _mm_aeskeygenassist_si128(sched[2], 0x4)); sched[4] = assist128(sched[3], _mm_aeskeygenassist_si128(sched[3], 0x8)); sched[5] = assist128(sched[4], _mm_aeskeygenassist_si128(sched[4], 0x10)); sched[6] = assist128(sched[5], _mm_aeskeygenassist_si128(sched[5], 0x20)); sched[7] = assist128(sched[6], _mm_aeskeygenassist_si128(sched[6], 0x40)); sched[8] = assist128(sched[7], _mm_aeskeygenassist_si128(sched[7], 0x80)); sched[9] = assist128(sched[8], _mm_aeskeygenassist_si128(sched[8], 0x1b)); sched[10] = assist128(sched[9], _mm_aeskeygenassist_si128(sched[9], 0x36)); } int ae_init(ae_ctx *ctx, const void *key, int key_len, int nonce_len, int tag_len) { AES_set_encrypt_key(key, 0, (AES_KEY *)ctx->K1); // (AES_KEY *)ctx->K1 将 uint8_t[240] 强制转换为 AES_KEY* AES_set_encrypt_key((unsigned char *)key + 16, 0, (AES_KEY *)ctx->K2); return 0; } 如果还是用gcc xx.c编译或者直接执行该文件，可能报如下类型错误。 error: ‘__builtin_ia32_aeskeygenassist128’ needs isa option -maes -msse2 82 | sched[1] = assist128(sched[0], _mm_aeskeygenassist_si128(sched[0], 0x1)); 这个错误表明代码使用了 AES-NI 指令集，但编译器没有启用相应的指令集支持。__builtin_ia32_aeskeygenassist128为Intel AES 指令集的内在函数，needs isa option -maes -msse2提示需要启用 AES 和 SSE2 指令集支持。 现在修改main()函数，增加参数选项，重新调用密钥生成函数。 int main(int argc, char **argv){ createFolder(\"result\"); //linux，创建一个文件夹 unsigned int ui; ALIGN(16) u8 key[32]; ALIGN(16) u8 pt[4096] = {0}; ALIGN(16) u8 tag[16]; u8 tweak[16]; unsigned long long clock1, clock2; double cpb[101]; // init for (int i = 0; i 用下面的命令执行上述代码，本文案例用gcc -march=native -O2 -maes xxx.c命令编译该文件，将得到a.out可执行文件。 # 开发环境（使用本地CPU支持的所有特性） gcc -march=native -O2 -maes your_code.c -o program # 可移植版本（明确指定所需指令集） gcc -msse2 -msse4.1 -maes -O2 your_code.c -o program # 如果目标CPU较老，可能需要 gcc -msse2 -mpclmul -maes -O2 your_code.c -o program 输出函数 在测试和解析密钥生成函数之前，先定义输出函数。从上面的代码不难看出，密钥将是__m128i类型，并放在ae_ctx类型结构中，并不能直接用printf()打印输出，需要转换输出格式。 // 输出单个轮密钥（16字节） void print_round_key(const char* name, const uint8_t* round_key) { printf(\"%-40s[0x\", name); for (int i = 0; i round_key为uint8_t类型，然后按照%02x的格式输出每个字节。 #include int snprintf(char *str, size_t size, const char *format, ...); snprintf 函数是 C 标准库中的一个重要函数，用于安全地格式化字符串到缓冲区。 str: 指向目标缓冲区的指针，用于存储格式化后的字符串 size: 缓冲区的大小（包括字符串终止符 \\0） format: 格式字符串，指定输出的格式 ...: 可变参数，根据格式字符串提供相应的值 测试和分析 按照下面方式调用，打印轮密钥，然后分析密钥生成算法 print_all_round_keys(\"K1\", ctx->K1); print_all_round_keys(\"K2\", ctx->K2); 调用print_all_round_keys()输出如下 K1 Round 0 [0x000102030405060708090a0b0c0d0e0f] K1 Round 1 [0xd6aa74fdd2af72fadaa678f1d6ab76fe] K1 Round 2 [0xb692cf0b643dbdf1be9bc5006830b3fe] K1 Round 3 [0xb6ff744ed2c2c9bf6c590cbf0469bf41] K1 Round 4 [0x47f7f7bc95353e03f96c32bcfd058dfd] K1 Round 5 [0x3caaa3e8a99f9deb50f3af57adf622aa] K1 Round 6 [0x5e390f7df7a69296a7553dc10aa31f6b] K1 Round 7 [0x14f9701ae35fe28c440adf4d4ea9c026] K1 Round 8 [0x47438735a41c65b9e016baf4aebf7ad2] K1 Round 9 [0x549932d1f08557681093ed9cbe2c974e] K1 Round 10 [0x13111d7fe3944a17f307a78b4d2b30c5] K1 Round 11 [0x00000000000000000000000000000000] K1 Round 12 [0x00000000000000000000000000000000] K1 Round 13 [0x00000000000000000000000000000000] K1 Round 14 [0x00000000000000000000000000000000] K2 Round 0 [0x101112131415161718191a1b1c1d1e1f] K2 Round 1 [0xb563d28fa176c498b96fde83a572c09c] K2 Round 2 [0xf7d90c8956afc811efc016924ab2d60e] K2 Round 3 [0xc42fa75f92806f4e7d4079dc37f2afd2] K2 Round 4 [0x455612c5d7d67d8baa9604579d64ab85] K2 Round 5 [0x1634859bc1e2f8106b74fc47f61057c2] K2 Round 6 [0xfc6fa0d93d8d58c956f9a48ea0e9f34c] K2 Round 7 [0xa26289399fefd1f0c916757e69ff8632] K2 Round 8 [0x3426aac0abc97b3062df0e4e0b20887c] K2 Round 9 [0x98e2baeb332bc1db51f4cf955ad447e9] K2 Round 10 [0xe642a455d569658e849daa1bde49edf2] K2 Round 11 [0x00000000000000000000000000000000] K2 Round 12 [0x00000000000000000000000000000000] K2 Round 13 [0x00000000000000000000000000000000] K2 Round 14 [0x00000000000000000000000000000000] 用户密钥在初始化的时候确定，为32字节的无符号数值（unsigned char类型），数值为0∼310 \\sim 310∼31，放在ALIGN(16) u8 key[32];的key中，然后由_mm_loadu_si128()加载到sched[0]中，前半段值为0x000102030405060708090a0b0c0d0e0f；后半段由AES_set_encrypt_key((unsigned char *)key + 16, 0, (AES_KEY *)ctx->K2);调用，值为0x101112131415161718191a1b1c1d1e1f。ctx存储的是轮密钥，初始值为全0，这个应该是在申请内存单元的时候由系统自动初始化。 现在着重分析assist128()和AES_set_encrypt_key()。前半段密钥输入0x000102030405060708090a0b0c0d0e0f，经过assist128()的哈希作用，输出0xd6aa74fdd2af72fadaa678f1d6ab76fe；后半段密钥输入0x101112131415161718191a1b1c1d1e1f，输出0xb563d28fa176c498b96fde83a572c09c。 在讨论计算过程之前，先看_mm_aeskeygenassist_si128()的作用，它是 Intel AES-NI 指令集的内在函数，用于 AES 密钥扩展，帮助生成 AES 加密的轮密钥。 #include // AES-NI 头文件 __m128i _mm_aeskeygenassist_si128(__m128i key, const int round_const); 参数说明： key: 当前的轮密钥（128 位） round_const: 轮常数，用于密钥扩展算法（8 位立即数） 返回值：返回一个 __m128i 类型的 128 位向量，包含用于生成下一轮密钥的辅助数据。 在assist128()作用之前，_mm_aeskeygenassist_si128()将前半段密钥输入0x000102030405060708090a0b0c0d0e0f变成了0xf26b6fc56a6fc5f2fed7ab76d6ab76fe，将后半段密钥输入0x101112131415161718191a1b1c1d1e1f变成了0xfa5947f05847f0fa9ca472c0a572c09c。这个过程是经过_mm_aeskeygenassist_si128会加入轮常量，10轮变换的轮常量如下。 轮数 1 2 3 4 5 6 7 8 9 10 轮常量 0x01 0x02 0x04 0x08 0x10 0x20 0x40 0x80 0x1B 0x36 用户密钥0∼310 \\sim 310∼31（即0x000102030405060708090a0b0c0d0e0f和0x101112131415161718191a1b1c1d1e1f）经过密钥扩展，每一轮的密钥如下。 轮数 前半段_mm_aeskeygenassist_si128() 前半段assist128() 后半段_mm_aeskeygenassist_si128() 后半段assist128() 1 0xf26b6fc56a6fc5f2fed7ab76d6ab76fe 0xd6aa74fdd2af72fadaa678f1d6ab76fe 0xfa5947f05847f0fa9ca472c0a572c09c 0xb563d28fa176c498b96fde83a572c09c 2 0xb579402d7b402db5f66238bb6038bbf6 0xb692cf0b643dbdf1be9bc5006830b3fe 0x32381c463a1c46320640bade42bade06 0xf7d90c8956afc811efc016924ab2d60e 3 0x43277aa1237aa14345046dbb006dbb45 0xb6ff744ed2c2c9bf6c590cbf0469bf41 0xb179e8827de882b1d637f6ab33f6abd6 0xc42fa75f92806f4e7d4079dc37f2afd2 4 0xb525dd082ddd08b5f2f90883f10883f2 0x47f7f7bc95353e03f96c32bcfd058dfd 0x4fcda82fc5a82f4f9a8979b58179b59a 0x455612c5d7d67d8baa9604579d64ab85 5 0x2a96b27b86b27b2a546b5d547b5d5454 0x3caaa3e8a99f9deb50f3af57adf622aa 0x0ef6ff3de6ff3d0e5e4362975362975e 0x1634859bc1e2f8106b74fc47f61057c2 6 0xd3db5ee9fb5ee9d3954293ac6293ac95 0x5e390f7df7a69296a7553dc10aa31f6b 0x789841cab841ca7842ca5b25ea5b2542 0xfc6fa0d93d8d58c956f9a48ea0e9f34c 7 0x68244f90644f9068670ac07f4ac07f67 0x14f9701ae35fe28c440adf4d4ea9c026 0x275d6add1d6add27e01e0d295e0d29e0 0xa26289399fefd1f0c916757e69ff8632 8 0x11cf98644f9864112fd3baf753baf72f 0x47438735a41c65b9e016baf4aebf7ad2 0xdbdf3e8c5f3e8cdbf9164423964423f9 0x3426aac0abc97b3062df0e4e0b20887c 9 0x499c4d56874d5649e408dab513dab5e4 0x549932d1f08557681093ed9cbe2c974e 0x62dd2104c62104622bb7c410acc4102b 0x98e2baeb332bc1db51f4cf955ad447e9 10 0x8c975b45a15b458cae71882f47882fae 0x13111d7fe3944a17f307a78b4d2b30c5 0xc3f178b9c778b9c3be48a01e7ea01ebe 0xe642a455d569658e849daa1bde49edf2 assist128()在密钥生成过程中，每一轮每一步骤的输出如下，其中c表示_mm_shuffle_epi32()的输出。 论数 初始a 初始b tmp a tmp a c return 1 0x000102030405060708090a0b0c0d0e0f 0xf26b6fc56a6fc5f2fed7ab76d6ab76fe 0x00000000000102030405060708090a0b 0x00010203040404040c0c0c0c04040404 0x00010203040404040c0c0c0c04040404 0x00010203040404040c0d0e0f00000000 0xd6ab76fed6ab76fed6ab76fed6ab76fe 0xd6aa74fdd2af72fadaa678f1d6ab76fe 2 0xd6aa74fdd2af72fadaa678f1d6ab76fe 0xb579402d7b402db5f66238bb6038bbf6 0x00000000d6aa74fdd2af72fadaa678f1 0xd6aa74fd0405060708090a0b0c0d0e0f 0xd6aa74fd0405060708090a0b0c0d0e0f 0xd6aa74fd04050607dea37ef608080808 0x6038bbf66038bbf66038bbf66038bbf6 0xb692cf0b643dbdf1be9bc5006830b3fe 3 0xb692cf0b643dbdf1be9bc5006830b3fe 0x43277aa1237aa14345046dbb006dbb45 0x00000000b692cf0b643dbdf1be9bc500 0xb692cf0bd2af72fadaa678f1d6ab76fe 0xb692cf0bd2af72fadaa678f1d6ab76fe 0xb692cf0bd2af72fa6c34b7fa04040404 0x006dbb45006dbb45006dbb45006dbb45 0xb6ff744ed2c2c9bf6c590cbf0469bf41 4 0xb6ff744ed2c2c9bf6c590cbf0469bf41 0xb525dd082ddd08b5f2f90883f10883f2 0x00000000b6ff744ed2c2c9bf6c590cbf 0xb6ff744e643dbdf1be9bc5006830b3fe 0xb6ff744e643dbdf1be9bc5006830b3fe 0xb6ff744e643dbdf10864b14e0c0d0e0f 0xf10883f2f10883f2f10883f2f10883f2 0x47f7f7bc95353e03f96c32bcfd058dfd 5 0x47f7f7bc95353e03f96c32bcfd058dfd 0x2a96b27b86b27b2a546b5d547b5d5454 0x0000000047f7f7bc95353e03f96c32bc 0x47f7f7bcd2c2c9bf6c590cbf0469bf41 0x47f7f7bcd2c2c9bf6c590cbf0469bf41 0x47f7f7bcd2c2c9bf2baefb03d6ab76fe 0x7b5d54547b5d54547b5d54547b5d5454 0x3caaa3e8a99f9deb50f3af57adf622aa 6 0x3caaa3e8a99f9deb50f3af57adf622aa 0xd3db5ee9fb5ee9d3954293ac6293ac95 0x000000003caaa3e8a99f9deb50f3af57 0x3caaa3e895353e03f96c32bcfd058dfd 0x3caaa3e895353e03f96c32bcfd058dfd 0x3caaa3e895353e03c5c691546830b3fe 0x6293ac956293ac956293ac956293ac95 0x5e390f7df7a69296a7553dc10aa31f6b 7 0x5e390f7df7a69296a7553dc10aa31f6b 0x68244f90644f9068670ac07f4ac07f67 0x000000005e390f7df7a69296a7553dc1 0x5e390f7da99f9deb50f3af57adf622aa 0x5e390f7da99f9deb50f3af57adf622aa 0x5e390f7da99f9deb0ecaa02a0469bf41 0x4ac07f674ac07f674ac07f674ac07f67 0x14f9701ae35fe28c440adf4d4ea9c026 8 0x14f9701ae35fe28c440adf4d4ea9c026 0x11cf98644f9864112fd3baf753baf72f 0x0000000014f9701ae35fe28c440adf4d 0x14f9701af7a69296a7553dc10aa31f6b 0x14f9701af7a69296a7553dc10aa31f6b 0x14f9701af7a69296b3ac4ddbfd058dfd 0x53baf72f53baf72f53baf72f53baf72f 0x47438735a41c65b9e016baf4aebf7ad2 9 0x47438735a41c65b9e016baf4aebf7ad2 0x499c4d56874d5649e408dab513dab5e4 0x0000000047438735a41c65b9e016baf4 0x47438735e35fe28c440adf4d4ea9c026 0x47438735e35fe28c440adf4d4ea9c026 0x47438735e35fe28c03495878adf622aa 0x13dab5e413dab5e413dab5e413dab5e4 0x549932d1f08557681093ed9cbe2c974e 10 0x549932d1f08557681093ed9cbe2c974e 0x8c975b45a15b458cae71882f47882fae 0x00000000549932d1f08557681093ed9c 0x549932d1a41c65b9e016baf4aebf7ad2 0x549932d1a41c65b9e016baf4aebf7ad2 0x549932d1a41c65b9b48f88250aa31f6b 0x47882fae47882fae47882fae47882fae 0x13111d7fe3944a17f307a78b4d2b30c5 1 0x101112131415161718191a1b1c1d1e1f 0xfa5947f05847f0fa9ca472c0a572c09c 0x00000000101112131415161718191a1b 0x10111213040404040c0c0c0c04040404 0x10111213040404040c0c0c0c04040404 0x10111213040404041c1d1e1f00000000 0xa572c09ca572c09ca572c09ca572c09c 0xb563d28fa176c498b96fde83a572c09c 2 0xb563d28fa176c498b96fde83a572c09c 0x32381c463a1c46320640bade42bade06 0x00000000b563d28fa176c498b96fde83 0xb563d28f1415161718191a1b1c1d1e1f 0xb563d28f1415161718191a1b1c1d1e1f 0xb563d28f14151617ad7ac89408080808 0x42bade0642bade0642bade0642bade06 0xf7d90c8956afc811efc016924ab2d60e 3 0xf7d90c8956afc811efc016924ab2d60e 0xb179e8827de882b1d637f6ab33f6abd6 0x00000000f7d90c8956afc811efc01692 0xf7d90c89a176c498b96fde83a572c09c 0xf7d90c89a176c498b96fde83a572c09c 0xf7d90c89a176c4984eb6d20a04040404 0x33f6abd633f6abd633f6abd633f6abd6 0xc42fa75f92806f4e7d4079dc37f2afd2 4 0xc42fa75f92806f4e7d4079dc37f2afd2 0x4fcda82fc5a82f4f9a8979b58179b59a 0x00000000c42fa75f92806f4e7d4079dc 0xc42fa75f56afc811efc016924ab2d60e 0xc42fa75f56afc811efc016924ab2d60e 0xc42fa75f56afc8112befb1cd1c1d1e1f 0x8179b59a8179b59a8179b59a8179b59a 0x455612c5d7d67d8baa9604579d64ab85 5 0x455612c5d7d67d8baa9604579d64ab85 0x0ef6ff3de6ff3d0e5e4362975362975e 0x00000000455612c5d7d67d8baa960457 0x455612c592806f4e7d4079dc37f2afd2 0x455612c592806f4e7d4079dc37f2afd2 0x455612c592806f4e38166b19a572c09c 0x5362975e5362975e5362975e5362975e 0x1634859bc1e2f8106b74fc47f61057c2 6 0x1634859bc1e2f8106b74fc47f61057c2 0x789841cab841ca7842ca5b25ea5b2542 0x000000001634859bc1e2f8106b74fc47 0x1634859bd7d67d8baa9604579d64ab85 0x1634859bd7d67d8baa9604579d64ab85 0x1634859bd7d67d8bbca281cc4ab2d60e 0xea5b2542ea5b2542ea5b2542ea5b2542 0xfc6fa0d93d8d58c956f9a48ea0e9f34c 7 0xfc6fa0d93d8d58c956f9a48ea0e9f34c 0x275d6add1d6add27e01e0d295e0d29e0 0x00000000fc6fa0d93d8d58c956f9a48e 0xfc6fa0d9c1e2f8106b74fc47f61057c2 0xfc6fa0d9c1e2f8106b74fc47f61057c2 0xfc6fa0d9c1e2f810971b5c9e37f2afd2 0x5e0d29e05e0d29e05e0d29e05e0d29e0 0xa26289399fefd1f0c916757e69ff8632 8 0xa26289399fefd1f0c916757e69ff8632 0xdbdf3e8c5f3e8cdbf9164423964423f9 0x00000000a26289399fefd1f0c916757e 0xa26289393d8d58c956f9a48ea0e9f34c 0xa26289393d8d58c956f9a48ea0e9f34c 0xa26289393d8d58c9f49b2db79d64ab85 0x964423f9964423f9964423f9964423f9 0x3426aac0abc97b3062df0e4e0b20887c 9 0x3426aac0abc97b3062df0e4e0b20887c 0x62dd2104c62104622bb7c410acc4102b 0x000000003426aac0abc97b3062df0e4e 0x3426aac09fefd1f0c916757e69ff8632 0x3426aac09fefd1f0c916757e69ff8632 0x3426aac09fefd1f0fd30dfbef61057c2 0xacc4102bacc4102bacc4102bacc4102b 0x98e2baeb332bc1db51f4cf955ad447e9 10 0x98e2baeb332bc1db51f4cf955ad447e9 0xc3f178b9c778b9c3be48a01e7ea01ebe 0x0000000098e2baeb332bc1db51f4cf95 0x98e2baebabc97b3062df0e4e0b20887c 0x98e2baebabc97b3062df0e4e0b20887c 0x98e2baebabc97b30fa3db4a5a0e9f34c 0x7ea01ebe7ea01ebe7ea01ebe7ea01ebe 0xe642a455d569658e849daa1bde49edf2 加密算法 将XTS模式的AES加密算法放在不同并行数下测试，其测试结果可以参考《可调加密方案的软件优化实现》。下面根据不同并行数分别分析源码，从最简单的一个并行数开始。 并行数为1的XTS模式 下面是最简单的加密方式，并行数为1，源码和测试代码如下。 #include //linux int compare(const void *a, const void *b) { double ret = *(double *)a - *(double *)b; if (ret > 0) { return 1; } else if (ret K2; T = _mm_xor_si128(T, KEY[0]); for (int i = 1; i K1; for (int i = 0; i > 4); i++) { tmp = _mm_load_si128(&((__m128i *)pt)[i]); tmp = _mm_xor_si128(tmp, T); tmp = _mm_xor_si128(tmp, KEY[0]); for (int j = 1; j 测试代码：为了方便，将相关输出放到了文件中，所以在测试代码中添加了打开文件的代码。 int main(int argc, char **argv){ createFolder(\"result\"); //linux，创建一个文件夹 unsigned int ui; ALIGN(16) u8 key[32]; ALIGN(16) u8 pt[4096] = {0}; ALIGN(16) u8 tag[16]; u8 tweak[16]; unsigned long long clock1, clock2; double cpb[101]; // init for (int i = 0; i K1); // print_round_key(\"init\", ctx->K2); ae_init(ctx, key, 32, 0, 0); // 初始化密钥 // print_all_round_keys(\"K1\", ctx->K1); // print_all_round_keys(\"K2\", ctx->K2); int pt_len = 32; FILE *fp = NULL; fp = fopen(\"./result/XTS_1.txt\", \"w\"); while (pt_len 测试和解析 从ae_encrypt()的调用来看，参数说明如下 ctx：轮密钥 nonce：可调值，初始值全部为0 pt：明文 pt_len：明文分组长度，分块长度 ad： ad_len： ct：密文，用存储明文的pt存储 tag： final： 调用XTS_encrypt_1(pt, pt_len, nonce, ct, ctx);，输入了明文、明文分组长度、可调值、返回密文、轮密钥。注释掉while循环，测试XTS_encrypt_1()的输入输出。 变量 值 说明 nonce 0x00000000000000000000000000000000 初始的nonce值为0 T 0x00000000000000000000000000000000 初始加载的nonce值为0 KEY 0x101112131415161718191a1b1c1d1e1f 初始加载分组密钥的后半段 T 0x101112131415161718191a1b1c1d1e1f 与初始加载的分组密钥异或，得到的值与初始密钥相同 T 0x9edc773b9fe0e90e4f67e7626871c6aa 九轮加密的输出 T 0xeda330f90eecd16c003e5fb09bcff358 最后一轮加密的输出 KEY 0x000102030405060708090a0b0c0d0e0f 轮密钥后半段 pt 0x000102030405060708090a0b0c0d0e0f 明文0∼40950 \\sim 40950∼4095，这里只是输出了前面16个字节 Tmp 0xb8ddc9c0653a7fb0dc8425c7ef276dea 完成所有明文加密之后的密文 T 0x338fc2e43bb047b301f87cc16e3ecf63 倒数第二轮XTS模式的输出 XTS_encrypt_1()用XTS模式加密，前半部分只是加密K2K_2K​2​​，后半部分才对明文加密。xts_crank_lfsr()更新数据分组的TTT值。 在这个过程中，没有加入并行计算，TXS值作为输入持续更新。 相关工具说明 以下是XTS_encrypt_1()中用到的相关函数。 _mm_load_si128()是 SSE2 指令集的内在函数，用于从对齐的内存地址加载 128 位数据。 #include // SSE2 头文件 __m128i _mm_load_si128(__m128i const* mem_addr); mem_addr: 指向要加载数据的内存地址的指针，__m128i const*（指向 128 位整型向量的常量指针）必须是 16 字节对齐的地址 _mm_aesenc_si128()是 Intel AES-NI 指令集的内在函数，用于执行 AES 单轮加密操作。 #include // AES-NI 头文件 __m128i _mm_aesenc_si128(__m128i state, __m128i round_key); 参数说明 state: 当前的加密状态（128 位数据块） round_key: 当前轮的轮密钥（128 位） 返回一个 __m128i 类型的 128 位向量，包含加密一轮后的数据状态 _mm_aesenclast_si128()是 Intel AES-NI 指令集的内在函数，用于执行 AES 最终轮加密操作。 #include // AES-NI 头文件 __m128i _mm_aesenclast_si128(__m128i state, __m128i round_key); 参数说明 state: 当前的加密状态（128 位数据块） round_key: 最终轮的轮密钥（128 位） 返回一个 __m128i 类型的 128 位向量，包含最终加密后的数据（密文） xts_crank_lfsr()中用到的函数如下 _mm_set_epi32() 是 SSE2 指令集的内在函数，用于从四个 32 位整数创建 128 位向量。 #include // SSE2 头文件 __m128i _mm_set_epi32(int e3, int e2, int e1, int e0); 参数说明 e3: 最高位的 32 位整数（位置 3） e2: 次高位的 32 位整数（位置 2） e1: 次低位的 32 位整数（位置 1） e0: 最低位的 32 位整数（位置 0） 返回一个 __m128i 类型的 128 位向量，包含四个 32 位整数 _mm_shuffle_epi32()是 SSE2 指令集的内在函数，用于对 128 位向量中的 4 个 32 位元素进行重新排列 #include // SSE2 头文件 __m128i _mm_shuffle_epi32(__m128i a, int imm8); 参数说明 a: 输入的 128 位向量，包含 4 个 32 位整数 imm8: 8 位立即数，控制洗牌模式（必须在编译时确定） 返回一个 __m128i 类型的 128 位向量，包含重新排列后的 4 个 32 位整数 _mm_srai_epi32()是 SSE2 指令集的内在函数，用于对 128 位向量中的 4 个 32 位有符号整数进行算术右移。 #include // SSE2 头文件 __m128i _mm_srai_epi32(__m128i a, int imm8); 参数说明 a: 输入的 128 位向量，包含 4 个 32 位有符号整数 imm8: 8 位立即数，指定右移的位数（0-31） 返回一个 __m128i 类型的 128 位向量，包含算术右移后的 4 个 32 位有符号整数 _mm_and_si128()是 SSE2 指令集的内在函数，用于对两个 128 位向量进行按位与操作。 #include // SSE2 头文件 __m128i _mm_and_si128(__m128i a, __m128i b); 参数说明 a: 第一个 128 位输入向量 b: 第二个 128 位输入向量 返回一个 __m128i 类型的 128 位向量，包含两个输入向量的按位与结果 _mm_slli_epi32()是 SSE2 指令集的内在函数，用于对 128 位向量中的 4 个 32 位整数进行逻辑左移。 #include // SSE2 头文件 __m128i _mm_slli_epi32(__m128i a, int imm8); 参数说明 a: 输入的 128 位向量，包含 4 个 32 位整数 imm8: 8 位立即数，指定左移的位数（0-31） 返回一个 __m128i 类型的 128 位向量，包含逻辑左移后的 4 个 32 位整数 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-26 "},"ai/intro.html":{"url":"ai/intro.html","title":"AI专题","keywords":"","body":"AI专题 AI相关的专题 AI写论文 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-30 "},"ai/paper.html":{"url":"ai/paper.html","title":"AI写论文","keywords":"","body":"AI写论文 DeepSeek写论文 DeepSeek生成论文的主要步骤： 1、定位相关领域的顶刊资源 Scimago可以查看各个领域的顶级期刊，然后选择所选领域的代表性期刊，投喂口令： I select some journals I am intersted in. Do you know these journals? .... 2、总结顶刊5大经典议题 把第一步找到的10本期刊提供给DeepSeek，让它总结对同一主题、不同学科或领域会有哪些不同研究方向，投喂口令： I am a master in gender study but I do not know how to reformulate my research questions of my master thesis. Please help me to analyese these journals to generate the questions according to my guildance and procedure. OK? Help me to analyese the 5 typical themes of the journals I sent to you. Please also offer their examples so that I can understand. 3、组合创新，提出研究问题 让DeepSeek在这5大议题里进行筛选和组合，同时让它给我组合创新的理由和方式，投喂口令： Please combine these topics and generate 10 new research questions. And tell me why and how you combine. 4、聚焦研究问题，拓展顶刊资源 让DeepSeek找到与研究题目有关、在全世界还有哪些相关的顶刊 5、模仿顶刊写出论文大纲 让DeepSeek围绕我的研究问题，按照这些期刊的典型论文写作，生成大纲，投喂口令： I am interested in the topic \"how does ...\" Tell me the typical article (including questions, literature review and gap, framework, method, research findings) answering this question in the journals you offered me. 6、补充顶刊文献写出初稿 让DeepSeek推荐我们前面定位的期刊里的近些年的代表作，并补充到大纲里，投喂口令： Your discussion is great. Now I need to read litearture to refine my research. Tell me 10 key literatures the typical article above needs to engage with. Please include the key insights of the 10 articles you offered into the typical article you had generated above. The refined typical article needs a consistent and precise argument by adding these articles. DeepSeek和Zotero结合 安装文献管理软件Zotero，然后在Zotero插件商店下载插件Awesome GPT，得到.xpi文件。 关于安装，参考文献管理工具Zotero安装教程 在zotero的【tool】中选择【plugins】将插件放进来 接入API：用硅基流动调用DeepSeek的API，在API密钥选项里面新建API密钥，然后回到Zotero，进入设置页面，设置API Key，Base API选择siliconflow，Model选择DeepSeek，设置如图所示，点击test测试是否成功。 可以批量选择文件（批量导入文件），然后点击GPT图标，使用DeepSeek功能。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-30 "},"ebook/intro.html":{"url":"ebook/intro.html","title":"Gitbook使用指南","keywords":"","body":" 欢迎来到Gitbook应用教程 GitBook 是基于 Node.js 的命令行工具，通过集成 GitHub/Git 版本控制系统和 Markdown 语法实现电子书创作与管理。该工具支持生成静态网站、PDF、ePub 等文档格式，并可通过插件系统扩展功能。用户需通过 npm 安装 gitbook-cli 工具包，初始化项目时自动生成 README.md（书籍介绍）和 SUMMARY.md（目录结构）核心配置文件。 Gitbook的学习包括两大部分，一部分是Gitbook本身的操作方法，这部分相对简单，只需要掌握工程项目创建、运行、打包、插件安装等几个步骤即可；另一部分是MarkDown语法学习，Gitbook主要用Markdown编辑，然后将Markdown文件编译打包为静态页面（或PDF等）。 Gitbook配置教程 Gitbook环境配置 第一个Gitbook项目 Gitbook插件配置 Gitbook使用技巧 Gitbook操作技巧 MarkDown语法规则 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"ebook/startbook.html":{"url":"ebook/startbook.html","title":"Gitbook环境配置","keywords":"","body":"Gitbook环境配置 Gitbook基于Node.js开发，所以需要先配置Node.js的环境，然后配置Gitbook环境。本文形成时（2024年4月）选择的环境及版本如下： 操作系统：MacOS M1 12.2 Node.js：18.20.2 npm：10.5.0 Gitbook：3.2.3 [!NOTE] Node.js的版本选择不宜过高，可参考Gitbook的官网说明。 配置node.js环境 进入node.js官网，下载安装程序，这里建议选择18.20.2LTS版本，下载好安装程序就可以双击安装。 安装过程不需要有特殊设置和选择，直接选择【确定】下一步即可。 [!NOTE] 根据操作系统不同，选择不同的版本，本文教程用的操作系统是MacOS M1 12.2。 完成安装之后，可查看安装是否成功。 % node -v % which node 第一个命令查看安装版本，如果能够输出版本信息，表示安装成功。 第二个命令可查看安装路径。 配置Gitbook环境 [!NOTE] Gitbook环境需要Nodejs支持，配置过程中，可能出现两个重要错误，都与nodejs版本相关。 在nodejs的配置中，已经默认配置了npm，只需要用npm安装Gitbook即可。 % npm install -g gitbook-cli 这里可能就安装失败，提示错误信息如下 npm ERR! [Error: EACCES: permission denied, mkdir 这个错误提示很简单，就是没有权限，只需要在命令前面加上sudo即可 % sudo npm install -g gitbook-cli 配置完成，即可查看版本信息，如果有正确版本信息，表示安装成功。 % gitbook --version 键入上述命令，将进入Gitbook相关包下载安装时间，只需要等待。但如果选择的nodejs版本过高，可能会出现下面的错误提示。 Installing GitBook 3.2.3 /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (node:fs:205:5) Node.js v20.12.2 根据错误提示信息，找到/usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js文件，将下面三行代码注释掉，再次尝试即可顺利完成。 // fs.stat = statFix(fs.stat) // fs.fstat = statFix(fs.fstat) // fs.lstat = statFix(fs.lstat) [!NOTE] 这个错误提示及解决办法，在后面的配置过程中，可能还会用到。 再次看出版本信息，将可以看到Gitbook版本信息。 % gitbook --version CLI version: 2.3.2 GitBook version: 3.2.3 初始化Gitbook项目 完成上述过程之后，就可以初始化Gitbook项目。在磁盘新建文件夹，然后在该文件目录下初始化一个项目。 % pwd /Documents/ehandlebook/ebook % gitbook init 此时，可能出现如下错误提示。 TypeError [ERR_INVALID_ARG_TYPE]: The \"data\" argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received an instance of Promise 这是版本不兼容导致，下面有两个处理办法，本文采用第二个解决方案。 1、卸载nodejs，更换低版本。 先查看nodejs的安装路径，然后卸载掉已经安装的gitbook，然后将nodejs相关的文件删除。删除完nodejs之后，再次看出其版本信息，是找不到版本信息的。 % which node /usr/local/bin/node % sudo npm uninstall -g gitbook % sudo npm uninstall -g gitbook-cli % sudo rm -rf /usr/local/bin/npm % sudo rm -rf /usr/local/share/man/man1/node.1 % sudo rm -rf /usr/local/lib/dtrace/node.d % sudo rm -rf /usr/local/lib/node_modules/...与node相关 % sudo rm -rf ~/.npm % sudo rm -rf ~/.node-gyp % sudo rm /usr/local/bin/node 完成卸载之后，重新下载低版本nodejs安装，安装过程与之前的一样。完成所有的环境配置之后，再次创建gitbook项目，可能还是会出现这个错误。 2、不卸载重装，进入gitbook安装文件，修改相关代码。 用gitbook的debug命令，找到下面版本文件。在版本文件下，找到\\3.2.3\\lib\\init.js文件，将该文件的其中一行代码替换掉。 % gitbook init --debug /Users/.../.gitbook/versions/3.2.3/ 原代码行和替换的代码行 // return fs.writeFile(filePath, summary.toText(extension)); return summary.toText(extension).then(stx=>{return fs.writeFile(filePath, stx);}); 完成之后，再次初始化项目，将可以正常创建。 % gitbook init warn: no summary file in this book info: create SUMMARY.md info: initialization is finished 测试 本文之初采用Sublime Text编辑器管理gitbook项目，它的弊端是不能实时更新网页内容，很多人推荐使用Typora。 为了方便对gitbook项目的管理，在gitbook项目中创建npm项目。在gitbook项目的文件目录下，创建npm项目。这里有很多选项，直接回车即可，最后选择yes。 % npm init This utility will walk you through creating a package.json file. It only covers the most common items, and tries to guess sensible defaults. See `npm help init` for definitive documentation on these fields and exactly what they do. Use `npm install ` afterwards to install a package and save it as a dependency in the package.json file. Press ^C at any time to quit. package name: (ebook) version: (1.0.0) description: entry point: (index.js) test command: git repository: keywords: author: license: (ISC) About to write to /Documents/ehandlebook/ebook/package.json: { \"name\": \"ebook\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\": \"\", \"license\": \"ISC\" } Is this OK? (yes) 完成npm项目配置之后，项目中会得到一个package.json文件。 启动项目有两种方式，第一种方式是用gitbook的启动命令。还是在该项目目录下，启动项目。 % gitbook serve Live reload server started on port: 35729 Press CTRL+C to quit ... /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 很遗憾，可能启动不成功，提示的错误，与前面出现的错误类型一致，找到/usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js文件，将下面三行代码注释掉，再次尝试即可顺利完成。 // fs.stat = statFix(fs.stat) // fs.fstat = statFix(fs.fstat) // fs.lstat = statFix(fs.lstat) 再次启动，启动之后，会出现一个目录_book，浏览器访问“http://localhost:4000”。 > ebook@1.0.0 serve > gitbook serve Live reload server started on port: 35729 Press CTRL+C to quit ... info: 7 plugins are installed info: loading plugin \"livereload\"... OK info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 1 pages info: found 1 asset files info: >> generation finished with success in 0.1s ! Starting server ... Serving book on http://localhost:4000 第二种启动方式，在package.json中配置启动项。 { \"name\": \"ebook\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"serve\": \"gitbook serve\", \"build\": \"gitbook build\" }, \"author\": \"\", \"license\": \"ISC\" } 启动命令为 % npm run serve 构建项目的命令为 % npm run build gitbook依次读取.gitignore，.bookignore和.ignore文件，将一些文件和目录排除。创建.bookignore文件，在里面可以配置需要忽略的内容。 package.json package-lock.json .bookignore 构建项目 % npm run build > ebook@1.0.0 build > gitbook build info: 9 plugins are installed info: 6 explicitly listed info: loading plugin \"search-pro\"... OK info: loading plugin \"code\"... OK info: loading plugin \"highlight\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 1 pages info: found 0 asset files info: >> generation finished with success in 0.1s ! 编辑工具 本文之初采用Sublime Text编辑器管理gitbook项目，它的弊端是不能实时更新网页内容，很多人推荐使用Typora。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-10 "},"ebook/firstpage.html":{"url":"ebook/firstpage.html","title":"第一个Gitbook项目","keywords":"","body":"第一个Gitbook项目 在完成了Gitbook环境配置之后，就可以创建任何Gitbook项目，现在做一个Gitbook项目的一般化结构框架。 1、选择项目存储位置，在该位置创建一个新的文件夹。 % mkdir foldername 2、在该目录下初始化一个Gitbook项目。 % gitbook init warn: no summary file in this book info: create README.md info: create SUMMARY.md info: initialization is finished 完成后，文件目录下出现README.md、SUMMARY.md两个项目文件。当需要多个文件时，只有在SUMMARY.md中注册的文件才能够编译成HTML文件，才能够被访问。README.md文件是默认的文件，一定会被编译为HTML文件。 3、添加必要的文件。 % touch book.js % touch .bookignore 其中book.js暂时放入下面的内容。 module.exports = { // 书籍信息 title: 'Gitbook应用教程', description: 'Gitbook快速建立个人博客', author: '计算机科学实验室', lang: 'zh-cn', // 插件列表 plugins: [ ], // 插件全局配置 pluginsConfig: { }, // 模板变量 variables: { // 自定义 }, }; 其中 .bookignore暂时放入下面的内容。 package.json package-lock.json .bookignore 4、gitbook项目添加npm项目，方便项目管理。npm init初始化npm项目，一路回车即可，最后输入yes。 % npm init This utility will walk you through creating a package.json file. It only covers the most common items, and tries to guess sensible defaults. See `npm help init` for definitive documentation on these fields and exactly what they do. Use `npm install ` afterwards to install a package and save it as a dependency in the package.json file. Press ^C at any time to quit. package name: (miracldoc) version: (1.0.0) description: entry point: (book.js) test command: git repository: keywords: author: license: (ISC) About to write to /Users/lisl/Documents/ehandlebook/miracldoc/package.json: { \"name\": \"miracldoc\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"book.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\": \"\", \"license\": \"ISC\" } Is this OK? (yes) yes 完成之后，将可以看到一个package.json的文件，文件内容如下。 { \"name\": \"miracldoc\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"book.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\": \"\", \"license\": \"ISC\" } 修改文件中的配置信息，修改之后如下。 { \"name\": \"miracldoc\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"book.js\", \"scripts\": { \"serve\": \"gitbook serve\", \"build\": \"gitbook build\" }, \"author\": \"\", \"license\": \"ISC\" } 其实就是将gitbook的启动命令和构建命令配置到了npm，由npm启动或构建项目。 5、启动或构建项目。 % npm run serve > miracldoc@1.0.0 serve > gitbook serve Live reload server started on port: 35729 Press CTRL+C to quit ... info: 7 plugins are installed info: loading plugin \"livereload\"... OK info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 1 pages info: found 0 asset files info: >> generation finished with success in 0.1s ! Starting server ... Serving book on http://localhost:4000 启动项目之后，就可以在浏览器访问，地址为“http://localhost:4000”。 打包项目的命令与之类似。 % npm run build > miracldoc@1.0.0 build > gitbook build info: 7 plugins are installed info: 6 explicitly listed info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 1 pages info: found 0 asset files info: >> generation finished with success in 0.1s ! 这只是完成一个简单的项目创建，关于项目的初始设置可以阅读操作技巧。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"ebook/plugins.html":{"url":"ebook/plugins.html","title":"Gitbook插件配置","keywords":"","body":"Gitbook的插件配置 npm为Gitbook提供了很多插件，只需要在Gitbook项目配置npm项目，就可以下载相关插件使用。 [!NOTE] 插件应该在项目目录下安装，也就是说在当前项目文件下安装，才会出现在package.json文件中。 搜索插件 插件gitbook-plugin-search-pro支持中文搜索，详情参考官方文档，首先在项目中安装该插件 npm i gitbook-plugin-search-pro 然后在book.js文件中添加配置项 { \"plugins\": [ \"-lunr\", \"-search\", \"search-pro\" ] } 该插件能够搜索到全文匹配字符，搜索能力非常强。 代码插件 插件gitbook-plugin-code用于排版代码，详情参考官方文档，首先在项目中安装该插件 npm i gitbook-plugin-code 然后在book.js文件中添加配置项 \"plugins\" : [ \"code\" ], \"pluginsConfig\": { \"code\": { \"copyButtons\": false } } 主题插件 gitbook-plugin-theme- 隐藏Gitbook默认设置 Gitbook页面有诸如“Published with GitBook”的默认设置，可用插件gitbook-plugin-hide-element使之隐藏。 插件gitbook-plugin-hide-element的官方文档，首先在项目中安装该插件 npm i gitbook-plugin-hide-element 然后在book.js文件中添加配置项 { \"plugins\": [ \"hide-element\" ], \"pluginsConfig\": { \"hide-element\": { \"elements\": [\".gitbook-link\"] } } } 完成上述配置，就可以将“Published with GitBook”的默认设置去掉。 添加提示、警告等提示框 插件gitbook-plugin-flexible-alerts用于添加提示、警告等提示框，参考官方文档，首先在项目中安装该插件 npm i gitbook-plugin-flexible-alerts 然后在book.js文件中添加配置项，以下是其中一种配置方式，更多配置参数，可查看官方文档。 { \"plugins\": [ \"flexible-alerts\" ], \"pluginsConfig\": { \"flexible-alerts\": { \"style\": \"flat\" } } } 例如给出具体的样式配置 \"flexible-alerts\": { // \"style\": \"flat\", \"note\": {\"label\" : \"注意\"}, \"tip\": {\"label\" : \"提示\"}, \"warning\": { \"label\": \"warning\" }, \"danger\": { \"label\": \"危险\" } } 使用方式如下，> [!NOTE]给出“提示”，后面跟着相关文本；其他提示框也类似，例如下面的“TIPs”。 > [!NOTE] > 文本 [!NOTE] An alert of type 'tip' using alert specific style 'flat' which overrides global style 'callout'. In addition, this alert uses an own heading and hides specific icon. > [!TIP] > An alert of type 'tip' using alert specific style 'flat' which overrides global style 'callout'. > In addition, this alert uses an own heading and hides specific icon. [!TIP] An alert of type 'tip' using alert specific style 'flat' which overrides global style 'callout'. In addition, this alert uses an own heading and hides specific icon. 更多高级用法，参考官方文档。 菜单折叠 插件gitbook-plugin-expandable-chapters用于折叠菜单，参考官方文档，首先在项目中安装该插件。 npm i gitbook-plugin-expandable-chapters 然后在book.js文件中添加配置项 { plugins: [\"expandable-chapters\"], \"pluginsConfig\": { \"expandable-chapters\":{} } } 返回顶部 插件gitbook-plugin-back-to-top-button用于设置返回顶部按钮，参考官方文档，首先在项目中安装该插件。 npm i gitbook-plugin-back-to-top-button 然后在book.js文件中添加配置项，以下是其中一种配置方式，更多配置参数，可查看官方文档。 { \"plugins\" : [ \"back-to-top-button\" ] } 设置返回顶部按钮之后，可能受到原来默认的左右导航箭头影响，不能正常显示返回顶部的按钮，需要去掉左右导航箭头，去除左右导航箭头可以配置CSS样式（CSS样式设置参考样式调整）。 /* 隐藏导航箭头 */ .navigation-next, .navigation-prev { display: none !important; } /* 或者更具体的选择器 */ button[data-testid=\"next-chapter-button\"], button[data-testid=\"previous-chapter-button\"] { display: none !important; } 页内导航 插件gitbook-plugin-page-toc用于页内导航，参考官方文档，首先在项目中安装该插件。 npm i gitbook-plugin-page-toc 然后在book.js文件中添加配置项，以下是其中一种配置方式，更多配置参数，可查看官方文档。 { \"plugins\": [ \"page-toc\" ], \"pluginsConfig\": { \"page-toc\": { \"selector\": \".markdown-section h1, .markdown-section h2, .markdown-section h3, .markdown-section h4\", \"position\": \"before-first\", \"showByDefault\": true } } } 默认情况下显示导航目录，如果showToc设置为false，则会隐藏导航目录，但是显示不了打开导航的按钮。可以设置showToc为false，在需要打开导航目录的markdown文档顶部添加以下代码，则该页面出现导航目录。 --- showToc: true --- 如果是某个页面不需要导航目录，则设置showToc为false --- showToc: false --- 页面上可能会有一些元素遮挡导航目录，这时候可以通过下面的方式将导航目录浮动到页面顶层。 /* 重置所有可能的高 z-index 元素 */ .book .book-header, .book .book-summary, .book .book-body .navigation, .markdown-section .code-toolbar { z-index: 100 !important; } /* 模态框和弹出层 */ .modal, .popup, .tooltip { z-index: 1000 !important; } /* 页面目录 - 最高优先级 */ .page-toc { z-index: 2147483647 !important; /* 接近最大整数值 */ position: fixed !important; right: 20px !important; top: 80px !important; /* 创建新的层叠上下文 */ transform: translate3d(0, 0, 0); isolation: isolate; } /* 确保在移动端也能正常显示 */ @media (max-width: 1240px) { .page-toc { z-index: 2147483647 !important; position: fixed !important; top: 60px !important; right: 10px !important; width: 250px !important; } } 这个插件的另一个缺点是，当页面出现导航目录的时候，会导致顶部间距增加，或许可以在website.css中设置相应的样式调整。 页内导航与返回顶部 插件gitbook-plugin-anchor-navigation-ex用于页内导航和返回顶部，参考官方文档，首先在项目中安装该插件。 npm i gitbook-plugin-anchor-navigation-ex 然后在book.js文件中添加配置项 { \"plugins\": [ \"anchor-navigation-ex\" ] } 该插件解决了插件gitbook-plugin-page-toc的问题，合并了插件gitbook-plugin-back-to-top-button和插件gitbook-plugin-page-toc的功能。该插件更详细的配置如下 \"anchor-navigation-ex\":{ \"showLevel\": true, \"associatedWithSummary\": true, \"printLog\": false, \"multipleH1\": true, \"mode\": \"pageTop\", // pageTop or float \"showGoTop\":true, \"float\": {//悬浮在右上角 \"floatIcon\": \"fa fa-navicon\", \"showLevelIcon\": false, \"level1Icon\": \"fa fa-hand-o-right\", \"level2Icon\": \"fa fa-hand-o-right\", \"level3Icon\": \"fa fa-hand-o-right\" }, \"pageTop\": {//页面底部插入 \"showLevelIcon\": false, \"level1Icon\": \"fa fa-hand-o-right\", \"level2Icon\": \"fa fa-hand-o-right\", \"level3Icon\": \"fa fa-hand-o-right\" } } 插件gitbook-plugin-page-toc的返回顶部按钮固定不变，有些呆板，可以设置参数showGoTop为false，然后用插件gitbook-plugin-back-to-top-button设置返回顶部按钮。 TeX 公式 插件gitbook-plugin-katex用于处理 TEX 公式，参考官方文档，首先在项目中安装该插件。 npm i gitbook-plugin-katex 然后在book.js文件中添加配置项，以下是其中一种配置方式，更多配置参数，可查看官方文档。 { \"plugins\": [\"katex\"] } 例如，下面的代码，放在两个 $$ 之间，与latex的语法格式相同，编译之后就是latex公式。 Inline math: {% math %}\\int_{-\\infty}^\\infty g(x) dx{% endmath %} Block math: {% math %} \\int_{-\\infty}^\\infty g(x) dx {% endmath %} Inline math: ∫−∞∞g(x)dx\\int_{-\\infty}^\\infty g(x) dx∫​−∞​∞​​g(x)dx Block math: ∫−∞∞g(x)dx \\int_{-\\infty}^\\infty g(x) dx ∫​−∞​∞​​g(x)dx $$ 在gitbook中有特殊含义，表示数学公式的开始，要打印 $$，可以用转义的方式，如 \\$\\$。 代码高亮 插件npm i gitbook-plugin-prism用于处理代码高亮，参考官方文档，首先在项目中安装该插件。 npm i gitbook-plugin-prism 然后在book.js文件中添加配置项，以下是其中一种配置方式，更多配置参数，可查看官方文档。 { \"plugins\": [\"prism\", \"-highlight\"] } \"pluginsConfig\": { \"prism\": { \"css\": [\"prismjs/themes/prism-solarizedlight.css\"], \"lang\": {\"flow\": \"typescript\"}, \"ignore\": [\"mermaid\",\"eval-js\"] }, } 在使用的时候，需要指定编程语言，例如上面采用的是json。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-22 "},"ebook/gitbk.html":{"url":"ebook/gitbk.html","title":"Gitbook操作技巧","keywords":"","body":"Gitbook操作技巧 项目初始化配置 项目初始化完成之后，会带有很多Gitbook自身的默认配置，比如目录最后默认有一个“Published with GitBook”的超链接，在页面的右上角有很多页面分享图标。 去掉“Published with GitBook”超链接 插件gitbook-plugin-hide-element 的官方文档，首先在项目中安装该插件 npm i gitbook-plugin-hide-element 然后在book.js文件中添加配置项 { \"plugins\": [ \"hide-element\" ], \"pluginsConfig\": { \"hide-element\": { \"elements\": [\".gitbook-link\"] } } } 完成上述配置，就可以将“Published with GitBook”的默认设置去掉。 去掉分享功能 在book.js中添加下面的json代码，不需要放在pluginsConfig中，与pluginsConfig同级。 // 去掉分享功能 \"links\": { \"gitbook\": false, \"sharing\": { \"google\": false, \"facebook\": false, \"twitter\": false, \"all\": false } }, 加入以上代码，即可去掉分享功能。 目录 目录分级 以分割线的方式为目录分级 目录编号 为页面左边的目录编号，在pluginsConfig中添加一个参数即可。注意，Gitbook的目录最多只有三层。 pluginsConfig: { // 目录编号 \"theme-default\": { \"showLevel\": true }, }, 项目结构 SUMMAY.md README.md package.json © phdlisl all right reserved，powered by GitbookUpdate in 2024-04-19 "},"ebook/mkdown.html":{"url":"ebook/mkdown.html","title":"MarkDown语法规则","keywords":"","body":"MarkDown 语法 GitBook 默认使用MarkDown语法。MarkDown是一种轻量级标记语言，语法简洁，让作者更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与 HTML 混编，可导出 HTML、PDF 以及.md格式的文件。Github、Wikipedia 等网站都有使用MarkDown文本。 标题和段落 标题 markdown支持6级标题，每一级标题根据#号个数确定，以#号开头。 级别 markdown形式 html形式 一级标题 # 标题 标题 二级标题 ## 标题 标题 三级标题 ### 标题 标题 四级标题 #### 标题 标题 五级标题 ##### 标题 标题 六级标题 ###### 标题 标题 标题 标题 标题 标题 标题 标题 --> 段落 markdown以空行作为段落的分段标志。 第一段 第二段 强调 强调文本包括文本加粗、斜体等。 粗体 单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）可实现文本加粗，例如“加粗”就是由“**加粗**”实现，“加粗”就是由“__加粗__”实现。这些都是MarkDown的语法，在HTML中，可以用标签“”实现。 类别 代码 效果 MarkDown语法 **加粗** 或 __加粗__ 加粗 或 加粗 HTML语法 加粗 加粗 MarkDown和HTML两种语法，GitBook都能认识。 斜体 用星号*或下划线_可以设计斜体。 类别 代码 效果 MarkDown语法 *斜体* 或 _斜体_ 斜体 或 斜体 HTML语法 斜体或 斜体 斜体 或 斜体 斜体+粗体 类别 代码 效果 MarkDown语法 ***斜体+粗体*** 或 ___斜体___ 斜体+粗体 或 斜体 HTML语法 斜体或 斜体 斜体 或 斜体 删除线 类别 代码 效果 MarkDown语法 ~~删除线~~ 删除线 HTML语法 斜体 删除线 表格 MarkDown 的表格设置语法比较简单，例如下面的表格及其代码。 第一列 第二列 第三列 第四列 第二行 第二行 第二行 第二行 第三行 第三行 第三行 第三行 第四行 第四行 第四行 第四行 | 第一列 | 第二列 | 第三列 | 第四列 | | ---- | ---- | ---- | ---- | | 第二行 | 第二行 | 第二行 | 第二行 | | 第三行 | 第三行 | 第三行 | 第三行 | | 第四行 | 第四行 | 第四行 | 第四行 | |、-、:之间的多余空格会被忽略，不影响布局。 默认标题栏居中对齐，内容居左对齐。 -:表示内容和标题栏居右对齐，:-表示内容和标题栏居左对齐，:-:表示内容和标题栏居中对齐。 内容和|之间的多余空格会被忽略，每行第一个|和最后一个|可以省略，-的数量至少一个。 第一列 第二列 第三列 第四列 第二行第一列 第二行第二列 第二行第三列 第二行第四列 第三行 第三行 第三行 第三行 第四行 第四行 第四行 第四行 | 第一列 | 第二列 | 第三列 | 第四列 | | ---: | :--- | ---- | ---- | | 第二行第一列 | 第二行第二列 | 第二行第三列 | 第二行第四列 | | 第三行 | 第三行 | 第三行 | 第三行 | | 第四行 | 第四行 | 第四行 | 第四行 | 列表 Gitbook可以建立两种列表，分别是有序列表和无序列表。 有序列表 有序列表以数字 1. 起始，每个列表项以数字加英文句点开始，数字不必按顺序排列。 类别 代码 效果 MarkDown语法 1. 第一项 3. 第二项 5. 第三项 1. 第一项 3. 第二项 5. 第三项 HTML语法 第一项第二项第三项 第一项第二项第三项 [!NOTE] 在表格中，如果需要用到列表，每一项的后面需要添加换行符使之能够换行，形成列表项。在正常文本中，是不需要换行符的，只需要正常空行就行。 无序列表 无序列表以破折号 (-)、星号 (*) 或加号 (+)开头，一个或多个缩进，可形成嵌套列表。 类别 代码 效果 MarkDown语法 - 第一项 - 第二项 - 第三项 - 第一项 - 第二项 - 第三项 HTML语法 第一项第二项第三项 第一项第二项第三项 [!NOTE] 在表格中，如果需要用到列表，每一项的后面需要添加换行符使之能够换行，形成列表项。在正常文本中，是不需要换行符的，只需要正常空行就行。 公式 \\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N Γ(n)=(n−1)!∀n∈N\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb NΓ(n)=(n−1)!∀n∈N © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-10 "},"ebook/style.html":{"url":"ebook/style.html","title":"个性化样式配置","keywords":"","body":"样式调整 可以在 GitBook 项目根目录创建styles文件夹，然后在其中创建website.css文件，调整默认的页面样式。 例如在website.css文件中添加如下代码，调整页面内容的展示宽度。 /* 调整主内容区域宽度 */ .book .book-body .page-wrapper .page-inner { max-width: 95% !important; } /* 调整正文内容宽度 */ .markdown-section { /* max-width: 1200px !important; */ max-width: 100% !important; margin: 0 auto; padding: 0 40px; } /* 调整代码块的宽度 */ .markdown-section pre { max-width: 100% !important; } /* 调整表格宽度 */ .markdown-section table { width: 100% !important; } /* 如果需要调整侧边栏宽度 */ .book .book-summary { width: 300px !important; } .book.with-summary .book-body { left: 300px !important; } /* 移动端适配 */ @media (max-width: 768px) { .book .book-summary { /* width: 280px !important; */ width: 100% !important; transform: translateX(-100%); } .book.with-summary .book-summary { transform: translateX(0); } .book.with-summary .book-body { /* transform: translateX(280px); */ transform: translateX(100%); left: 0 !important; } .markdown-section { max-width: 100% !important; padding: 0 20px; } } 同时需要在book.js文件中添加CSS 配置（如果没有这个配置，似乎也不会影响效果，应该是作为默认项加载） { \"styles\": { \"website\": \"styles/website.css\" } } © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-09 "},"clang/intro.html":{"url":"clang/intro.html","title":"C语言","keywords":"","body":"C语言 C语言在全球编程语言中有着重要地位，市场份额稳居前几，编程语言的市场变化参考TIOBE报告。 C语言的语法规则简单，编译执行效率很高，是多数底层设备的首选编程语言。 这部分是C语言编程的操作指南，持续完善中。 标准库函数 内存分配 qsort函数 硬件 AES密钥扩展 属性 指令集 SSE2函数 SSE函数 实用案例 时间统计方法 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-12 "},"clang/standardLib/memory.html":{"url":"clang/standardLib/memory.html","title":"内存分配","keywords":"","body":"内存分配 内存分配相关的函数 malloc malloc 是 C 语言标准库中的动态内存分配函数，用于在堆（heap）区分配指定大小的内存块。 #include void* malloc(size_t size); 参数说明 size: 要分配的字节数 返回值 成功：返回指向分配内存起始地址的指针（类型为 void*） 失败：返回 NULL #include #include int main() { // 分配内存 int* arr = (int*)malloc(10 * sizeof(int)); if (arr == NULL) { printf(\"内存分配失败\\n\"); return 1; } // 使用内存 for (int i = 0; i free free()释放内存，calloc()分配并清零内存，realloc()调整已分配内存的大小。 [!NOTE] free()只能释放一个连续内存空间。 _mm_malloc _mm_malloc 是 Intel 提供的内存分配函数，主要用于分配对齐的内存块，特别适用于需要 SSE/AVX 等 SIMD 指令集优化的场景。 void* _mm_malloc(size_t size, size_t align); 参数说明 size: 要分配的字节数 align: 对齐边界，必须是 2 的幂次方，且至少为 sizeof(void*) #include #include // 需要包含这个头文件 int main() { // 分配 64 字节内存，按 16 字节对齐（SSE 要求） float* aligned_data = (float*)_mm_malloc(64, 16); if (aligned_data != NULL) { // 使用对齐的内存进行 SIMD 操作 __m128 vec = _mm_load_ps(aligned_data); // 安全加载，不会段错误 // ... 处理数据 printf(\"create memory\\n\"); _mm_free(aligned_data); // 必须使用配套的释放函数 } return 0; } 16字节对齐，适用于SSE指令集；32字节对齐，适用于AVX指令集；64字节对齐，适用于AVX-512指令集。对齐值必须是 2 的幂次方。 // 标准 malloc - 对齐不确定 void* data1 = malloc(64); // 对齐可能不是16字节 // _mm_malloc - 保证对齐 void* data2 = _mm_malloc(64, 16); // 保证16字节对齐 必须使用 _mm_free 释放，不能使用 free()。需要包含 或 头文件 _mm_free void _mm_free(void* ptr); malloc与 _mm_malloc 的区别 特性 malloc _mm_malloc 标准性 C 标准函数 编译器扩展 对齐 实现定义 指定对齐 释放 使用 free() 使用 _mm_free() 用途 通用内存分配 SIMD/特定对齐需求 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-12 "},"clang/standardLib/qsort.html":{"url":"clang/standardLib/qsort.html","title":"qsort函数","keywords":"","body":"排序函数qsort qsort是C标准库中提供的快速排序函数，用于对任意类型的数组进行排序。 #include void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void *)); 参数说明： base：指向要排序的数组的第一个元素的指针（数组首地址） nitems：数组中元素的个数 size：每个元素的大小（以字节为单位） compar：比较函数指针，用于定义排序规则 以下案例是一个简单的整数排序，定义排序规则compare_int，然后通过qsort函数完成排序。 #include #include // 比较函数 - 升序排序 int compare_int(const void *a, const void *b) { const int *num1 = (const int *)a; const int *num2 = (const int *)b; if (*num1 *num2) return 1; return 0; // 更简洁的写法： // return (*(int*)a - *(int*)b); } // 降序排序的比较函数 int compare_int_desc(const void *a, const void *b) { return (*(int*)b - *(int*)a); } int main() { int arr[] = {64, 34, 25, 12, 22, 11, 90}; int n = sizeof(arr) / sizeof(arr[0]); printf(\"Original array: \"); for (int i = 0; i © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-12 "},"clang/hardware/aesNI.html":{"url":"clang/hardware/aesNI.html","title":"AES密钥扩展","keywords":"","body":"AES密钥扩展 Intel AES-NI 指令集为 AES 密钥扩展提供了几个重要的 intrinsic 函数 // 核心密钥扩展函数 __m128i _mm_aeskeygenassist_si128(__m128i key, int round_constant); // 加密相关指令 __m128i _mm_aesenc_si128(__m128i state, __m128i round_key); __m128i _mm_aesenclast_si128(__m128i state, __m128i round_key); __m128i _mm_aesdec_si128(__m128i state, __m128i round_key); // 解密相关指令 __m128i _mm_aesdec_si128(__m128i state, __m128i round_key); __m128i _mm_aesdeclast_si128(__m128i state, __m128i round_key); // 逆向密钥扩展 __m128i _mm_aesimc_si128(__m128i round_key); 核心密钥扩展函数 _mm_aeskeygenassist_si128 __m128i _mm_aeskeygenassist_si128(__m128i key, int round_constant); 加密相关指令 _mm_aesenc_si128 __m128i _mm_aesenc_si128(__m128i state, __m128i round_key); _mm_aesenclast_si128 __m128i _mm_aesenclast_si128(__m128i state, __m128i round_key); _mm_aesdec_si128 __m128i _mm_aesdec_si128(__m128i state, __m128i round_key); 解密相关指令 _mm_aesdec_si128 __m128i _mm_aesdec_si128(__m128i state, __m128i round_key); _mm_aesdeclast_si128 __m128i _mm_aesdeclast_si128(__m128i state, __m128i round_key); 逆向密钥扩展 _mm_aesimc_si128 __m128i _mm_aesimc_si128(__m128i round_key); 密钥扩展示例 #include #include void aes128_key_expansion(const unsigned char* user_key, unsigned char* key_schedule) { __m128i key = _mm_loadu_si128((const __m128i*)user_key); __m128i temp; int i; // 存储初始密钥 _mm_storeu_si128((__m128i*)key_schedule, key); // 生成10轮密钥（AES-128） for (i = 0; i © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-17 "},"clang/hardware/attribute.html":{"url":"clang/hardware/attribute.html","title":"属性","keywords":"","body":"__attribute__ __attribute__ 是GCC编译器的一个扩展语法，用于为函数、变量、类型等添加特定的属性或修饰符，以控制编译器的行为。 函数原型 // 基本语法 __attribute__((attribute_name)) __attribute__((attribute_name(parameters))) // 多个属性 __attribute__((attribute1, attribute2, ...)) 用于为函数、变量、类型等添加特定的属性或修饰符，下面是相关案例。 函数属性 (Function Attributes) // 指定函数不会返回 void fatal_error(const char* msg) __attribute__((noreturn)); void fatal_error(const char* msg) { fprintf(stderr, \"Error: %s\\n\", msg); exit(1); // 函数不会返回，不需要return语句 } // 标记函数已过时 void old_function() __attribute__((deprecated)); void new_function() __attribute__((deprecated(\"Use new_function_v2 instead\"))); void old_function() { // 旧实现 } // 在main函数之前/之后自动执行 void __attribute__((constructor)) init_function() { printf(\"在main之前执行\\n\"); } void __attribute__((destructor)) cleanup_function() { printf(\"在main之后执行\\n\"); } // 强制内联函数 static inline __attribute__((always_inline)) int max(int a, int b) { return a > b ? a : b; } // 禁止内联函数 void __attribute__((noinline)) debug_function() { // 调试函数，不希望被内联 } 变量属性 (Variable Attributes) // 指定变量对齐方式 int array[4] __attribute__((aligned(16))); // 16字节对齐 double data __attribute__((aligned(32))); // 32字节对齐 // SSE编程中的典型用法 float sse_data[4] __attribute__((aligned(16))); // 紧凑排列结构体，去除填充字节 struct __attribute__((packed)) Packet { char type; int size; short checksum; }; // 大小为 1 + 4 + 2 = 7 字节 // 对比：普通结构体可能有填充字节 struct NormalPacket { char type; // 1字节 + 3字节填充 int size; // 4字节 short checksum; // 2字节 + 2字节填充 }; // 大小为 12 字节 // 标记变量可能未使用，避免编译器警告 int __attribute__((unused)) debug_variable; void function() { int __attribute__((unused)) temp_var = 42; // 变量可能在某些条件下不使用 } // 指定变量在特定段中 int __attribute__((section(\".mysection\"))) my_var; // 常用于嵌入式系统 const char __attribute__((section(\".rodata\"))) config[] = \"config_data\"; 类型属性 (Type Attributes) // 定义对齐的类型 typedef int __attribute__((aligned(16))) int_aligned16_t; struct __attribute__((aligned(32))) AlignedStruct { int a; float b; }; // 整个结构体32字节对齐 // 定义紧凑类型 typedef struct __attribute__((packed)) { char a; int b; } PackedStruct; SSE编程中的内存对齐 #include // 对齐的数组用于SSE操作 float input[4] __attribute__((aligned(16))) = {1.0f, 2.0f, 3.0f, 4.0f}; float output[4] __attribute__((aligned(16))); void sse_example() { __m128 vec = _mm_load_ps(input); // 需要对齐加载 __m128 result = _mm_mul_ps(vec, vec); _mm_store_ps(output, result); } © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-12 "},"clang/hardware/instruct.html":{"url":"clang/hardware/instruct.html","title":"指令集","keywords":"","body":"指令集 指令集描述某个类型的CPU所完成的所有功能，不同CPU的指令集不同。 指令集 类型 主要应用领域 主导公司/组织 x86 / x86-64 CISC 个人电脑、服务器、笔记本电脑 Intel, AMD ARM RISC 智能手机、平板、嵌入式、物联网、Mac ARM Holdings（授权） RISC-V RISC 嵌入式、IoT、新兴计算领域（开源） RISC-V International MIPS RISC 网络设备、嵌入式历史领域 MIPS Technologies PowerPC RISC 早期Mac、游戏机、高性能计算 IBM, Freescale CISC表示复杂指令集，RISC表示精简指令集。 台湾积体电路制造股份有限公司（简称“台积电”）是全球最大的专业集成电路制造服务企业，主要产品应用于手机芯片、智能卡等领域。 高通（Qualcomm）是一家主要从事电子科技行业的上市公司，经营范围包括发明移动基础科技，研发无线芯片平台和其它产品解决方案等。骁龙（Snapdragon）是美国高通公司推出的移动处理器系列，自2007年发布以来已成为全球领先的智能计算平台。 联发科技股份有限公司（英文名：MediaTek Inc.MTK）简称联发科，是一家以从事半导体及相关设备为主的企业。 SIMD指令集 SIMD 的全称是 Single Instruction, Multiple Data。单指令表示CPU只执行一条指令，多数据表示这条指令可以同时处理多个数据元素。它是一种并行处理技术，不是多核CPU，而是一个CPU核心内部的数据级并行。 在多媒体、科学计算、机器学习等众多领域，程序经常需要对大量数据（如数组、向量、像素）执行完全相同的操作。如果没有SIMD，CPU需要循环执行一条条指令，效率低下。有了SIMD，就可以大幅压缩处理时间。 SSE指令集 SSE 的全称是 Streaming SIMD Extensions。 它是 Intel 公司提出的一套SIMD指令集实现，首次出现在1999年的Pentium III处理器中。 它是x86架构对SIMD能力的一次重大扩展，后来被AMD等其他厂商采纳。 SSE引入了一套新的128位寄存器，称为 XMM0 ~ XMM7（后续版本增多） SSE本身也是一个系列，包括： SSE：主要支持单精度浮点数。 SSE2：加入了双精度浮点数和整型支持，成为最基础和重要的一代。 SSE3、SSSE3、SSE4.1/4.2：不断增加新的专用指令，如点积、字符串处理、popcnt（位计数）等，进一步增强功能。 SIMD 是一个广义的概念和思想，一种并行计算模型。SSE 是x86架构上实现SIMD思想的一个具体指令集。 一个简单的代码示例 假设我们要将两个浮点数数组 a 和 b 的每一个元素相加，结果存入数组 c。 传统标量方式（C代码）： for (int i = 0; i 使用SSE的SIMD方式（伪代码概念）： #include // SSE头文件 // 假设数组是16字节对齐的 for (int i = 0; i 完善上述案例，完整代码如下 #include #include #include #include // SSE头文件 #include // 函数声明 void normal_vector_add(float* a, float* b, float* c, int n); void sse_vector_add(float* a, float* b, float* c, int n); int verify_results(float* c1, float* c2, int n); int main() { const int ARRAY_SIZE = 1024; // 分配对齐的内存（16字节对齐，这对SSE很重要） float* a = (float*)_mm_malloc(ARRAY_SIZE * sizeof(float), 16); float* b = (float*)_mm_malloc(ARRAY_SIZE * sizeof(float), 16); float* c_normal = (float*)_mm_malloc(ARRAY_SIZE * sizeof(float), 16); float* c_sse = (float*)_mm_malloc(ARRAY_SIZE * sizeof(float), 16); if (a == NULL || b == NULL || c_normal == NULL || c_sse == NULL) { printf(\"内存分配失败！\\n\"); return -1; } // 初始化数组 printf(\"初始化数组...\\n\"); for (int i = 0; i 1e-6f) { printf(\"在索引 %d 处发现差异: %.6f vs %.6f\\n\", i, c1[i], c2[i]); return 0; } } return 1; } © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-12 "},"clang/hardware/sse2fun.html":{"url":"clang/hardware/sse2fun.html","title":"SSE2函数","keywords":"","body":"SSE2指令集 SSE2指令集常用函数 // 数据加载 // 对齐加载 __m128i _mm_load_si128(const __m128i *mem_addr); // 从对齐地址加载 __m128d _mm_load_pd(const double *mem_addr); // 加载双精度浮点数 // 非对齐加载 __m128i _mm_loadu_si128(const __m128i *mem_addr); // 从任意地址加载 __m128d _mm_loadu_pd(const double *mem_addr); // 非对齐加载双精度 // 数据存储 // 对齐存储 void _mm_store_si128(__m128i *mem_addr, __m128i a); // 存储到对齐地址 void _mm_store_pd(double *mem_addr, __m128d a); // 存储双精度 // 非对齐存储 void _mm_storeu_si128(__m128i *mem_addr, __m128i a); // 存储到任意地址 void _mm_storeu_pd(double *mem_addr, __m128d a); // 非对齐存储双精度 // 算术运算 // 加法 __m128i _mm_add_epi8(__m128i a, __m128i b); // 8位整数加法 __m128i _mm_add_epi16(__m128i a, __m128i b); // 16位整数加法 __m128i _mm_add_epi32(__m128i a, __m128i b); // 32位整数加法 __m128i _mm_add_epi64(__m128i a, __m128i b); // 64位整数加法 // 减法 __m128i _mm_sub_epi8(__m128i a, __m128i b); // 8位整数减法 __m128i _mm_sub_epi16(__m128i a, __m128i b); // 16位整数减法 __m128i _mm_sub_epi32(__m128i a, __m128i b); // 32位整数减法 __m128i _mm_sub_epi64(__m128i a, __m128i b); // 64位整数减法 // 浮点数 __m128d _mm_add_pd(__m128d a, __m128d b); // 双精度加法 __m128d _mm_sub_pd(__m128d a, __m128d b); // 双精度减法 __m128d _mm_mul_pd(__m128d a, __m128d b); // 双精度乘法 __m128d _mm_div_pd(__m128d a, __m128d b); // 双精度除法 // 逻辑运算 __m128i _mm_and_si128(__m128i a, __m128i b); // 位与 __m128i _mm_or_si128(__m128i a, __m128i b); // 位或 __m128i _mm_xor_si128(__m128i a, __m128i b); // 位异或 __m128i _mm_andnot_si128(__m128i a, __m128i b); // 位与非 // 比较运算 // 整数 __m128i _mm_cmpeq_epi8(__m128i a, __m128i b); // 8位相等比较 __m128i _mm_cmpeq_epi16(__m128i a, __m128i b); // 16位相等比较 __m128i _mm_cmpeq_epi32(__m128i a, __m128i b); // 32位相等比较 __m128i _mm_cmpgt_epi8(__m128i a, __m128i b); // 8位大于比较 __m128i _mm_cmpgt_epi16(__m128i a, __m128i b); // 16位大于比较 __m128i _mm_cmpgt_epi32(__m128i a, __m128i b); // 32位大于比较 // 浮点数 __m128d _mm_cmpeq_pd(__m128d a, __m128d b); // 双精度相等比较 __m128d _mm_cmpgt_pd(__m128d a, __m128d b); // 双精度大于比较 __m128d _mm_cmplt_pd(__m128d a, __m128d b); // 双精度小于比较 // 移位运算 // 逻辑位移 __m128i _mm_slli_epi16(__m128i a, int imm8); // 16位左移 __m128i _mm_slli_epi32(__m128i a, int imm8); // 32位左移 __m128i _mm_slli_epi64(__m128i a, int imm8); // 64位左移 __m128i _mm_srli_epi16(__m128i a, int imm8); // 16位右移 __m128i _mm_srli_epi32(__m128i a, int imm8); // 32位右移 __m128i _mm_srli_epi64(__m128i a, int imm8); // 64位右移 __m128i _mm_slli_si128(__m128i a, int imm8); // 对 128 位数据进行字节级别的逻辑左移 // 算术位移 __m128i _mm_srai_epi16(__m128i a, int imm8); // 16位算术右移 __m128i _mm_srai_epi32(__m128i a, int imm8); // 32位算术右移 // 数据重排 // 洗牌 __m128i _mm_shuffle_epi32(__m128i a, int imm8); // 32位元素重排 __m128d _mm_shuffle_pd(__m128d a, __m128d b, int imm8); // 双精度重排 // 解包 __m128i _mm_unpackhi_epi8(__m128i a, __m128i b); // 高位解包8位 __m128i _mm_unpacklo_epi8(__m128i a, __m128i b); // 低位解包8位 __m128i _mm_unpackhi_epi16(__m128i a, __m128i b); // 高位解包16位 __m128i _mm_unpacklo_epi16(__m128i a, __m128i b); // 低位解包16位 // 设置常量 __m128i _mm_setzero_si128(void); // 设置全零 __m128i _mm_set1_epi8(char a); // 设置所有8位元素 __m128i _mm_set1_epi16(short a); // 设置所有16位元素 __m128i _mm_set1_epi32(int a); // 设置所有32位元素 __m128i _mm_set_epi8(char e15, ..., char e0); // 设置16个8位元素 __m128i _mm_set_epi32(int e3, int e2, int e1, int e0); // 设置4个32位元素 简单案例 #include // SSE2 指令集头文件 void example() { // 1. 初始化源数据数组 int data[4] = {1, 2, 3, 4}; // 2. 从内存加载数据到 SSE 寄存器 // _mm_loadu_si128 从非对齐内存地址加载 128 位数据 __m128i vec = _mm_loadu_si128((__m128i*)data); // 3. 执行 SSE 操作 // _mm_set1_epi32(10) 创建包含4个10的128位向量：{10, 10, 10, 10} // _mm_add_epi32 执行4个32位整数的并行加法 vec = _mm_add_epi32(vec, _mm_set1_epi32(10)); // 4. 将结果存储回内存 int result[4]; _mm_storeu_si128((__m128i*)result, vec); // 5. 结果：result 现在包含 {11, 12, 13, 14} } 完整案例 #include #include #include // 用于内存对齐 #include // 打印 __m128i 变量的内容（32位整数） void print_m128i_epi32(__m128i value, const char* name) { alignas(16) int result[4]; _mm_store_si128((__m128i*)result, value); printf(\"%s: {%d, %d, %d, %d}\\n\", name, result[0], result[1], result[2], result[3]); } // 基本示例：向量加法 void basic_example() { printf(\"=== 基本示例：向量加法 ===\\n\"); // 源数据 int data[4] = {1, 2, 3, 4}; printf(\"原始数据: {%d, %d, %d, %d}\\n\", data[0], data[1], data[2], data[3]); // 加载到 SSE 寄存器 __m128i vec = _mm_loadu_si128((__m128i*)data); print_m128i_epi32(vec, \"加载后的向量\"); // 创建常量向量 {10, 10, 10, 10} __m128i constant = _mm_set1_epi32(10); print_m128i_epi32(constant, \"常量向量\"); // 执行向量加法 __m128i result_vec = _mm_add_epi32(vec, constant); print_m128i_epi32(result_vec, \"加法结果\"); // 存储回内存 int result[4]; _mm_storeu_si128((__m128i*)result, result_vec); printf(\"最终结果: {%d, %d, %d, %d}\\n\", result[0], result[1], result[2], result[3]); } // 进阶示例：多种 SSE2 操作 void advanced_example() { printf(\"\\n=== 进阶示例：多种 SSE2 操作 ===\\n\"); int a[4] = {10, 20, 30, 40}; int b[4] = {5, 6, 7, 8}; __m128i vec_a = _mm_loadu_si128((__m128i*)a); __m128i vec_b = _mm_loadu_si128((__m128i*)b); printf(\"向量 A: {%d, %d, %d, %d}\\n\", a[0], a[1], a[2], a[3]); printf(\"向量 B: {%d, %d, %d, %d}\\n\", b[0], b[1], b[2], b[3]); // 加法 __m128i add_result = _mm_add_epi32(vec_a, vec_b); print_m128i_epi32(add_result, \"A + B\"); // 减法 __m128i sub_result = _mm_sub_epi32(vec_a, vec_b); print_m128i_epi32(sub_result, \"A - B\"); // 乘法（注意：没有直接的32位整数乘法，这里使用16位演示） __m128i mul_result = _mm_mullo_epi16( _mm_set_epi16(10, 20, 30, 40, 50, 60, 70, 80), _mm_set_epi16(2, 3, 4, 5, 6, 7, 8, 9) ); // 位运算 __m128i and_result = _mm_and_si128(vec_a, vec_b); print_m128i_epi32(and_result, \"A & B (位与)\"); __m128i or_result = _mm_or_si128(vec_a, vec_b); print_m128i_epi32(or_result, \"A | B (位或)\"); } // 性能对比示例：标量 vs 向量运算 void performance_example() { printf(\"\\n=== 性能对比示例（修正版） ===\\n\"); const int SIZE = 10000; // 减小数据量用于演示 const int VECTOR_SIZE = SIZE + 3; // 确保是4的倍数 // 使用动态内存分配并手动对齐 int* array1 = (int*)aligned_alloc(16, VECTOR_SIZE * sizeof(int)); int* array2 = (int*)aligned_alloc(16, VECTOR_SIZE * sizeof(int)); int* result_scalar = (int*)aligned_alloc(16, VECTOR_SIZE * sizeof(int)); int* result_vector = (int*)aligned_alloc(16, VECTOR_SIZE * sizeof(int)); if (!array1 || !array2 || !result_scalar || !result_vector) { printf(\"内存分配失败！\\n\"); free(array1); free(array2); free(result_scalar); free(result_vector); return; } // 初始化数据 for (int i = 0; i © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-12 "},"clang/hardware/ssefun.html":{"url":"clang/hardware/ssefun.html","title":"SSE函数","keywords":"","body":"SSE函数 SSE（Streaming SIMD Extensions）函数，是Intel推出的一套SIMD指令集扩展。 SSE是Intel在1999年推出的SIMD（单指令多数据）指令集，允许在单个指令中同时处理多个数据元素，显著提升多媒体和科学计算应用的性能。 基本数据类型 #include // SSE #include // SSE2 // 主要数据类型： __m128 // 4个单精度浮点数 __m128d // 2个双精度浮点数 __m128i // 整数（16×8位, 8×16位, 4×32位, 2×64位） 常用SSE函数分类 数据加载和存储 算术运算 比较运算 逻辑运算 位移运算 // 加载操作 __m128 _mm_load_ps(float* p); // 对齐加载 __m128 _mm_loadu_ps(float* p); // 未对齐加载 __m128 _mm_set_ps(float z, float y, float x, float w); // 设置值 // 存储操作 void _mm_store_ps(float* p, __m128 a); // 对齐存储 void _mm_storeu_ps(float* p, __m128 a); // 未对齐存储 // 算术运算 __m128 _mm_add_ps(__m128 a, __m128 b); // a + b __m128 _mm_add_ss(__m128 a, __m128 b); // 仅低32位相加 __m128 _mm_sub_ps(__m128 a, __m128 b); // a - b __m128 _mm_mul_ps(__m128 a, __m128 b); // a * b __m128 _mm_div_ps(__m128 a, __m128 b); // a / b __m128 _mm_sqrt_ps(__m128 a); // sqrt(a) // 比较运算 __m128 _mm_cmpeq_ps(__m128 a, __m128 b); // a == b __m128 _mm_cmpgt_ps(__m128 a, __m128 b); // a > b __m128 _mm_cmplt_ps(__m128 a, __m128 b); // a = b __m128 _mm_cmple_ps(__m128 a, __m128 b); // a 数据加载和存储 _mm_load_ps _mm_load_ps 用于从内存中加载4个单精度浮点数到SSE寄存器中，要求内存地址必须16字节对齐。 __m128 _mm_load_ps(float const* mem_addr); #include #include int main() { // 16字节对齐的数组（C11对齐语法） float aligned_array[4] __attribute__((aligned(16))) = {1.0f, 2.0f, 3.0f, 4.0f}; // 使用_mm_load_ps加载数据 __m128 vec = _mm_load_ps(aligned_array); // 将结果存回另一个对齐数组 float result[4] __attribute__((aligned(16))); _mm_store_ps(result, vec); printf(\"Loaded values: %.1f, %.1f, %.1f, %.1f\\n\", result[0], result[1], result[2], result[3]); return 0; } _mm_loadu_ps _mm_set_ps _mm_store_ps _mm_storeu_ps 算术运算 _mm_add_ps _mm_add_ss _mm_sub_ps _mm_mul_ps _mm_div_ps _mm_sqrt_ps 比较运算 _mm_cmpeq_ps _mm_cmpgt_ps _mm_cmplt_ps _mm_cmpge_ps _mm_cmple_ps 逻辑运算 _mm_and_ps _mm_or_ps _mm_xor_ps _mm_andnot_ps 位移 _mm_shuffle_ps _mm_slli_epi32 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-12 "},"clang/tools/times.html":{"url":"clang/tools/times.html","title":"时间统计方法","keywords":"","body":"时间统计 统计程序执行时间，主要用于分析程序性能。主要分为两大类统计方案，一种是一般精度时间统计，一种是高精度时间统计。 一般精度时间统计 todo 高精度时间统计 对于高精度时间统计方案，主要介绍__rdtsc和__rdtscp等方案。 高精度时间统计 __rdtsc 极高精度时间统计 __rdtscp 是一个编译器内置函数，用于读取处理器的时间戳计数器，并确保序列化执行，同时读取处理器的核心ID。 unsigned __int64 __rdtscp(unsigned int * _A); 参数_A：一个指向无符号整数的指针。函数执行后，会将当前处理器ID/核心ID 写入到这个内存地址。 返回值：一个64位无符号整数，代表当前时间戳计数器的值。 [!NOTE] 下来给出了四种方法实现时间统计，每种方法分别针对Linux系统和Windows系统设计，但只测试了Linux系统上的可行性，没有测试Windows系统上是否可行。 在Linux/GCC环境下的使用示例： #include #include // 包含 __rdtscp 等 intrinsic 函数的头文件 int main() { unsigned int aux; // 用于存储处理器ID的变量 unsigned long long tsc1, tsc2; // 第一次读取 tsc1 = __rdtscp(&aux); printf(\"First read: TSC = %llu, Processor ID = %u\\n\", tsc1, aux); // 执行一些操作，例如一个简单的循环 for (volatile int i = 0; i 在Windows/MSVC下的示例： #include #include // MSVC 的头文件 #pragma intrinsic(__rdtscp) // 告诉编译器使用内置函数 int main() { unsigned int aux; unsigned __int64 tsc1, tsc2; tsc1 = __rdtscp(&aux); // ... 做一些操作 tsc2 = __rdtscp(&aux); printf(\"Elapsed cycles: %llu\\n\", tsc2 - tsc1); return 0; } __rdtscp 指令本身有执行开销（几十到上百个时钟周期），在测量非常短的代码段时，这个开销本身会占据很大比例，影响结果的准确性。 虽然序列化保证了准确性，但它也阻止了CPU的并行优化，可能会使得测量的代码性能与正常运行时的性能略有不同。 对于大多数不需要检测核心迁移的场景，使用它的轻量级版本 __rdtsc 就足够了。但在需要最高可靠性的基准测试中，__rdtscp 是更专业和可靠的选择。 时钟周期数转时间 将时钟周期转换为时间需要知道处理器的实际运行频率。 方法1、使用固定频率（推荐用于现代CPU） 现代CPU大多支持 \"Invariant TSC\"（恒定时间戳计数器），这意味着TSC以固定频率递增，不受CPU频率调节的影响。 #include #include // 假设CPU基准频率为2.5GHz（请根据你的CPU实际情况调整） #define CPU_GHZ 2.5 #define NS_PER_SEC 1000000000ULL int main() { unsigned int aux; unsigned long long tsc1, tsc2, cycles; double time_ns, time_us, time_ms; tsc1 = __rdtscp(&aux); // 执行要测量的代码 for (volatile int i = 0; i 方法2：运行时获取CPU频率（更准确） 在linux系统上，通过读取文件/proc/cpuinfo，获得准确的CPU频率，然后计算对应的时间。 #include #include #include double get_cpu_ghz() { FILE *fp = fopen(\"/proc/cpuinfo\", \"r\"); if (!fp) return 0.0; char line[256]; double freq_ghz = 0.0; while (fgets(line, sizeof(line), fp)) { if (sscanf(line, \"cpu MHz : %lf\", &freq_ghz) == 1) { freq_ghz /= 1000.0; // 转换为GHz break; } } fclose(fp); return freq_ghz; } int main() { double cpu_ghz = get_cpu_ghz(); if (cpu_ghz == 0.0) { cpu_ghz = 2.5; // 默认值 printf(\"Warning: Using default CPU frequency: %.2f GHz\\n\", cpu_ghz); } else { printf(\"Detected CPU frequency: %.2f GHz\\n\", cpu_ghz); } unsigned int aux; unsigned long long tsc1, tsc2; tsc1 = __rdtscp(&aux); // 要测量的代码 for (volatile int i = 0; i 类似的，在Windows系统上，获得准确的CPU频率，然后计算对应的时间。 #include #include #include #pragma intrinsic(__rdtscp) double get_cpu_ghz() { HKEY hKey; DWORD freq_mhz = 0; DWORD size = sizeof(freq_mhz); if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, \"HARDWARE\\\\DESCRIPTION\\\\System\\\\CentralProcessor\\\\0\", 0, KEY_READ, &hKey) == ERROR_SUCCESS) { RegQueryValueExA(hKey, \"~MHz\", NULL, NULL, (LPBYTE)&freq_mhz, &size); RegCloseKey(hKey); } return freq_mhz / 1000.0; // 转换为GHz } 方法3：使用标准库校准（最准确） 通过测量已知时间间隔内的周期数来计算实际频率。 #include #include #include #include // for usleep // 校准函数，计算实际的CPU频率 double calibrate_cpu_frequency() { const long long calibrate_time_us = 100000; // 100ms校准时间 unsigned int aux; // 第一次测量 struct timespec start, end; unsigned long long tsc_start, tsc_end; clock_gettime(CLOCK_MONOTONIC, &start); tsc_start = __rdtscp(&aux); // 等待一段时间 usleep(calibrate_time_us); clock_gettime(CLOCK_MONOTONIC, &end); tsc_end = __rdtscp(&aux); // 计算经过的时间（纳秒） long long time_ns = (end.tv_sec - start.tv_sec) * 1000000000LL + (end.tv_nsec - start.tv_nsec); // 计算频率（GHz） double freq_ghz = (double)(tsc_end - tsc_start) / time_ns; printf(\"Calibrated CPU frequency: %.6f GHz\\n\", freq_ghz); return freq_ghz; } int main() { double cpu_ghz = calibrate_cpu_frequency(); unsigned int aux; unsigned long long tsc1, tsc2; tsc1 = __rdtscp(&aux); // 要测量的代码 for (volatile int i = 0; i 方法4：直接使用高精度计时器（最简单） 对于大多数应用，直接使用操作系统提供的高精度计时器可能更简单可靠： 对于Linux系统 #include struct timespec start, end; clock_gettime(CLOCK_MONOTONIC, &start); // 要测量的代码 clock_gettime(CLOCK_MONOTONIC, &end); long long time_ns = (end.tv_sec - start.tv_sec) * 1000000000LL + (end.tv_nsec - start.tv_nsec); 对于Windows系统 #include LARGE_INTEGER frequency, start, end; QueryPerformanceFrequency(&frequency); QueryPerformanceCounter(&start); // 要测量的代码 QueryPerformanceCounter(&end); double time_sec = (double)(end.QuadPart - start.QuadPart) / frequency.QuadPart; © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-12 "},"datastruct/intro.html":{"url":"datastruct/intro.html","title":"数据结构与算法","keywords":"","body":"数据结构 数据结构是计算机专业的必须课程，通常与算法课程相关，是很多专业课程的前导课程，在整个计算机专业中占据重要地位，但学习起来并不是很轻松。 这部分记录数据结构相关内容，持续更新中。（或可从C语言、C++、Java等不同角度解读） 前期版本参考数据结构合集 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/intro.html":{"url":"miracldoc/intro.html","title":"Miracl密码库","keywords":"","body":"欢迎来到Miracl教程 Miracl-SDK在GitHub上，下载点这里。目前（2024）该库已经有5年没有更新。 Miracl官方提供了一份安装配置教程和一份参考手册。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-10 "},"miracldoc/install.html":{"url":"miracldoc/install.html","title":"环境配置","keywords":"","body":"MIRACL环境配置 本文介绍MIRACL的环境配置，目前以MacOS系统为例。 准备工作 实验运行的环境介绍。 系统参数 参考操作系统的相关参数：Version 21.3.0，arm64 % uname -a Darwin LisldeMacBook-Pro.local 21.3.0 Darwin Kernel Version 21.3.0: Wed Jan 5 21:37:58 PST 2022; root:xnu-8019.80.24~20/RELEASE_ARM64_T8101 arm64 编译环境 本实验目前全部采用C语言编译，所以配置gcc环境。 % gcc -v Configured with: --prefix=/Library/Developer/CommandLineTools/usr --with-gxx-include-dir=/Library/Developer/CommandLineTools/SDKs/MacOSX12.3.sdk/usr/include/c++/4.2.1 Apple clang version 13.0.0 (clang-1300.0.27.3) Target: arm64-apple-darwin21.3.0 Thread model: posix InstalledDir: /Library/Developer/CommandLineTools/usr/bin Miracl环境 Miracl-SDK在GitHub上，下载点这里。目前（2024）该库已经有5年没有更新。 Miracl官方提供了一份安装配置教程和一份参考手册。 下载Miracl源文件，准备在本地安装。 Miracl源码结构 。。。 安装Miracl 逐步添加源文件，解析Miracl源码。 初始化Miracl项目 添加主要文件，编译Miracl静态库。 在Miracl源文件中找到以下几个文件：mirdef.h、mirdef.h64、mrcore.c、miracl.h，复制该文件到新目录。 新建文件Makefile，用该文件管理整个项目。 #生成 MIRACL 密码库的静态库 #操作环境：MacOS 64位 #ar 维护链接编辑器使用的索引库 #-c 屏蔽库创建时的正确消息提示 #-r 替换已经存在的文件 miracl.a : mrcore.o ar -cr miracl.a mrcore.o #-c 表示编译并生成目标文件 #-m64 表示程序的宿主机器cpu架构是amd64 #-O0 表示没有优化, -O1 为默认值，-O3 优化级别最高 mrcore.o : mrcore.c gcc -c -o -m64 mrcore.o mrcore.c clean : rm -f *.o *.a 编译Makefile，可能出现下面的错误提示 % make gcc -c -o -m64 mrcore.o mrcore.c clang: error: no such file or directory: 'mrcore.o' make: *** [mrcore.o] Error 1 这是由于-m64不能被系统检测，为此，先去掉Makefile中的参数-m64。再次编译，最好的结果是打印下面的信息。 % make gcc -c -o mrcore.o mrcore.c ar -cr miracl.a mrcore.o 还可能出现类似下面的错误提示 % make gcc -c -o mrcore.o mrcore.c In file included from mrcore.c:45: ./miracl.h:303:31: error: expected ';' after top level declarator typedef unsigned mr_dltype mr_large; 首先看到的是typedef unsigned mr_dltype mr_large;，这个定义本身是没有问题的，mr_dltype本身就是一个声明类型，导致这个错误的原因，肯定是没有声明mr_dltype。所以定义unsigned mr_dltype的别名为mr_large是不可能的，后面还有很多关于mr_large的错误。现在需要知道mr_dltype在哪里定义？在mirdef.h有对mr_dltype的定义，虽然miracl.h有对mirdef.h的包含，但是依然没有起作用。 #include \"mirdef.h\" #define mr_dltype __int64 问题应该出在__int64的定义上，__int64为long long for Unix/Linux。__int64为微软MSVC定义的数据类型，long long为C99定义的数据类型。 写一小段程序测试 #include typedef long long __int64; int main(){ __int64 a; printf(\"%lu\\n\", sizeof(a));//8 //-9223372036854775808～+9223372036854775807 printf(\"%lu\\n\", sizeof(long));//8 printf(\"%lu\\n\", sizeof(long long));//8 printf(\"%lu\\n\", sizeof(int));//4 a = 9223372036854775806; printf(\"%lld\\n\", a); return 0; } 在本系统上，long类型和long long类型，都是8字节大小，所能够表示的数据范围为-9223372036854775808～+9223372036854775807。而且，在本系统上，long long类型是可用的。 现在，修改mirdef.h中关于__int64的定义 // #define mr_dltype __int64 /* ... or long long for Unix/Linux */ // #define mr_unsign64 unsigned __int64 #define mr_dltype long long #define mr_unsign64 unsigned long long 在MacOS arm64上编译，与数据类型__int64相关，而__int64类型的原本定义是long long类型，在arm64上是支持的。 修改完成之后，再次用make编译，是可以成功编译的。现在将其他的.c文件全部编译到静态库文件中。 mrbrick.c mrflsh1.c mrjack.c mrshs.c mrbuild.c mrflsh2.c mrlucas.c mrshs256.c mrflsh3.c mrmonty.c mrshs512.c mirdef.h64 mrcrt.c mrflsh4.c mrmuldv.c mrsmall.c mraes.c mrcurve.c mrfpe.c mrpi.c mrsroot.c mralloc.c mrdouble.c mrfrnd.c mrpower.c mrstrong.c mrarth0.c mrebrick.c mrgcd.c mrprime.c mrxgcd.c mrarth1.c mrec2m.c mrgcm.c mrrand.c mrzzn2.c mrarth2.c mrecn2.c mrgf2m.c mrround.c mrzzn2b.c mrarth3.c mrfast.c mrio1.c mrscrt.c mrzzn3.c mrbits.c mrflash.c mrio2.c mrsha3.c mrzzn4.c 完成文件复制之后，编译所有文件，做成静态库，在Makefile里面添加下面内容。 #生成 MIRACL 密码库的静态库 #操作环境：MacOS 64位 #ar 维护链接编辑器使用的索引库 #-c 屏蔽库创建时的正确消息提示 #-r 替换已经存在的文件 miracl.a : mrcore.o mrarth0.o mrarth1.o mrarth2.o mralloc.o mrsmall.o mrio1.o mrio2.o mrgcd.o mrjack.o mrxgcd.o mrarth3.o mrbits.o mrrand.o mrprime.o mrcrt.o mrscrt.o mrmonty.o mrpower.o mrsroot.o mrcurve.o mrfast.o mrshs.o mrshs256.o mrshs512.o mrsha3.o mrfpe.o mraes.o mrgcm.o mrlucas.o mrzzn2.o mrzzn2b.o mrzzn3.o mrzzn4.o mrecn2.o mrstrong.o mrbrick.o mrebrick.o mrec2m.o mrgf2m.o mrflash.o mrfrnd.o mrdouble.o mrround.o mrbuild.o mrflsh1.o mrpi.o mrflsh2.o mrflsh3.o mrflsh4.o mrmuldv.o ar -cr miracl.a mrcore.o mrarth0.o mrarth1.o mrarth2.o mralloc.o mrsmall.o mrio1.o mrio2.o mrgcd.o mrjack.o mrxgcd.o mrarth3.o mrbits.o mrrand.o mrprime.o mrcrt.o mrscrt.o mrmonty.o mrpower.o mrsroot.o mrcurve.o mrfast.o mrshs.o mrshs256.o mrshs512.o mrsha3.o mrfpe.o mraes.o mrgcm.o mrlucas.o mrzzn2.o mrzzn2b.o mrzzn3.o mrzzn4.o mrecn2.o mrstrong.o mrbrick.o mrebrick.o mrec2m.o mrgf2m.o mrflash.o mrfrnd.o mrdouble.o mrround.o mrbuild.o mrflsh1.o mrpi.o mrflsh2.o mrflsh3.o mrflsh4.o mrmuldv.o #-c 表示编译并生成目标文件 #-m64 表示程序的宿主机器cpu架构是amd64 #-O0 表示没有优化, -O1 为默认值，-O3 优化级别最高 mrcore.o : mrcore.c gcc -c -o mrcore.o mrcore.c mrarth0.o : mrarth0.c gcc -c -o mrarth0.o mrarth0.c mrarth1.o : mrarth1.c gcc -c -o mrarth1.o mrarth1.c mrarth2.o : mrarth2.c gcc -c -o mrarth2.o mrarth2.c mralloc.o : mralloc.c gcc -c -o mralloc.o mralloc.c mrsmall.o : mrsmall.c gcc -c -o mrsmall.o mrsmall.c mrio1.o : mrio1.c gcc -c -o mrio1.o mrio1.c mrio2.o : mrio2.c gcc -c -o mrio2.o mrio2.c mrgcd.o : mrgcd.c gcc -c -o mrgcd.o mrgcd.c mrjack.o : mrjack.c gcc -c -o mrjack.o mrjack.c mrxgcd.o : mrxgcd.c gcc -c -o mrxgcd.o mrxgcd.c mrarth3.o : mrarth3.c gcc -c -o mrarth3.o mrarth3.c mrbits.o : mrbits.c gcc -c -o mrbits.o mrbits.c mrrand.o : mrrand.c gcc -c -o mrrand.o mrrand.c mrprime.o : mrprime.c gcc -c -o mrprime.o mrprime.c mrcrt.o : mrcrt.c gcc -c -o mrcrt.o mrcrt.c mrscrt.o : mrscrt.c gcc -c -o mrscrt.o mrscrt.c mrmonty.o : mrmonty.c gcc -c -o mrmonty.o mrmonty.c mrpower.o : mrpower.c gcc -c -o mrpower.o mrpower.c mrsroot.o : mrsroot.c gcc -c -o mrsroot.o mrsroot.c mrcurve.o : mrcurve.c gcc -c -o mrcurve.o mrcurve.c mrfast.o : mrfast.c gcc -c -o mrfast.o mrfast.c mrshs.o : mrshs.c gcc -c -o mrshs.o mrshs.c mrshs256.o : mrshs256.c gcc -c -o mrshs256.o mrshs256.c mrshs512.o : mrshs512.c gcc -c -o mrshs512.o mrshs512.c mrsha3.o : mrsha3.c gcc -c -o mrsha3.o mrsha3.c mrfpe.o : mrfpe.c gcc -c -o mrfpe.o mrfpe.c mraes.o : mraes.c gcc -c -o mraes.o mraes.c mrgcm.o : mrgcm.c gcc -c -o mrgcm.o mrgcm.c mrlucas.o : mrlucas.c gcc -c -o mrlucas.o mrlucas.c mrzzn2.o : mrzzn2.c gcc -c -o mrzzn2.o mrzzn2.c mrzzn2b.o : mrzzn2b.c gcc -c -o mrzzn2b.o mrzzn2b.c mrzzn3.o : mrzzn3.c gcc -c -o mrzzn3.o mrzzn3.c mrzzn4.o : mrzzn4.c gcc -c -o mrzzn4.o mrzzn4.c mrecn2.o : mrecn2.c gcc -c -o mrecn2.o mrecn2.c mrstrong.o : mrstrong.c gcc -c -o mrstrong.o mrstrong.c mrbrick.o : mrbrick.c gcc -c -o mrbrick.o mrbrick.c mrebrick.o : mrebrick.c gcc -c -o mrebrick.o mrebrick.c mrec2m.o : mrec2m.c gcc -c -o mrec2m.o mrec2m.c mrgf2m.o : mrgf2m.c gcc -c -o mrgf2m.o mrgf2m.c mrflash.o : mrflash.c gcc -c -o mrflash.o mrflash.c mrfrnd.o : mrfrnd.c gcc -c -o mrfrnd.o mrfrnd.c mrdouble.o : mrdouble.c gcc -c -o mrdouble.o mrdouble.c mrround.o : mrround.c gcc -c -o mrround.o mrround.c mrbuild.o : mrbuild.c gcc -c -o mrbuild.o mrbuild.c mrflsh1.o : mrflsh1.c gcc -c -o mrflsh1.o mrflsh1.c mrpi.o : mrpi.c gcc -c -o mrpi.o mrpi.c mrflsh2.o : mrflsh2.c gcc -c -o mrflsh2.o mrflsh2.c mrflsh3.o : mrflsh3.c gcc -c -o mrflsh3.o mrflsh3.c mrflsh4.o : mrflsh4.c gcc -c -o mrflsh4.o mrflsh4.c mrmuldv.o : mrmuldv.c gcc -c -o mrmuldv.o mrmuldv.c clean : rm -f *.o *.a 编译之后，我们希望看到下面的结果。 % make gcc -c -o mrcore.o mrcore.c gcc -c -o mrarth0.o mrarth0.c gcc -c -o mrarth1.o mrarth1.c gcc -c -o mrarth2.o mrarth2.c gcc -c -o mralloc.o mralloc.c gcc -c -o mrsmall.o mrsmall.c gcc -c -o mrio1.o mrio1.c gcc -c -o mrio2.o mrio2.c gcc -c -o mrgcd.o mrgcd.c gcc -c -o mrjack.o mrjack.c gcc -c -o mrxgcd.o mrxgcd.c gcc -c -o mrarth3.o mrarth3.c gcc -c -o mrbits.o mrbits.c gcc -c -o mrrand.o mrrand.c gcc -c -o mrprime.o mrprime.c gcc -c -o mrcrt.o mrcrt.c gcc -c -o mrscrt.o mrscrt.c gcc -c -o mrmonty.o mrmonty.c gcc -c -o mrpower.o mrpower.c gcc -c -o mrsroot.o mrsroot.c gcc -c -o mrcurve.o mrcurve.c gcc -c -o mrfast.o mrfast.c gcc -c -o mrshs.o mrshs.c gcc -c -o mrshs256.o mrshs256.c gcc -c -o mrshs512.o mrshs512.c gcc -c -o mrsha3.o mrsha3.c gcc -c -o mrfpe.o mrfpe.c gcc -c -o mraes.o mraes.c gcc -c -o mrgcm.o mrgcm.c gcc -c -o mrlucas.o mrlucas.c gcc -c -o mrzzn2.o mrzzn2.c gcc -c -o mrzzn2b.o mrzzn2b.c gcc -c -o mrzzn3.o mrzzn3.c gcc -c -o mrzzn4.o mrzzn4.c gcc -c -o mrecn2.o mrecn2.c gcc -c -o mrstrong.o mrstrong.c gcc -c -o mrbrick.o mrbrick.c gcc -c -o mrebrick.o mrebrick.c gcc -c -o mrec2m.o mrec2m.c gcc -c -o mrgf2m.o mrgf2m.c gcc -c -o mrflash.o mrflash.c gcc -c -o mrfrnd.o mrfrnd.c gcc -c -o mrdouble.o mrdouble.c gcc -c -o mrround.o mrround.c gcc -c -o mrbuild.o mrbuild.c gcc -c -o mrflsh1.o mrflsh1.c gcc -c -o mrpi.o mrpi.c gcc -c -o mrflsh2.o mrflsh2.c gcc -c -o mrflsh3.o mrflsh3.c gcc -c -o mrflsh4.o mrflsh4.c gcc -c -o mrmuldv.o mrmuldv.c ar -cr miracl.a mrcore.o mrarth0.o mrarth1.o mrarth2.o mralloc.o mrsmall.o mrio1.o mrio2.o mrgcd.o mrjack.o mrxgcd.o mrarth3.o mrbits.o mrrand.o mrprime.o mrcrt.o mrscrt.o mrmonty.o mrpower.o mrsroot.o mrcurve.o mrfast.o mrshs.o mrshs256.o mrshs512.o mrsha3.o mrfpe.o mraes.o mrgcm.o mrlucas.o mrzzn2.o mrzzn2b.o mrzzn3.o mrzzn4.o mrecn2.o mrstrong.o mrbrick.o mrebrick.o mrec2m.o mrgf2m.o mrflash.o mrfrnd.o mrdouble.o mrround.o mrbuild.o mrflsh1.o mrpi.o mrflsh2.o mrflsh3.o mrflsh4.o mrmuldv.o 但是在编译mrmuldv.c的时候，可能出现这样的错误提示。 error: use of undeclared identifier '_asm' 原因在于，gcc支持asm，但是不支持_asm，所以将mrmuldv.c对应的定义修改 // #define ASM _asm #define ASM asm 出现新的错误 error: expected 'volatile', 'inline', 'goto', or '(' ASM mov eax,DWORD PTR a 到这里出现错误，属于汇编部分内容了。先不忙着去学习汇编，再次阅读文档发现，在mrmuldv.any中给出了各种环境的可能文件，例如选择mrmuldv.g64文件，将mrmuldv.g64修改为mrmuldv.c，然后编译，将出现类似下面的错误。 error: unknown register name 'rax' in asm : \"rax\",\"rbx\",\"memory\" 很明显，这是由于系统环境所导致的。选择mrmuldv.ccc，然后将mrmuldv.ccc修改为mrmuldv.c，再次编译应该不会出现上述问题了。 以上完成了Miracl中主要文件的静态打包。 测试 测试编译好的静态库，根据linux64的指导，测试ecsgen，将下面的文件放在一个目录下，其中miracl.a就是编译得到的静态库。 Makefile big.h ecn.h miracl.a mirdef.h big.cpp ecn.cpp ecsgen.cpp miracl.h 同样的，利用Makefile管理项目，Makefile的内容如下。 # 测试 ecsgen.cpp ecsgen : big.o miracl.a ecsgen.o ecn.o g++ -o ecsgen big.o miracl.a ecsgen.o ecn.o big.o : big.cpp g++ -c -o big.o big.cpp ecn.o : ecn.cpp g++ -c -o ecn.o ecn.cpp ecsgen.o : ecsgen.cpp g++ -c -o ecsgen.o ecsgen.cpp clean : rm -f *.o 经过编译，得到下面的提示信息，表示编译通过。 % make g++ -c -o big.o big.cpp g++ -c -o ecsgen.o ecsgen.cpp g++ -c -o ecn.o ecn.cpp g++ -o ecsgen big.o miracl.a ecsgen.o ecn.o 在Makefile的编辑中，可能会按照如下方式编辑，导致编译出错。 # 测试 ecsgen.cpp ecsgen : big.o miracl.a ecsgen.o ecn.o gcc -o ecsgen big.o miracl.a ecsgen.o ecn.o big.o : big.cpp gcc -c -o big.o big.cpp ecn.o : ecn.cpp gcc -c -o ecn.o ecn.cpp ecsgen.o : ecsgen.cpp gcc -c -o ecsgen.o ecsgen.cpp clean : rm -f *.o ecsgen 用gcc来编译，却发生了下面的错误。 Undefined symbols for architecture arm64: \"std::__1::locale::use_facet(std::__1::locale::id&) const\", referenced from: std::__1::ctype const& std::__1::use_facet >(std::__1::locale const&) in big.o std::__1::ctype const& std::__1::use_facet >(std::__1::locale const&) in ecsgen.o ... 在linux64的指导里面，用的是g++编译，gcc和g++是两个不同版本，查看版本，发现两者完全相同。 % g++ -v Configured with: --prefix=/Library/Developer/CommandLineTools/usr --with-gxx-include-dir=/Library/Developer/CommandLineTools/SDKs/MacOSX12.3.sdk/usr/include/c++/4.2.1 Apple clang version 13.0.0 (clang-1300.0.27.3) Target: arm64-apple-darwin21.3.0 Thread model: posix InstalledDir: /Library/Developer/CommandLineTools/usr/bin 为什么用gcc编译报错呢？ gcc是GNU开发的针对c的编译器，刚开始只支持编译c代码，随着gcc的发展愈发强大，后面gcc也支持编译c++、Objective-c和java等，在编译时需要通过设定参数指定编译的语言。所以后来，gcc默认编译的是c代码。把参数给用户设置显然没有那么友好，于是就专门针对c++ 开发了g++编译器。所以gcc是一个编译器集合，而g++是针对c++的编译器。因此，想要使用gcc编译c++的代码需要加上参数-lstdc++指令。 # 测试 ecsgen.cpp ecsgen : big.o miracl.a ecsgen.o ecn.o gcc -lstdc++ -o ecsgen big.o miracl.a ecsgen.o ecn.o big.o : big.cpp gcc -c -lstdc++ -o big.o big.cpp ecn.o : ecn.cpp gcc -c -lstdc++ -o ecn.o ecn.cpp ecsgen.o : ecsgen.cpp gcc -c -lstdc++ -o ecsgen.o ecsgen.cpp clean : rm -f *.o ecsgen 执行编译后的可执行文件 % ./ecsgen Enter 9 digit random number seed = 322476589 MIRACL error from routine prepare_monty called from ecurve_init called from your program Illegal modulus 很可惜，并没有通过。这必然是由于ecurve函数调用失败导致的，而导致这个错误的原因，就是因为没有添加common.ecs文件，将这个文件包含进项目，再次测试，就能够得到正确结果。 % ./ecsgen Enter 9 digit random number seed = 384738928 public key = 1 5077662368640563685149485350869738525687256375694504212009 Miracl库是一个非常强大的密码库，在构建这个项目的时候，最重要的是要生成SDK，这个过程就是生成静态库的过程，常常会遇到很多问题。 主要问题就是环境因素，在mrmuldv.any中给出了一系列的可能环境，根据自己的机器环境，选择不同的环境代码，才能够得到自己的静态库。我想这也是为什么没有给出一个固定的SDK的原因吧，毕竟每个人的应用环境是不同的。但是，不得不说，这个SDK的搭建，确实存在很大的挑战。所以，用Makefile来管理所有文件，能够轻松掌握。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-10 "},"miracldoc/curvePara.html":{"url":"miracldoc/curvePara.html","title":"曲线参数","keywords":"","body":"MIRACL Standard Curves 曲线方程 y2=x3+Ax+B  mod  p y^2 = x^3 + Ax+B ~~ mod ~~ p y​2​​=x​3​​+Ax+B  mod  p 其中质数ppp全等于3  mod  43~~mod~~43  mod  4，A=−3A=-3A=−3。质数ppp长度为nnn，曲线上点的个数qqq也是质数。 ssc-160 n=160 B=993193335754933797118314178888153828594854512705 p=1147860701762054730346201299935827782113538756127 q=1147860701762054730346200648614608152209809891831 ssc-192 n=192 B=4265732895672588129268258440977714335632089762934383523494 p=4930024174431634640599033341057067222865862716297522433299 q=4930024174431634640599033341125441632693811654341940586403 ssc-224 n=224 B=18321183280385145938884990414875229336370193019939570227257813318147 p=21174292597673270169193562049053717791882423761323585056162680913631 q=21174292597673270169193562049053723134442099121024262551089688143309 ssc-256 n=256 B=78688883013276200091698248537162581920209762369847930022367595957783191893217 p=90942894222941581070058735694432465663348344332098107489693037779484723616779 q=90942894222941581070058735694432465663288414616171509431879910319924502217783 ssc-288 n=288 B=337966179100791213208996178567593129982221810838428315939365373128820605838874928979766 p=390596756491121423614434954606695289304724084762108334731724254341779347664665278286219 q=390596756491121423614434954606695289304724116479393090921502092797686514928150248753237 ssc-320 n=320 B=1451553686391976948456801799936788618707919738968947956999929796583121697128874465400872041660580 p=1677600295053042228788960243555000810201048522356787237681776606087928304667951345024875097229491 q=1677600295053042228788960243555000810201048522357873106251579120122685384485967275546948559607409 ssc-384 n=384 B=26776439362122453792588319552731959650141032425239760139617629033244994517401871440317035340712170298670944533378961 p=30946263300823101954888425259784296108860594177929936231961025381527827855583154673559277957637088071546809309873019 q=30946263300823101954888425259784296108860594177929936231959195086011429040851460901626189237585847628753659044398489 ssc-512 n=512 B=9111550163858012281440901732746538838772262590143654133938674743542107885492015390851248618042056679983385207705625699101049041930943171450852516780927629 p=10530467723362659054861705371139847026313999328372313651398671272025951445569024729948471343061931586610942824229083371331823229156399790385588443550959087 q=10530467723362659054861705371139847026313999328372313651398671272025951445569144524507377363887941433449823713742916287342504795006316114468040283111710577 © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-04 "},"miracldoc/demo/ecsgen.html":{"url":"miracldoc/demo/ecsgen.html","title":"ecsgen.cpp","keywords":"","body":"剖析ecsgen.cpp文件 测试编译好的静态库，根据linux64的指导，测试ecsgen（Elliptic Curve Digital Signature Algorithm），将下面的文件放在一个目录下，其中miracl.a就是编译得到的静态库。 Makefile big.h ecn.h miracl.a mirdef.h big.cpp ecn.cpp ecsgen.cpp miracl.h ecsgen.cpp文件源码 /* * Elliptic Curve Digital Signature Algorithm (ECDSA) * * * This program generates one set of public and private keys in files * public.ecs and private.ecs respectively. Notice that the public key * can be much shorter in this scheme, for the same security level. * * It is assumed that Curve parameters are to be found in file common.ecs * * The curve is y^2=x^3+Ax+B mod p * * The file common.ecs is presumed to exist, and to contain the domain * information {p,A,B,q,x,y}, where A and B are curve parameters, (x,y) are * a point of order q, p is the prime modulus, and q is the order of the * point (x,y). In fact normally q is the prime number of points counted * on the curve. * * Requires: big.cpp ecn.cpp */ #include #include #include \"ecn.h\" using namespace std; // if MR_STATIC defined, it should be 20 #ifndef MR_NOFULLWIDTH Miracl precision=20; #else Miracl precision(20,MAXBASE); #endif int main() { ifstream common(\"common.ecs\"); /* construct file I/O streams */ ofstream public_key(\"public.ecs\"); ofstream private_key(\"private.ecs\"); int bits,ep; miracl *mip=&precision; ECn G,W; Big a,b,p,q,x,y,d; long seed; cout > seed; irand(seed); common >> bits; mip->IOBASE=16; common >> p >> a >> b >> q >> x >> y; mip->IOBASE=10; ecurve(a,b,p,MR_PROJECTIVE); if (!G.set(x,y)) { cout Makefile文件和测试 用Makefile管理项目，Makefile的内容如下。 # 测试 ecsgen.cpp ecsgen : big.o miracl.a ecsgen.o ecn.o g++ -o ecsgen big.o miracl.a ecsgen.o ecn.o big.o : big.cpp g++ -c -o big.o big.cpp ecn.o : ecn.cpp g++ -c -o ecn.o ecn.cpp ecsgen.o : ecsgen.cpp g++ -c -o ecsgen.o ecsgen.cpp clean : rm -f *.o 经过编译，得到下面的提示信息，表示编译通过。 % make g++ -c -o big.o big.cpp g++ -c -o ecsgen.o ecsgen.cpp g++ -c -o ecn.o ecn.cpp g++ -o ecsgen big.o miracl.a ecsgen.o ecn.o 在Makefile的编辑中，可能会按照如下方式编辑，导致编译出错。 # 测试 ecsgen.cpp ecsgen : big.o miracl.a ecsgen.o ecn.o gcc -o ecsgen big.o miracl.a ecsgen.o ecn.o big.o : big.cpp gcc -c -o big.o big.cpp ecn.o : ecn.cpp gcc -c -o ecn.o ecn.cpp ecsgen.o : ecsgen.cpp gcc -c -o ecsgen.o ecsgen.cpp clean : rm -f *.o ecsgen 用gcc来编译，却发生了下面的错误。 Undefined symbols for architecture arm64: \"std::__1::locale::use_facet(std::__1::locale::id&) const\", referenced from: std::__1::ctype const& std::__1::use_facet >(std::__1::locale const&) in big.o std::__1::ctype const& std::__1::use_facet >(std::__1::locale const&) in ecsgen.o ... 在linux64的指导里面，用的是g++编译，gcc和g++是两个不同版本，查看版本，发现两者完全相同。 % g++ -v Configured with: --prefix=/Library/Developer/CommandLineTools/usr --with-gxx-include-dir=/Library/Developer/CommandLineTools/SDKs/MacOSX12.3.sdk/usr/include/c++/4.2.1 Apple clang version 13.0.0 (clang-1300.0.27.3) Target: arm64-apple-darwin21.3.0 Thread model: posix InstalledDir: /Library/Developer/CommandLineTools/usr/bin 为什么用gcc编译报错呢？ gcc是GNU开发的针对c的编译器，刚开始只支持编译c代码，随着gcc的发展愈发强大，后面gcc也支持编译c++、Objective-c和java等，在编译时需要通过设定参数指定编译的语言。所以后来，gcc默认编译的是c代码。把参数留给用户设置显然没有那么友好，于是就专门针对c++ 开发了g++编译器。所以gcc是一个编译器集合，而g++是针对c++的编译器。因此，想要使用gcc编译c++的代码需要加上参数-lstdc++指令。 # 测试 ecsgen.cpp ecsgen : big.o miracl.a ecsgen.o ecn.o gcc -lstdc++ -o ecsgen big.o miracl.a ecsgen.o ecn.o big.o : big.cpp gcc -c -lstdc++ -o big.o big.cpp ecn.o : ecn.cpp gcc -c -lstdc++ -o ecn.o ecn.cpp ecsgen.o : ecsgen.cpp gcc -c -lstdc++ -o ecsgen.o ecsgen.cpp clean : rm -f *.o ecsgen 执行编译后的可执行文件 % ./ecsgen Enter 9 digit random number seed = 322476589 MIRACL error from routine prepare_monty called from ecurve_init called from your program Illegal modulus 很可惜，并没有通过。这必然是由于ecurve函数调用失败导致的，而导致这个错误的原因，就是因为没有添加common.ecs文件，将这个文件包含进项目，再次测试，就能够得到正确结果。 % ./ecsgen Enter 9 digit random number seed = 384738928 public key = 1 5077662368640563685149485350869738525687256375694504212009 Miracl库是一个非常强大的密码库，在构建这个项目的时候，最重要的是要生成SDK，这个过程就是生成静态库的过程，常常会遇到很多问题。 主要问题就是环境因素，在mrmuldv.any中给出了一系列的可能环境，根据自己的机器环境，选择不同的环境代码，才能够得到自己的静态库。我想这也是为什么没有给出一个固定的SDK的原因吧，毕竟每个人的应用环境是不同的。但是，不得不说，这个SDK的搭建，确实存在很大的挑战。所以，用Makefile来管理所有文件，能够轻松掌握。 源码分析 密码原理 Elliptic Curve Digital Signature Algorithm (ECDSA)，椭圆曲线上的数字签名算法，假设椭圆曲线为 y2=x3+Ax+B  mod  p y^2=x^3+Ax+B ~~ mod ~~ p y​2​​=x​3​​+Ax+B  mod  p 参数p,A,B,q{p,A,B,q}p,A,B,q在common.ecs里面，(x,y)(x,y)(x,y)为椭圆曲线上的点，取值分别为bits、p、a、b、q、x、y。 192 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF -3 64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1 FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831 188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012 07192B95FFC8DA78631011ED6B24CDD573F977A11E794811 过程：读入椭圆曲线参数，验证椭圆曲线参数的可行性，选择私钥，计算公钥，输出公私钥。 实现过程 下面逐行分析ECDSA的实现过程。 #ifndef MR_NOFULLWIDTH Miracl precision=20; #else Miracl precision(20,MAXBASE); #endif 如果定义了MR_NOFULLWIDTH，那么precision就是20，否则就是(20,MAXBASE)，其中MAXBASE在文件mirdef.h。 #define MIRACL 32 //定义MIRACL在32位计算机上执行 #define MAXBASE ((mr_small)1 1、读取椭圆曲线的参数。 读取文件信息，打开文件（写入公私钥）。common、public_key、private_key由C++提供。 ifstream common(\"common.ecs\"); /* construct file I/O streams */ ofstream public_key(\"public.ecs\"); ofstream private_key(\"private.ecs\"); 2、构造椭圆曲线。 设置变量，miracl类型定义在miracl.h中。 int bits,ep; miracl *mip=&precision; ECn类型定义在ecn.h，Big类型定义在big.h。 ECn G,W; Big a,b,p,q,x,y,d; long seed; 3、产生一个种子，验证椭圆曲线参数的可行性。 提示输入一个9位随机数，放在seed中，irand定义在miracl.h中，在mrcore.c中实现，初始化一个随机数。 cout > seed; irand(seed); 从common.ecs读取相应的值。 common >> bits; mip->IOBASE=16; common >> p >> a >> b >> q >> x >> y; mip->IOBASE=10; ecurve定义在big.h，实现在big.cpp，初始化一个椭圆曲线。 ecurve(a,b,p,MR_PROJECTIVE); // 获取椭圆曲线上的点(x,y) if (!G.set(x,y)) { cout 4、随机选择私钥，计算公钥，公私钥写入文件。 /* generate public/private keys */ d=rand(q); //产生随机值，作为私钥 // for (int i=0;i 测试案例 #include #include using namespace std; int main(){ ifstream common(\"common.ecs\"); /* construct file I/O streams */ ofstream public_key(\"public.ecs\"); ofstream private_key(\"private.ecs\"); int bits,ep; common >> bits; cout 在这个案例中，主要说明C++已经提供common、public_key、private_key等函数等实现。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/demo/mraes.html":{"url":"miracldoc/demo/mraes.html","title":"mraes.c","keywords":"","body":"mraes.c 测试AES算法，准备相关文件。其中mraes.c就是需要测试的文件，miracl.a就是编译得到的静态库。 Makefile miracl.a miracl.h mirdef.h mraes.c AES算法的实现，只需要miracl.a和相关头文件，及Miracl的静态库，是因为相关参数全部用数组的列出来了，而不是临时计算。如果临时计算，那就需要其他函数辅助。 Makefile文件和测试 用Makefile管理项目，Makefile的内容如下。 # AES加密算法测试 # 测试 mraes.c 文件 aes : aes.o miracl.a gcc -o aes aes.o miracl.a aes.o : mraes.c gcc -c -o aes.o mraes.c clean : rm -f *.o aes 经过编译，得到下面的提示信息，表示编译通过。 % make gcc -c -o aes.o mraes.c gcc -o aes aes.o miracl.a 执行编译后的可执行文件 % ./aes Key Size= 128 bits Plain= 000102030405060708090a0b0c0d0e0f Encrypt= fb8c0d88a89188332414b542f0a7d5d2 Decrypt= 000102030405060708090a0b0c0d0e0f Key Size= 192 bits Plain= 000102030405060708090a0b0c0d0e0f Encrypt= 0ec4d187a56d28f36b3959f445a956b9 Decrypt= 000102030405060708090a0b0c0d0e0f Key Size= 256 bits Plain= 000102030405060708090a0b0c0d0e0f Encrypt= e66e17e6963d760a8a80e000f2da44eb Decrypt= 000102030405060708090a0b0c0d0e0f 解析AES算法 1、定义相关运算和常量。 // 在 mirdef.h 中，有对 mr_unsign32 的定义：#define mr_unsign32 unsigned int #define MR_WORD mr_unsign32 // 状态字的长度，即明文分组的字长，128/32=4，构造状态矩阵的列数 /* this is fixed */ #define NB 4 /* rotates x one bit to the left */ // 8位二进制数 x 的最高位调换到最低位 #define ROTL(x) (((x)>>7)|((x)>24)) #define ROTL16(x) (((x)>16)) #define ROTL24(x) (((x)>8)) 完成比特位左移1位操作 完成4字节左移，左移1字节 完成4字节左移，左移2字节 完成4字节左移，左移3字节 2、固定S盒等信息，避免临时计算。 static const MR_BYTE InCo[4] static const MR_BYTE ptab[] static const MR_BYTE ltab[] static const MR_BYTE fbsub[] static const MR_BYTE rbsub[] static const MR_WORD rco[] static const MR_WORD ftable[] static const MR_WORD rtable[] static const MR_WORD ftable1[] static const MR_WORD rtable1[] static const MR_WORD ftable2[] static const MR_WORD rtable2[] static const MR_WORD ftable3[] static const MR_WORD rtable3[] 3、定义随机数组，用于数据加密。 // unsigned 4 chars to unsigned int is 4 bytes to 32-bit // MR_WORD：unsigned int // MR_BYTE：unsigned char // 将4个char数据转换为1个int数据 static MR_WORD pack(const MR_BYTE *b) { /* pack bytes into a 32-bit Word */ // 4个字节全部强制转换为 MR_WORD 类型，然后分别左移3、2、1、0个字节，使得 4*byte = int return ((MR_WORD)b[3]>8); b[2]=MR_TOBYTE(a>>16); b[3]=MR_TOBYTE(a>>24); } 4、计算 Log(x)+Log(y)Log(x) + Log(y)Log(x)+Log(y) 的反对数，即 x∗y=AntiLog(Log(x)+Log(y))x*y= AntiLog(Log(x) + Log(y))x∗y=AntiLog(Log(x)+Log(y)) // 计算 Log(x) + Log(y) 的反对数，即 x.y= AntiLog(Log(x) + Log(y)) // 如果 x && y != 0，即x和y都不为0，则可以计算反对数 // bmul() 并没有给出反对数的算法，只是用数组给出一个固定的案例 static MR_BYTE bmul(MR_BYTE x,MR_BYTE y) { /* x.y= AntiLog(Log(x) + Log(y)) */ if (x && y) return ptab[(ltab[x]+ltab[y])%255]; else return 0; } 5、完成1个Word（4个Byte）的置换，先将1个Word转换为4个Byte，然后查表置换，最后将4个Byte转换为1个Word返回。 // 完成1个Word（4个Byte）的置换 static MR_WORD SubByte(MR_WORD a) { MR_BYTE b[4]; unpack(a,b); // 将1个Word转换为4个Byte // 查表完成置换 b[0]=fbsub[b[0]]; b[1]=fbsub[b[1]]; b[2]=fbsub[b[2]]; b[3]=fbsub[b[3]]; return pack(b); // 将4个Byte转换为1个Word } 6、两个4字节点乘，先将1个Word转换为4个Byte，然后对每个字节两两相乘，最后将点乘的结果做异或运算返回。 // 两个4字节点乘 static MR_BYTE product(MR_WORD x,MR_WORD y) { /* dot product of two 4-byte arrays */ MR_BYTE xb[4],yb[4]; unpack(x,xb); // 将1个Word转换为4个Byte unpack(y,yb); // 每个字节两两相乘，最后将点乘的结果做异或运算 return bmul(xb[0],yb[0])^bmul(xb[1],yb[1])^bmul(xb[2],yb[2])^bmul(xb[3],yb[3]); } 7、实现两个4字节矩阵乘法运算 static MR_WORD InvMixCol(MR_WORD x) { /* matrix Multiplication */ MR_WORD y,m; MR_BYTE b[4]; m=pack(InCo); // 将4个Byte转换为1个Word b[3]=product(m,x); // 两个4字节矩阵点乘 m=ROTL24(m); // 左移3个字节 b[2]=product(m,x); m=ROTL24(m); b[1]=product(m,x); m=ROTL24(m); b[0]=product(m,x); y=pack(b); return y; } 8、重置AES，将16字节数组全部初始化。 /* 重置AES，将16字节数组 f 全部初始化 aes类型变量，确定AES相关的参数 参数mode：工作模式，AES为CBC模式 参数iv：初始向量 */ void aes_reset(aes *a,int mode,char *iv) { /* reset mode, or reset iv */ int i; a->mode=mode; for (i=0;if[i]=0; if (mode!=MR_ECB && iv!=NULL) { for (i=0;if[i]=iv[i]; } } 其中aes的定义如下，分别规定了AES 的密钥字长度，迭代次数，工作模式等相关信息。工作模式有五种： 电码本模式（Electronic Codebook Book (ECB)）； 密码分组链接模式（Cipher Block Chaining (CBC)）； 计算器模式（Counter (CTR)）； 密码反馈模式（Cipher FeedBack (CFB)）； 输出反馈模式（Output FeedBack (OFB)）； 在miracl.h定义了aes类型，就有工作模式的选择。 typedef struct { int Nk,Nr; int mode; mr_unsign32 fkey[60]; mr_unsign32 rkey[60]; char f[16]; } aes; 个人认为，该函数可以稍微调整，以优化效率，优化如下，仅供参考 void aes_reset(aes *a,int mode,char *iv) { /* reset mode, or reset iv */ int i; a->mode=mode; if (mode!=MR_ECB && iv!=NULL) { for (i=0;if[i]=iv[i]; }else{ for (i=0;if[i]=0; } } 9、获取16字节数组 f 的全部元素 void aes_getreg(aes *a,char *ir) { int i; for (i=0;if[i]; } 10、初始化 /* 初始化操作 a：获取AES的相关参数 mode：工作模式 nk：密钥字长度 key：密钥矩阵 iv：初始向量 */ BOOL aes_init(aes* a,int mode,int nk,char *key,char *iv) { /* Key=nk bytes */ /* currently NB.nk = 16, 24 or 32 */ /* Key Scheduler. Create expanded encryption key */ int i,j,k,N,nr; MR_WORD CipherKey[8]; // 最多有8个字长的密钥 nk/=4; // 密钥长度除以4，变成字，也就是列数 // 如果列数不是4、6、8，即不是AES-128、AES-192、AES-256 if (nk!=4 && nk!=6 && nk!=8) return FALSE; // 如果是AES-128、AES-192、AES-256，nk=4、6、8 /* nr is number of rounds */ nr=6+nk; // AES-128、AES-192、AES-256迭代的轮数 nr=10、12、14 a->Nk=nk; a->Nr=nr; // 初始化列数和轮数 aes_reset(a,mode,iv); // 初始化AES的16字节数组 f 和工作模式 N=NB*(nr+1); // 共需要的列数 // 将初始密钥16/24/32字节转换为4/6/8密钥字 for (i=j=0;ifkey[i]=CipherKey[i]; // 密钥扩充 // 列数j从nk开始，轮数k从0开始 for (j=nk,k=0;jfkey[j]=a->fkey[j-nk]^SubByte(ROTL24(a->fkey[j-1]))^rco[k]; if (nkfkey[i+j]=a->fkey[i+j-nk]^a->fkey[i+j-1]; } else { // if(nk>6) for (i=1;ifkey[i+j]=a->fkey[i+j-nk]^a->fkey[i+j-1]; if ((j+4)fkey[j+4]=a->fkey[j+4-nk]^SubByte(a->fkey[j+3]); for (i=5;ifkey[i+j]=a->fkey[i+j-nk]^a->fkey[i+j-1]; } } /* now for the expanded decrypt key in reverse order */ for (j=0;jrkey[j+N-NB]=a->fkey[j]; for (i=NB;irkey[k+j]=InvMixCol(a->fkey[i+j]); } for (j=N-NB;jrkey[j-N+NB]=a->fkey[j]; return TRUE; } 11、加密 加密过程中，用到了SSE指令集，如_mm_loadu_si128。 void aes_ecb_encrypt(aes *a,MR_BYTE *buff) { int i,j,k; MR_WORD p[4],q[4],*x,*y,*t; #ifdef AES_NI_SUPPORT __m128i ky,m = _mm_loadu_si128((__m128i *) buff); ky = _mm_loadu_si128((__m128i *) &a->fkey[0]); m = _mm_xor_si128 (m, ky); k=NB; for (i=1;iNr;i++) { ky=_mm_loadu_si128((__m128i *) &a->fkey[k]); m =_mm_aesenc_si128(m, ky); k+=4; } ky=_mm_loadu_si128((__m128i *) &a->fkey[k]); m=_mm_aesenclast_si128(m, ky); _mm_storeu_si128((__m128i *)buff, m); #else for (i=j=0;ifkey[i]; } k=NB; x=p; y=q; /* State alternates between x and y */ for (i=1;iNr;i++) { /* Nr is number of rounds. May be odd. */ #ifndef MR_SMALL_AES y[0]=a->fkey[k]^ftable[MR_TOBYTE(x[0])]^ ftable1[MR_TOBYTE(x[1]>>8)]^ ftable2[MR_TOBYTE(x[2]>>16)]^ ftable3[x[3]>>24]; y[1]=a->fkey[k+1]^ftable[MR_TOBYTE(x[1])]^ ftable1[MR_TOBYTE(x[2]>>8)]^ ftable2[MR_TOBYTE(x[3]>>16)]^ ftable3[x[0]>>24]; y[2]=a->fkey[k+2]^ftable[MR_TOBYTE(x[2])]^ ftable1[MR_TOBYTE(x[3]>>8)]^ ftable2[MR_TOBYTE(x[0]>>16)]^ ftable3[x[1]>>24]; y[3]=a->fkey[k+3]^ftable[MR_TOBYTE(x[3])]^ ftable1[MR_TOBYTE(x[0]>>8)]^ ftable2[MR_TOBYTE(x[1]>>16)]^ ftable3[x[2]>>24]; #else y[0]=a->fkey[k]^ftable[MR_TOBYTE(x[0])]^ ROTL8(ftable[MR_TOBYTE(x[1]>>8)])^ ROTL16(ftable[MR_TOBYTE(x[2]>>16)])^ ROTL24(ftable[x[3]>>24]); y[1]=a->fkey[k+1]^ftable[MR_TOBYTE(x[1])]^ ROTL8(ftable[MR_TOBYTE(x[2]>>8)])^ ROTL16(ftable[MR_TOBYTE(x[3]>>16)])^ ROTL24(ftable[x[0]>>24]); y[2]=a->fkey[k+2]^ftable[MR_TOBYTE(x[2])]^ ROTL8(ftable[MR_TOBYTE(x[3]>>8)])^ ROTL16(ftable[MR_TOBYTE(x[0]>>16)])^ ROTL24(ftable[x[1]>>24]); y[3]=a->fkey[k+3]^ftable[MR_TOBYTE(x[3])]^ ROTL8(ftable[MR_TOBYTE(x[0]>>8)])^ ROTL16(ftable[MR_TOBYTE(x[1]>>16)])^ ROTL24(ftable[x[2]>>24]); #endif k+=4; t=x; x=y; y=t; /* swap pointers */ } /* Last Round */ y[0]=a->fkey[k]^(MR_WORD)fbsub[MR_TOBYTE(x[0])]^ ROTL8((MR_WORD)fbsub[MR_TOBYTE(x[1]>>8)])^ ROTL16((MR_WORD)fbsub[MR_TOBYTE(x[2]>>16)])^ ROTL24((MR_WORD)fbsub[x[3]>>24]); y[1]=a->fkey[k+1]^(MR_WORD)fbsub[MR_TOBYTE(x[1])]^ ROTL8((MR_WORD)fbsub[MR_TOBYTE(x[2]>>8)])^ ROTL16((MR_WORD)fbsub[MR_TOBYTE(x[3]>>16)])^ ROTL24((MR_WORD)fbsub[x[0]>>24]); y[2]=a->fkey[k+2]^(MR_WORD)fbsub[MR_TOBYTE(x[2])]^ ROTL8((MR_WORD)fbsub[MR_TOBYTE(x[3]>>8)])^ ROTL16((MR_WORD)fbsub[MR_TOBYTE(x[0]>>16)])^ ROTL24((MR_WORD)fbsub[x[1]>>24]); y[3]=a->fkey[k+3]^(MR_WORD)fbsub[MR_TOBYTE(x[3])]^ ROTL8((MR_WORD)fbsub[MR_TOBYTE(x[0]>>8)])^ ROTL16((MR_WORD)fbsub[MR_TOBYTE(x[1]>>16)])^ ROTL24((MR_WORD)fbsub[x[2]>>24]); for (i=j=0;i 12、解密 void aes_ecb_decrypt(aes *a,MR_BYTE *buff) { int i,j,k; MR_WORD p[4],q[4],*x,*y,*t; #ifdef AES_NI_SUPPORT __m128i ky,m = _mm_loadu_si128((__m128i *) buff); ky = _mm_loadu_si128((__m128i *) &a->rkey[0]); m = _mm_xor_si128 (m, ky); k=NB; for (i=1;iNr;i++) { ky=_mm_loadu_si128((__m128i *) &a->rkey[k]); m =_mm_aesdec_si128 (m, ky); k+=4; } ky=_mm_loadu_si128((__m128i *) &a->rkey[k]); m=_mm_aesdeclast_si128(m, ky); _mm_storeu_si128((__m128i *)buff, m); #else for (i=j=0;irkey[i]; } k=NB; x=p; y=q; /* State alternates between x and y */ for (i=1;iNr;i++) { /* Nr is number of rounds. May be odd. */ #ifndef MR_SMALL_AES y[0]=a->rkey[k]^rtable[MR_TOBYTE(x[0])]^ rtable1[MR_TOBYTE(x[3]>>8)]^ rtable2[MR_TOBYTE(x[2]>>16)]^ rtable3[x[1]>>24]; y[1]=a->rkey[k+1]^rtable[MR_TOBYTE(x[1])]^ rtable1[MR_TOBYTE(x[0]>>8)]^ rtable2[MR_TOBYTE(x[3]>>16)]^ rtable3[x[2]>>24]; y[2]=a->rkey[k+2]^rtable[MR_TOBYTE(x[2])]^ rtable1[MR_TOBYTE(x[1]>>8)]^ rtable2[MR_TOBYTE(x[0]>>16)]^ rtable3[x[3]>>24]; y[3]=a->rkey[k+3]^rtable[MR_TOBYTE(x[3])]^ rtable1[MR_TOBYTE(x[2]>>8)]^ rtable2[MR_TOBYTE(x[1]>>16)]^ rtable3[x[0]>>24]; #else y[0]=a->rkey[k]^rtable[MR_TOBYTE(x[0])]^ ROTL8(rtable[MR_TOBYTE(x[3]>>8)])^ ROTL16(rtable[MR_TOBYTE(x[2]>>16)])^ ROTL24(rtable[x[1]>>24]); y[1]=a->rkey[k+1]^rtable[MR_TOBYTE(x[1])]^ ROTL8(rtable[MR_TOBYTE(x[0]>>8)])^ ROTL16(rtable[MR_TOBYTE(x[3]>>16)])^ ROTL24(rtable[x[2]>>24]); y[2]=a->rkey[k+2]^rtable[MR_TOBYTE(x[2])]^ ROTL8(rtable[MR_TOBYTE(x[1]>>8)])^ ROTL16(rtable[MR_TOBYTE(x[0]>>16)])^ ROTL24(rtable[x[3]>>24]); y[3]=a->rkey[k+3]^rtable[MR_TOBYTE(x[3])]^ ROTL8(rtable[MR_TOBYTE(x[2]>>8)])^ ROTL16(rtable[MR_TOBYTE(x[1]>>16)])^ ROTL24(rtable[x[0]>>24]); #endif k+=4; t=x; x=y; y=t; /* swap pointers */ } /* Last Round */ y[0]=a->rkey[k]^(MR_WORD)rbsub[MR_TOBYTE(x[0])]^ ROTL8((MR_WORD)rbsub[MR_TOBYTE(x[3]>>8)])^ ROTL16((MR_WORD)rbsub[MR_TOBYTE(x[2]>>16)])^ ROTL24((MR_WORD)rbsub[x[1]>>24]); y[1]=a->rkey[k+1]^(MR_WORD)rbsub[MR_TOBYTE(x[1])]^ ROTL8((MR_WORD)rbsub[MR_TOBYTE(x[0]>>8)])^ ROTL16((MR_WORD)rbsub[MR_TOBYTE(x[3]>>16)])^ ROTL24((MR_WORD)rbsub[x[2]>>24]); y[2]=a->rkey[k+2]^(MR_WORD)rbsub[MR_TOBYTE(x[2])]^ ROTL8((MR_WORD)rbsub[MR_TOBYTE(x[1]>>8)])^ ROTL16((MR_WORD)rbsub[MR_TOBYTE(x[0]>>16)])^ ROTL24((MR_WORD)rbsub[x[3]>>24]); y[3]=a->rkey[k+3]^(MR_WORD)rbsub[MR_TOBYTE(x[3])]^ ROTL8((MR_WORD)rbsub[MR_TOBYTE(x[2]>>8)])^ ROTL16((MR_WORD)rbsub[MR_TOBYTE(x[1]>>16)])^ ROTL24((MR_WORD)rbsub[x[0]>>24]); for (i=j=0;i 13、加密和解密 mr_unsign32 aes_encrypt(aes* a,char *buff) { int j,bytes; char st[16]; mr_unsign32 fell_off; /* Supported Modes of Operation */ fell_off=0; switch (a->mode) { case MR_ECB: aes_ecb_encrypt(a,(MR_BYTE *)buff); return 0; case MR_CBC: for (j=0;jf[j]; aes_ecb_encrypt(a,(MR_BYTE *)buff); for (j=0;jf[j]=buff[j]; return 0; case MR_CFB1: case MR_CFB2: case MR_CFB4: bytes=a->mode-MR_CFB1+1; for (j=0;jf[j]; for (j=0;jf[j]; for (j=bytes;jf[j-bytes]=a->f[j]; aes_ecb_encrypt(a,(MR_BYTE *)st); for (j=0;jf[16-bytes+j]=buff[j]; } return fell_off; case MR_OFB1: case MR_OFB2: case MR_OFB4: case MR_OFB8: case MR_OFB16: bytes=a->mode-MR_OFB1+1; aes_ecb_encrypt(a,(MR_BYTE *)(a->f)); for (j=0;jf[j]; return 0; case MR_PCFB1: /* error propagating CFB */ case MR_PCFB2: case MR_PCFB4: bytes=a->mode-MR_PCFB1+1; for (j=0;jf[j]; for (j=0;jf[j]; for (j=bytes;jf[j-bytes]=a->f[j]; aes_ecb_encrypt(a,(MR_BYTE *)st); for (j=0;jf[16-bytes+j]=buff[j]^st[16-bytes+j]; } return fell_off; default: return 0; } } mr_unsign32 aes_decrypt(aes *a,char *buff) { int j,bytes; char st[16]; mr_unsign32 fell_off; /* Supported modes of operation */ fell_off=0; switch (a->mode) { case MR_ECB: aes_ecb_decrypt(a,(MR_BYTE *)buff); return 0; case MR_CBC: for (j=0;jf[j]; a->f[j]=buff[j]; } aes_ecb_decrypt(a,(MR_BYTE *)buff); for (j=0;jmode-MR_CFB1+1; for (j=0;jf[j]; for (j=0;jf[j]; for (j=bytes;jf[j-bytes]=a->f[j]; aes_ecb_encrypt(a,(MR_BYTE *)st); for (j=0;jf[16-bytes+j]=buff[j]; buff[j]^=st[j]; } return fell_off; case MR_OFB1: case MR_OFB2: case MR_OFB4: case MR_OFB8: case MR_OFB16: bytes=a->mode-MR_OFB1+1; aes_ecb_encrypt(a,(MR_BYTE *)(a->f)); for (j=0;jf[j]; return 0; case MR_PCFB1: /* error propagating CFB */ case MR_PCFB2: case MR_PCFB4: bytes=a->mode-MR_PCFB1+1; for (j=0;jf[j]; for (j=0;jf[j]; for (j=bytes;jf[j-bytes]=a->f[j]; aes_ecb_encrypt(a,(MR_BYTE *)st); for (j=0;jf[16-bytes+j]=buff[j]^st[16-bytes+j]; buff[j]^=st[j]; } return fell_off; default: return 0; } } 14、重置 aes 变量 /* 函数功能：重置 aes 变量 NB : 4 Nr : 10 12 14 */ void aes_end(aes *a) { /* clean up */ int i; // 将 aes 中的密钥数组清空 for (i=0;iNr+1);i++) a->fkey[i]=a->rkey[i]=0; // 清空16字节的数组 f for (i=0;if[i]=0; } 15、测试 int main() { int i,j; // 下标参数 int nk; // 控制密钥的字节数 aes a; // AES 类型变量 MR_BYTE y,x,m; // #define MR_BYTE unsigned char char key[32]; char block[16]; char iv[16]; // 初始化密钥数组 for (i=0;i mraes.c文件源码 /* * Implementation of the NIST Advanced Ecryption Standard * * Could/Should be speeded up by assembly patches in time critical loops in * aes_ecb_encrypt() and aes_ecb_decrypt() * * Note that the AES winner has not yet been determined! Nonetheless * we are jumping the gun a little and implementing one of the favourites * RIJNDAEL, partly because it is entirely patent-free. * * We were right! Rijndael is the AES from October 2nd 2000 */ #include #include \"miracl.h\" // 如果支持 INTEL AES-NI 系统的 intrinsics 函数，则定义 AES_NI_SUPPORT，intrinsics 函数包含在 wmmintrin.h 头文件，包含了MMX指令集的描述 /* Define this if INTEL AES-NI intrinsics are supported - for example with GCC compiler - use flag -maes */ /* #define AES_NI_SUPPORT */ #ifdef AES_NI_SUPPORT #include #endif // 在 mirdef.h 中，有对 mr_unsign32 的定义：#define mr_unsign32 unsigned int #define MR_WORD mr_unsign32 // 状态字的长度，即明文分组的字长，128/32=4，构造状态矩阵的列数 /* this is fixed */ #define NB 4 /* rotates x one bit to the left */ // 8位二进制数 x 的最高位调换到最低位 #define ROTL(x) (((x)>>7)|((x)>24)) #define ROTL16(x) (((x)>16)) #define ROTL24(x) (((x)>8)) // 在 miracl.h 中有对 MR_BYTE 的定义：#define MR_BYTE unsigned char // InCo 为4字节数组 static const MR_BYTE InCo[4]={0xB,0xD,0x9,0xE}; /* Inverse Coefficients */ static const MR_BYTE ptab[]= {1,3,5,15,17,51,85,255,26,46,114,150,161,248,19,53, 95,225,56,72,216,115,149,164,247,2,6,10,30,34,102,170, 229,52,92,228,55,89,235,38,106,190,217,112,144,171,230,49, 83,245,4,12,20,60,68,204,79,209,104,184,211,110,178,205, 76,212,103,169,224,59,77,215,98,166,241,8,24,40,120,136, 131,158,185,208,107,189,220,127,129,152,179,206,73,219,118,154, 181,196,87,249,16,48,80,240,11,29,39,105,187,214,97,163, 254,25,43,125,135,146,173,236,47,113,147,174,233,32,96,160, 251,22,58,78,210,109,183,194,93,231,50,86,250,21,63,65, 195,94,226,61,71,201,64,192,91,237,44,116,156,191,218,117, 159,186,213,100,172,239,42,126,130,157,188,223,122,142,137,128, 155,182,193,88,232,35,101,175,234,37,111,177,200,67,197,84, 252,31,33,99,165,244,7,9,27,45,119,153,176,203,70,202, 69,207,74,222,121,139,134,145,168,227,62,66,198,81,243,14, 18,54,90,238,41,123,141,140,143,138,133,148,167,242,13,23, 57,75,221,124,132,151,162,253,28,36,108,180,199,82,246,1}; static const MR_BYTE ltab[]= {0,255,25,1,50,2,26,198,75,199,27,104,51,238,223,3, 100,4,224,14,52,141,129,239,76,113,8,200,248,105,28,193, 125,194,29,181,249,185,39,106,77,228,166,114,154,201,9,120, 101,47,138,5,33,15,225,36,18,240,130,69,53,147,218,142, 150,143,219,189,54,208,206,148,19,92,210,241,64,70,131,56, 102,221,253,48,191,6,139,98,179,37,226,152,34,136,145,16, 126,110,72,195,163,182,30,66,58,107,40,84,250,133,61,186, 43,121,10,21,155,159,94,202,78,212,172,229,243,115,167,87, 175,88,168,80,244,234,214,116,79,174,233,213,231,230,173,232, 44,215,117,122,235,22,11,245,89,203,95,176,156,169,81,160, 127,12,246,111,23,196,73,236,216,67,31,45,164,118,123,183, 204,187,62,90,251,96,177,134,59,82,161,108,170,85,41,157, 151,178,135,144,97,190,220,252,188,149,207,205,55,63,91,209, 83,57,132,60,65,162,109,71,20,42,158,93,86,242,211,171, 68,17,146,217,35,32,46,137,180,124,184,38,119,153,227,165, 103,74,237,222,197,49,254,24,13,99,140,128,192,247,112,7}; static const MR_BYTE fbsub[]= {99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118, 202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192, 183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21, 4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117, 9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132, 83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207, 208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168, 81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210, 205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115, 96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219, 224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121, 231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8, 186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138, 112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158, 225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223, 140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22}; static const MR_BYTE rbsub[]= {82,9,106,213,48,54,165,56,191,64,163,158,129,243,215,251, 124,227,57,130,155,47,255,135,52,142,67,68,196,222,233,203, 84,123,148,50,166,194,35,61,238,76,149,11,66,250,195,78, 8,46,161,102,40,217,36,178,118,91,162,73,109,139,209,37, 114,248,246,100,134,104,152,22,212,164,92,204,93,101,182,146, 108,112,72,80,253,237,185,218,94,21,70,87,167,141,157,132, 144,216,171,0,140,188,211,10,247,228,88,5,184,179,69,6, 208,44,30,143,202,63,15,2,193,175,189,3,1,19,138,107, 58,145,17,65,79,103,220,234,151,242,207,206,240,180,230,115, 150,172,116,34,231,173,53,133,226,249,55,232,28,117,223,110, 71,241,26,113,29,41,197,137,111,183,98,14,170,24,190,27, 252,86,62,75,198,210,121,32,154,219,192,254,120,205,90,244, 31,221,168,51,136,7,199,49,177,18,16,89,39,128,236,95, 96,81,127,169,25,181,74,13,45,229,122,159,147,201,156,239, 160,224,59,77,174,42,245,176,200,235,187,60,131,83,153,97, 23,43,4,126,186,119,214,38,225,105,20,99,85,33,12,125}; static const MR_WORD rco[]= {1,2,4,8,16,32,64,128,27,54,108,216,171,77,154,47}; static const MR_WORD ftable[]= {0xa56363c6,0x847c7cf8,0x997777ee,0x8d7b7bf6,0xdf2f2ff,0xbd6b6bd6, 0xb16f6fde,0x54c5c591,0x50303060,0x3010102,0xa96767ce,0x7d2b2b56, 0x19fefee7,0x62d7d7b5,0xe6abab4d,0x9a7676ec,0x45caca8f,0x9d82821f, 0x40c9c989,0x877d7dfa,0x15fafaef,0xeb5959b2,0xc947478e,0xbf0f0fb, 0xecadad41,0x67d4d4b3,0xfda2a25f,0xeaafaf45,0xbf9c9c23,0xf7a4a453, 0x967272e4,0x5bc0c09b,0xc2b7b775,0x1cfdfde1,0xae93933d,0x6a26264c, 0x5a36366c,0x413f3f7e,0x2f7f7f5,0x4fcccc83,0x5c343468,0xf4a5a551, 0x34e5e5d1,0x8f1f1f9,0x937171e2,0x73d8d8ab,0x53313162,0x3f15152a, 0xc040408,0x52c7c795,0x65232346,0x5ec3c39d,0x28181830,0xa1969637, 0xf05050a,0xb59a9a2f,0x907070e,0x36121224,0x9b80801b,0x3de2e2df, 0x26ebebcd,0x6927274e,0xcdb2b27f,0x9f7575ea,0x1b090912,0x9e83831d, 0x742c2c58,0x2e1a1a34,0x2d1b1b36,0xb26e6edc,0xee5a5ab4,0xfba0a05b, 0xf65252a4,0x4d3b3b76,0x61d6d6b7,0xceb3b37d,0x7b292952,0x3ee3e3dd, 0x712f2f5e,0x97848413,0xf55353a6,0x68d1d1b9,0x0,0x2cededc1, 0x60202040,0x1ffcfce3,0xc8b1b179,0xed5b5bb6,0xbe6a6ad4,0x46cbcb8d, 0xd9bebe67,0x4b393972,0xde4a4a94,0xd44c4c98,0xe85858b0,0x4acfcf85, 0x6bd0d0bb,0x2aefefc5,0xe5aaaa4f,0x16fbfbed,0xc5434386,0xd74d4d9a, 0x55333366,0x94858511,0xcf45458a,0x10f9f9e9,0x6020204,0x817f7ffe, 0xf05050a0,0x443c3c78,0xba9f9f25,0xe3a8a84b,0xf35151a2,0xfea3a35d, 0xc0404080,0x8a8f8f05,0xad92923f,0xbc9d9d21,0x48383870,0x4f5f5f1, 0xdfbcbc63,0xc1b6b677,0x75dadaaf,0x63212142,0x30101020,0x1affffe5, 0xef3f3fd,0x6dd2d2bf,0x4ccdcd81,0x140c0c18,0x35131326,0x2fececc3, 0xe15f5fbe,0xa2979735,0xcc444488,0x3917172e,0x57c4c493,0xf2a7a755, 0x827e7efc,0x473d3d7a,0xac6464c8,0xe75d5dba,0x2b191932,0x957373e6, 0xa06060c0,0x98818119,0xd14f4f9e,0x7fdcdca3,0x66222244,0x7e2a2a54, 0xab90903b,0x8388880b,0xca46468c,0x29eeeec7,0xd3b8b86b,0x3c141428, 0x79dedea7,0xe25e5ebc,0x1d0b0b16,0x76dbdbad,0x3be0e0db,0x56323264, 0x4e3a3a74,0x1e0a0a14,0xdb494992,0xa06060c,0x6c242448,0xe45c5cb8, 0x5dc2c29f,0x6ed3d3bd,0xefacac43,0xa66262c4,0xa8919139,0xa4959531, 0x37e4e4d3,0x8b7979f2,0x32e7e7d5,0x43c8c88b,0x5937376e,0xb76d6dda, 0x8c8d8d01,0x64d5d5b1,0xd24e4e9c,0xe0a9a949,0xb46c6cd8,0xfa5656ac, 0x7f4f4f3,0x25eaeacf,0xaf6565ca,0x8e7a7af4,0xe9aeae47,0x18080810, 0xd5baba6f,0x887878f0,0x6f25254a,0x722e2e5c,0x241c1c38,0xf1a6a657, 0xc7b4b473,0x51c6c697,0x23e8e8cb,0x7cdddda1,0x9c7474e8,0x211f1f3e, 0xdd4b4b96,0xdcbdbd61,0x868b8b0d,0x858a8a0f,0x907070e0,0x423e3e7c, 0xc4b5b571,0xaa6666cc,0xd8484890,0x5030306,0x1f6f6f7,0x120e0e1c, 0xa36161c2,0x5f35356a,0xf95757ae,0xd0b9b969,0x91868617,0x58c1c199, 0x271d1d3a,0xb99e9e27,0x38e1e1d9,0x13f8f8eb,0xb398982b,0x33111122, 0xbb6969d2,0x70d9d9a9,0x898e8e07,0xa7949433,0xb69b9b2d,0x221e1e3c, 0x92878715,0x20e9e9c9,0x49cece87,0xff5555aa,0x78282850,0x7adfdfa5, 0x8f8c8c03,0xf8a1a159,0x80898909,0x170d0d1a,0xdabfbf65,0x31e6e6d7, 0xc6424284,0xb86868d0,0xc3414182,0xb0999929,0x772d2d5a,0x110f0f1e, 0xcbb0b07b,0xfc5454a8,0xd6bbbb6d,0x3a16162c}; static const MR_WORD rtable[]= {0x50a7f451,0x5365417e,0xc3a4171a,0x965e273a,0xcb6bab3b,0xf1459d1f, 0xab58faac,0x9303e34b,0x55fa3020,0xf66d76ad,0x9176cc88,0x254c02f5, 0xfcd7e54f,0xd7cb2ac5,0x80443526,0x8fa362b5,0x495ab1de,0x671bba25, 0x980eea45,0xe1c0fe5d,0x2752fc3,0x12f04c81,0xa397468d,0xc6f9d36b, 0xe75f8f03,0x959c9215,0xeb7a6dbf,0xda595295,0x2d83bed4,0xd3217458, 0x2969e049,0x44c8c98e,0x6a89c275,0x78798ef4,0x6b3e5899,0xdd71b927, 0xb64fe1be,0x17ad88f0,0x66ac20c9,0xb43ace7d,0x184adf63,0x82311ae5, 0x60335197,0x457f5362,0xe07764b1,0x84ae6bbb,0x1ca081fe,0x942b08f9, 0x58684870,0x19fd458f,0x876cde94,0xb7f87b52,0x23d373ab,0xe2024b72, 0x578f1fe3,0x2aab5566,0x728ebb2,0x3c2b52f,0x9a7bc586,0xa50837d3, 0xf2872830,0xb2a5bf23,0xba6a0302,0x5c8216ed,0x2b1ccf8a,0x92b479a7, 0xf0f207f3,0xa1e2694e,0xcdf4da65,0xd5be0506,0x1f6234d1,0x8afea6c4, 0x9d532e34,0xa055f3a2,0x32e18a05,0x75ebf6a4,0x39ec830b,0xaaef6040, 0x69f715e,0x51106ebd,0xf98a213e,0x3d06dd96,0xae053edd,0x46bde64d, 0xb58d5491,0x55dc471,0x6fd40604,0xff155060,0x24fb9819,0x97e9bdd6, 0xcc434089,0x779ed967,0xbd42e8b0,0x888b8907,0x385b19e7,0xdbeec879, 0x470a7ca1,0xe90f427c,0xc91e84f8,0x0,0x83868009,0x48ed2b32, 0xac70111e,0x4e725a6c,0xfbff0efd,0x5638850f,0x1ed5ae3d,0x27392d36, 0x64d90f0a,0x21a65c68,0xd1545b9b,0x3a2e3624,0xb1670a0c,0xfe75793, 0xd296eeb4,0x9e919b1b,0x4fc5c080,0xa220dc61,0x694b775a,0x161a121c, 0xaba93e2,0xe52aa0c0,0x43e0223c,0x1d171b12,0xb0d090e,0xadc78bf2, 0xb9a8b62d,0xc8a91e14,0x8519f157,0x4c0775af,0xbbdd99ee,0xfd607fa3, 0x9f2601f7,0xbcf5725c,0xc53b6644,0x347efb5b,0x7629438b,0xdcc623cb, 0x68fcedb6,0x63f1e4b8,0xcadc31d7,0x10856342,0x40229713,0x2011c684, 0x7d244a85,0xf83dbbd2,0x1132f9ae,0x6da129c7,0x4b2f9e1d,0xf330b2dc, 0xec52860d,0xd0e3c177,0x6c16b32b,0x99b970a9,0xfa489411,0x2264e947, 0xc48cfca8,0x1a3ff0a0,0xd82c7d56,0xef903322,0xc74e4987,0xc1d138d9, 0xfea2ca8c,0x360bd498,0xcf81f5a6,0x28de7aa5,0x268eb7da,0xa4bfad3f, 0xe49d3a2c,0xd927850,0x9bcc5f6a,0x62467e54,0xc2138df6,0xe8b8d890, 0x5ef7392e,0xf5afc382,0xbe805d9f,0x7c93d069,0xa92dd56f,0xb31225cf, 0x3b99acc8,0xa77d1810,0x6e639ce8,0x7bbb3bdb,0x97826cd,0xf418596e, 0x1b79aec,0xa89a4f83,0x656e95e6,0x7ee6ffaa,0x8cfbc21,0xe6e815ef, 0xd99be7ba,0xce366f4a,0xd4099fea,0xd67cb029,0xafb2a431,0x31233f2a, 0x3094a5c6,0xc066a235,0x37bc4e74,0xa6ca82fc,0xb0d090e0,0x15d8a733, 0x4a9804f1,0xf7daec41,0xe50cd7f,0x2ff69117,0x8dd64d76,0x4db0ef43, 0x544daacc,0xdf0496e4,0xe3b5d19e,0x1b886a4c,0xb81f2cc1,0x7f516546, 0x4ea5e9d,0x5d358c01,0x737487fa,0x2e410bfb,0x5a1d67b3,0x52d2db92, 0x335610e9,0x1347d66d,0x8c61d79a,0x7a0ca137,0x8e14f859,0x893c13eb, 0xee27a9ce,0x35c961b7,0xede51ce1,0x3cb1477a,0x59dfd29c,0x3f73f255, 0x79ce1418,0xbf37c773,0xeacdf753,0x5baafd5f,0x146f3ddf,0x86db4478, 0x81f3afca,0x3ec468b9,0x2c342438,0x5f40a3c2,0x72c31d16,0xc25e2bc, 0x8b493c28,0x41950dff,0x7101a839,0xdeb30c08,0x9ce4b4d8,0x90c15664, 0x6184cb7b,0x70b632d5,0x745c6c48,0x4257b8d0}; // 在什么情况下使用 MR_SMALL_AES ？？？ #ifndef MR_SMALL_AES static const MR_WORD ftable1[]= {0x6363c6a5,0x7c7cf884,0x7777ee99,0x7b7bf68d,0xf2f2ff0d,0x6b6bd6bd, 0x6f6fdeb1,0xc5c59154,0x30306050,0x1010203,0x6767cea9,0x2b2b567d, 0xfefee719,0xd7d7b562,0xabab4de6,0x7676ec9a,0xcaca8f45,0x82821f9d, 0xc9c98940,0x7d7dfa87,0xfafaef15,0x5959b2eb,0x47478ec9,0xf0f0fb0b, 0xadad41ec,0xd4d4b367,0xa2a25ffd,0xafaf45ea,0x9c9c23bf,0xa4a453f7, 0x7272e496,0xc0c09b5b,0xb7b775c2,0xfdfde11c,0x93933dae,0x26264c6a, 0x36366c5a,0x3f3f7e41,0xf7f7f502,0xcccc834f,0x3434685c,0xa5a551f4, 0xe5e5d134,0xf1f1f908,0x7171e293,0xd8d8ab73,0x31316253,0x15152a3f, 0x404080c,0xc7c79552,0x23234665,0xc3c39d5e,0x18183028,0x969637a1, 0x5050a0f,0x9a9a2fb5,0x7070e09,0x12122436,0x80801b9b,0xe2e2df3d, 0xebebcd26,0x27274e69,0xb2b27fcd,0x7575ea9f,0x909121b,0x83831d9e, 0x2c2c5874,0x1a1a342e,0x1b1b362d,0x6e6edcb2,0x5a5ab4ee,0xa0a05bfb, 0x5252a4f6,0x3b3b764d,0xd6d6b761,0xb3b37dce,0x2929527b,0xe3e3dd3e, 0x2f2f5e71,0x84841397,0x5353a6f5,0xd1d1b968,0x0,0xededc12c, 0x20204060,0xfcfce31f,0xb1b179c8,0x5b5bb6ed,0x6a6ad4be,0xcbcb8d46, 0xbebe67d9,0x3939724b,0x4a4a94de,0x4c4c98d4,0x5858b0e8,0xcfcf854a, 0xd0d0bb6b,0xefefc52a,0xaaaa4fe5,0xfbfbed16,0x434386c5,0x4d4d9ad7, 0x33336655,0x85851194,0x45458acf,0xf9f9e910,0x2020406,0x7f7ffe81, 0x5050a0f0,0x3c3c7844,0x9f9f25ba,0xa8a84be3,0x5151a2f3,0xa3a35dfe, 0x404080c0,0x8f8f058a,0x92923fad,0x9d9d21bc,0x38387048,0xf5f5f104, 0xbcbc63df,0xb6b677c1,0xdadaaf75,0x21214263,0x10102030,0xffffe51a, 0xf3f3fd0e,0xd2d2bf6d,0xcdcd814c,0xc0c1814,0x13132635,0xececc32f, 0x5f5fbee1,0x979735a2,0x444488cc,0x17172e39,0xc4c49357,0xa7a755f2, 0x7e7efc82,0x3d3d7a47,0x6464c8ac,0x5d5dbae7,0x1919322b,0x7373e695, 0x6060c0a0,0x81811998,0x4f4f9ed1,0xdcdca37f,0x22224466,0x2a2a547e, 0x90903bab,0x88880b83,0x46468cca,0xeeeec729,0xb8b86bd3,0x1414283c, 0xdedea779,0x5e5ebce2,0xb0b161d,0xdbdbad76,0xe0e0db3b,0x32326456, 0x3a3a744e,0xa0a141e,0x494992db,0x6060c0a,0x2424486c,0x5c5cb8e4, 0xc2c29f5d,0xd3d3bd6e,0xacac43ef,0x6262c4a6,0x919139a8,0x959531a4, 0xe4e4d337,0x7979f28b,0xe7e7d532,0xc8c88b43,0x37376e59,0x6d6ddab7, 0x8d8d018c,0xd5d5b164,0x4e4e9cd2,0xa9a949e0,0x6c6cd8b4,0x5656acfa, 0xf4f4f307,0xeaeacf25,0x6565caaf,0x7a7af48e,0xaeae47e9,0x8081018, 0xbaba6fd5,0x7878f088,0x25254a6f,0x2e2e5c72,0x1c1c3824,0xa6a657f1, 0xb4b473c7,0xc6c69751,0xe8e8cb23,0xdddda17c,0x7474e89c,0x1f1f3e21, 0x4b4b96dd,0xbdbd61dc,0x8b8b0d86,0x8a8a0f85,0x7070e090,0x3e3e7c42, 0xb5b571c4,0x6666ccaa,0x484890d8,0x3030605,0xf6f6f701,0xe0e1c12, 0x6161c2a3,0x35356a5f,0x5757aef9,0xb9b969d0,0x86861791,0xc1c19958, 0x1d1d3a27,0x9e9e27b9,0xe1e1d938,0xf8f8eb13,0x98982bb3,0x11112233, 0x6969d2bb,0xd9d9a970,0x8e8e0789,0x949433a7,0x9b9b2db6,0x1e1e3c22, 0x87871592,0xe9e9c920,0xcece8749,0x5555aaff,0x28285078,0xdfdfa57a, 0x8c8c038f,0xa1a159f8,0x89890980,0xd0d1a17,0xbfbf65da,0xe6e6d731, 0x424284c6,0x6868d0b8,0x414182c3,0x999929b0,0x2d2d5a77,0xf0f1e11, 0xb0b07bcb,0x5454a8fc,0xbbbb6dd6,0x16162c3a}; static const MR_WORD rtable1[]= {0xa7f45150,0x65417e53,0xa4171ac3,0x5e273a96,0x6bab3bcb,0x459d1ff1, 0x58faacab,0x3e34b93,0xfa302055,0x6d76adf6,0x76cc8891,0x4c02f525, 0xd7e54ffc,0xcb2ac5d7,0x44352680,0xa362b58f,0x5ab1de49,0x1bba2567, 0xeea4598,0xc0fe5de1,0x752fc302,0xf04c8112,0x97468da3,0xf9d36bc6, 0x5f8f03e7,0x9c921595,0x7a6dbfeb,0x595295da,0x83bed42d,0x217458d3, 0x69e04929,0xc8c98e44,0x89c2756a,0x798ef478,0x3e58996b,0x71b927dd, 0x4fe1beb6,0xad88f017,0xac20c966,0x3ace7db4,0x4adf6318,0x311ae582, 0x33519760,0x7f536245,0x7764b1e0,0xae6bbb84,0xa081fe1c,0x2b08f994, 0x68487058,0xfd458f19,0x6cde9487,0xf87b52b7,0xd373ab23,0x24b72e2, 0x8f1fe357,0xab55662a,0x28ebb207,0xc2b52f03,0x7bc5869a,0x837d3a5, 0x872830f2,0xa5bf23b2,0x6a0302ba,0x8216ed5c,0x1ccf8a2b,0xb479a792, 0xf207f3f0,0xe2694ea1,0xf4da65cd,0xbe0506d5,0x6234d11f,0xfea6c48a, 0x532e349d,0x55f3a2a0,0xe18a0532,0xebf6a475,0xec830b39,0xef6040aa, 0x9f715e06,0x106ebd51,0x8a213ef9,0x6dd963d,0x53eddae,0xbde64d46, 0x8d5491b5,0x5dc47105,0xd406046f,0x155060ff,0xfb981924,0xe9bdd697, 0x434089cc,0x9ed96777,0x42e8b0bd,0x8b890788,0x5b19e738,0xeec879db, 0xa7ca147,0xf427ce9,0x1e84f8c9,0x0,0x86800983,0xed2b3248, 0x70111eac,0x725a6c4e,0xff0efdfb,0x38850f56,0xd5ae3d1e,0x392d3627, 0xd90f0a64,0xa65c6821,0x545b9bd1,0x2e36243a,0x670a0cb1,0xe757930f, 0x96eeb4d2,0x919b1b9e,0xc5c0804f,0x20dc61a2,0x4b775a69,0x1a121c16, 0xba93e20a,0x2aa0c0e5,0xe0223c43,0x171b121d,0xd090e0b,0xc78bf2ad, 0xa8b62db9,0xa91e14c8,0x19f15785,0x775af4c,0xdd99eebb,0x607fa3fd, 0x2601f79f,0xf5725cbc,0x3b6644c5,0x7efb5b34,0x29438b76,0xc623cbdc, 0xfcedb668,0xf1e4b863,0xdc31d7ca,0x85634210,0x22971340,0x11c68420, 0x244a857d,0x3dbbd2f8,0x32f9ae11,0xa129c76d,0x2f9e1d4b,0x30b2dcf3, 0x52860dec,0xe3c177d0,0x16b32b6c,0xb970a999,0x489411fa,0x64e94722, 0x8cfca8c4,0x3ff0a01a,0x2c7d56d8,0x903322ef,0x4e4987c7,0xd138d9c1, 0xa2ca8cfe,0xbd49836,0x81f5a6cf,0xde7aa528,0x8eb7da26,0xbfad3fa4, 0x9d3a2ce4,0x9278500d,0xcc5f6a9b,0x467e5462,0x138df6c2,0xb8d890e8, 0xf7392e5e,0xafc382f5,0x805d9fbe,0x93d0697c,0x2dd56fa9,0x1225cfb3, 0x99acc83b,0x7d1810a7,0x639ce86e,0xbb3bdb7b,0x7826cd09,0x18596ef4, 0xb79aec01,0x9a4f83a8,0x6e95e665,0xe6ffaa7e,0xcfbc2108,0xe815efe6, 0x9be7bad9,0x366f4ace,0x99fead4,0x7cb029d6,0xb2a431af,0x233f2a31, 0x94a5c630,0x66a235c0,0xbc4e7437,0xca82fca6,0xd090e0b0,0xd8a73315, 0x9804f14a,0xdaec41f7,0x50cd7f0e,0xf691172f,0xd64d768d,0xb0ef434d, 0x4daacc54,0x496e4df,0xb5d19ee3,0x886a4c1b,0x1f2cc1b8,0x5165467f, 0xea5e9d04,0x358c015d,0x7487fa73,0x410bfb2e,0x1d67b35a,0xd2db9252, 0x5610e933,0x47d66d13,0x61d79a8c,0xca1377a,0x14f8598e,0x3c13eb89, 0x27a9ceee,0xc961b735,0xe51ce1ed,0xb1477a3c,0xdfd29c59,0x73f2553f, 0xce141879,0x37c773bf,0xcdf753ea,0xaafd5f5b,0x6f3ddf14,0xdb447886, 0xf3afca81,0xc468b93e,0x3424382c,0x40a3c25f,0xc31d1672,0x25e2bc0c, 0x493c288b,0x950dff41,0x1a83971,0xb30c08de,0xe4b4d89c,0xc1566490, 0x84cb7b61,0xb632d570,0x5c6c4874,0x57b8d042}; static const MR_WORD ftable2[]= {0x63c6a563,0x7cf8847c,0x77ee9977,0x7bf68d7b,0xf2ff0df2,0x6bd6bd6b, 0x6fdeb16f,0xc59154c5,0x30605030,0x1020301,0x67cea967,0x2b567d2b, 0xfee719fe,0xd7b562d7,0xab4de6ab,0x76ec9a76,0xca8f45ca,0x821f9d82, 0xc98940c9,0x7dfa877d,0xfaef15fa,0x59b2eb59,0x478ec947,0xf0fb0bf0, 0xad41ecad,0xd4b367d4,0xa25ffda2,0xaf45eaaf,0x9c23bf9c,0xa453f7a4, 0x72e49672,0xc09b5bc0,0xb775c2b7,0xfde11cfd,0x933dae93,0x264c6a26, 0x366c5a36,0x3f7e413f,0xf7f502f7,0xcc834fcc,0x34685c34,0xa551f4a5, 0xe5d134e5,0xf1f908f1,0x71e29371,0xd8ab73d8,0x31625331,0x152a3f15, 0x4080c04,0xc79552c7,0x23466523,0xc39d5ec3,0x18302818,0x9637a196, 0x50a0f05,0x9a2fb59a,0x70e0907,0x12243612,0x801b9b80,0xe2df3de2, 0xebcd26eb,0x274e6927,0xb27fcdb2,0x75ea9f75,0x9121b09,0x831d9e83, 0x2c58742c,0x1a342e1a,0x1b362d1b,0x6edcb26e,0x5ab4ee5a,0xa05bfba0, 0x52a4f652,0x3b764d3b,0xd6b761d6,0xb37dceb3,0x29527b29,0xe3dd3ee3, 0x2f5e712f,0x84139784,0x53a6f553,0xd1b968d1,0x0,0xedc12ced, 0x20406020,0xfce31ffc,0xb179c8b1,0x5bb6ed5b,0x6ad4be6a,0xcb8d46cb, 0xbe67d9be,0x39724b39,0x4a94de4a,0x4c98d44c,0x58b0e858,0xcf854acf, 0xd0bb6bd0,0xefc52aef,0xaa4fe5aa,0xfbed16fb,0x4386c543,0x4d9ad74d, 0x33665533,0x85119485,0x458acf45,0xf9e910f9,0x2040602,0x7ffe817f, 0x50a0f050,0x3c78443c,0x9f25ba9f,0xa84be3a8,0x51a2f351,0xa35dfea3, 0x4080c040,0x8f058a8f,0x923fad92,0x9d21bc9d,0x38704838,0xf5f104f5, 0xbc63dfbc,0xb677c1b6,0xdaaf75da,0x21426321,0x10203010,0xffe51aff, 0xf3fd0ef3,0xd2bf6dd2,0xcd814ccd,0xc18140c,0x13263513,0xecc32fec, 0x5fbee15f,0x9735a297,0x4488cc44,0x172e3917,0xc49357c4,0xa755f2a7, 0x7efc827e,0x3d7a473d,0x64c8ac64,0x5dbae75d,0x19322b19,0x73e69573, 0x60c0a060,0x81199881,0x4f9ed14f,0xdca37fdc,0x22446622,0x2a547e2a, 0x903bab90,0x880b8388,0x468cca46,0xeec729ee,0xb86bd3b8,0x14283c14, 0xdea779de,0x5ebce25e,0xb161d0b,0xdbad76db,0xe0db3be0,0x32645632, 0x3a744e3a,0xa141e0a,0x4992db49,0x60c0a06,0x24486c24,0x5cb8e45c, 0xc29f5dc2,0xd3bd6ed3,0xac43efac,0x62c4a662,0x9139a891,0x9531a495, 0xe4d337e4,0x79f28b79,0xe7d532e7,0xc88b43c8,0x376e5937,0x6ddab76d, 0x8d018c8d,0xd5b164d5,0x4e9cd24e,0xa949e0a9,0x6cd8b46c,0x56acfa56, 0xf4f307f4,0xeacf25ea,0x65caaf65,0x7af48e7a,0xae47e9ae,0x8101808, 0xba6fd5ba,0x78f08878,0x254a6f25,0x2e5c722e,0x1c38241c,0xa657f1a6, 0xb473c7b4,0xc69751c6,0xe8cb23e8,0xdda17cdd,0x74e89c74,0x1f3e211f, 0x4b96dd4b,0xbd61dcbd,0x8b0d868b,0x8a0f858a,0x70e09070,0x3e7c423e, 0xb571c4b5,0x66ccaa66,0x4890d848,0x3060503,0xf6f701f6,0xe1c120e, 0x61c2a361,0x356a5f35,0x57aef957,0xb969d0b9,0x86179186,0xc19958c1, 0x1d3a271d,0x9e27b99e,0xe1d938e1,0xf8eb13f8,0x982bb398,0x11223311, 0x69d2bb69,0xd9a970d9,0x8e07898e,0x9433a794,0x9b2db69b,0x1e3c221e, 0x87159287,0xe9c920e9,0xce8749ce,0x55aaff55,0x28507828,0xdfa57adf, 0x8c038f8c,0xa159f8a1,0x89098089,0xd1a170d,0xbf65dabf,0xe6d731e6, 0x4284c642,0x68d0b868,0x4182c341,0x9929b099,0x2d5a772d,0xf1e110f, 0xb07bcbb0,0x54a8fc54,0xbb6dd6bb,0x162c3a16}; static const MR_WORD rtable2[]= {0xf45150a7,0x417e5365,0x171ac3a4,0x273a965e,0xab3bcb6b,0x9d1ff145, 0xfaacab58,0xe34b9303,0x302055fa,0x76adf66d,0xcc889176,0x2f5254c, 0xe54ffcd7,0x2ac5d7cb,0x35268044,0x62b58fa3,0xb1de495a,0xba25671b, 0xea45980e,0xfe5de1c0,0x2fc30275,0x4c8112f0,0x468da397,0xd36bc6f9, 0x8f03e75f,0x9215959c,0x6dbfeb7a,0x5295da59,0xbed42d83,0x7458d321, 0xe0492969,0xc98e44c8,0xc2756a89,0x8ef47879,0x58996b3e,0xb927dd71, 0xe1beb64f,0x88f017ad,0x20c966ac,0xce7db43a,0xdf63184a,0x1ae58231, 0x51976033,0x5362457f,0x64b1e077,0x6bbb84ae,0x81fe1ca0,0x8f9942b, 0x48705868,0x458f19fd,0xde94876c,0x7b52b7f8,0x73ab23d3,0x4b72e202, 0x1fe3578f,0x55662aab,0xebb20728,0xb52f03c2,0xc5869a7b,0x37d3a508, 0x2830f287,0xbf23b2a5,0x302ba6a,0x16ed5c82,0xcf8a2b1c,0x79a792b4, 0x7f3f0f2,0x694ea1e2,0xda65cdf4,0x506d5be,0x34d11f62,0xa6c48afe, 0x2e349d53,0xf3a2a055,0x8a0532e1,0xf6a475eb,0x830b39ec,0x6040aaef, 0x715e069f,0x6ebd5110,0x213ef98a,0xdd963d06,0x3eddae05,0xe64d46bd, 0x5491b58d,0xc471055d,0x6046fd4,0x5060ff15,0x981924fb,0xbdd697e9, 0x4089cc43,0xd967779e,0xe8b0bd42,0x8907888b,0x19e7385b,0xc879dbee, 0x7ca1470a,0x427ce90f,0x84f8c91e,0x0,0x80098386,0x2b3248ed, 0x111eac70,0x5a6c4e72,0xefdfbff,0x850f5638,0xae3d1ed5,0x2d362739, 0xf0a64d9,0x5c6821a6,0x5b9bd154,0x36243a2e,0xa0cb167,0x57930fe7, 0xeeb4d296,0x9b1b9e91,0xc0804fc5,0xdc61a220,0x775a694b,0x121c161a, 0x93e20aba,0xa0c0e52a,0x223c43e0,0x1b121d17,0x90e0b0d,0x8bf2adc7, 0xb62db9a8,0x1e14c8a9,0xf1578519,0x75af4c07,0x99eebbdd,0x7fa3fd60, 0x1f79f26,0x725cbcf5,0x6644c53b,0xfb5b347e,0x438b7629,0x23cbdcc6, 0xedb668fc,0xe4b863f1,0x31d7cadc,0x63421085,0x97134022,0xc6842011, 0x4a857d24,0xbbd2f83d,0xf9ae1132,0x29c76da1,0x9e1d4b2f,0xb2dcf330, 0x860dec52,0xc177d0e3,0xb32b6c16,0x70a999b9,0x9411fa48,0xe9472264, 0xfca8c48c,0xf0a01a3f,0x7d56d82c,0x3322ef90,0x4987c74e,0x38d9c1d1, 0xca8cfea2,0xd498360b,0xf5a6cf81,0x7aa528de,0xb7da268e,0xad3fa4bf, 0x3a2ce49d,0x78500d92,0x5f6a9bcc,0x7e546246,0x8df6c213,0xd890e8b8, 0x392e5ef7,0xc382f5af,0x5d9fbe80,0xd0697c93,0xd56fa92d,0x25cfb312, 0xacc83b99,0x1810a77d,0x9ce86e63,0x3bdb7bbb,0x26cd0978,0x596ef418, 0x9aec01b7,0x4f83a89a,0x95e6656e,0xffaa7ee6,0xbc2108cf,0x15efe6e8, 0xe7bad99b,0x6f4ace36,0x9fead409,0xb029d67c,0xa431afb2,0x3f2a3123, 0xa5c63094,0xa235c066,0x4e7437bc,0x82fca6ca,0x90e0b0d0,0xa73315d8, 0x4f14a98,0xec41f7da,0xcd7f0e50,0x91172ff6,0x4d768dd6,0xef434db0, 0xaacc544d,0x96e4df04,0xd19ee3b5,0x6a4c1b88,0x2cc1b81f,0x65467f51, 0x5e9d04ea,0x8c015d35,0x87fa7374,0xbfb2e41,0x67b35a1d,0xdb9252d2, 0x10e93356,0xd66d1347,0xd79a8c61,0xa1377a0c,0xf8598e14,0x13eb893c, 0xa9ceee27,0x61b735c9,0x1ce1ede5,0x477a3cb1,0xd29c59df,0xf2553f73, 0x141879ce,0xc773bf37,0xf753eacd,0xfd5f5baa,0x3ddf146f,0x447886db, 0xafca81f3,0x68b93ec4,0x24382c34,0xa3c25f40,0x1d1672c3,0xe2bc0c25, 0x3c288b49,0xdff4195,0xa8397101,0xc08deb3,0xb4d89ce4,0x566490c1, 0xcb7b6184,0x32d570b6,0x6c48745c,0xb8d04257}; static const MR_WORD ftable3[]= {0xc6a56363,0xf8847c7c,0xee997777,0xf68d7b7b,0xff0df2f2,0xd6bd6b6b, 0xdeb16f6f,0x9154c5c5,0x60503030,0x2030101,0xcea96767,0x567d2b2b, 0xe719fefe,0xb562d7d7,0x4de6abab,0xec9a7676,0x8f45caca,0x1f9d8282, 0x8940c9c9,0xfa877d7d,0xef15fafa,0xb2eb5959,0x8ec94747,0xfb0bf0f0, 0x41ecadad,0xb367d4d4,0x5ffda2a2,0x45eaafaf,0x23bf9c9c,0x53f7a4a4, 0xe4967272,0x9b5bc0c0,0x75c2b7b7,0xe11cfdfd,0x3dae9393,0x4c6a2626, 0x6c5a3636,0x7e413f3f,0xf502f7f7,0x834fcccc,0x685c3434,0x51f4a5a5, 0xd134e5e5,0xf908f1f1,0xe2937171,0xab73d8d8,0x62533131,0x2a3f1515, 0x80c0404,0x9552c7c7,0x46652323,0x9d5ec3c3,0x30281818,0x37a19696, 0xa0f0505,0x2fb59a9a,0xe090707,0x24361212,0x1b9b8080,0xdf3de2e2, 0xcd26ebeb,0x4e692727,0x7fcdb2b2,0xea9f7575,0x121b0909,0x1d9e8383, 0x58742c2c,0x342e1a1a,0x362d1b1b,0xdcb26e6e,0xb4ee5a5a,0x5bfba0a0, 0xa4f65252,0x764d3b3b,0xb761d6d6,0x7dceb3b3,0x527b2929,0xdd3ee3e3, 0x5e712f2f,0x13978484,0xa6f55353,0xb968d1d1,0x0,0xc12ceded, 0x40602020,0xe31ffcfc,0x79c8b1b1,0xb6ed5b5b,0xd4be6a6a,0x8d46cbcb, 0x67d9bebe,0x724b3939,0x94de4a4a,0x98d44c4c,0xb0e85858,0x854acfcf, 0xbb6bd0d0,0xc52aefef,0x4fe5aaaa,0xed16fbfb,0x86c54343,0x9ad74d4d, 0x66553333,0x11948585,0x8acf4545,0xe910f9f9,0x4060202,0xfe817f7f, 0xa0f05050,0x78443c3c,0x25ba9f9f,0x4be3a8a8,0xa2f35151,0x5dfea3a3, 0x80c04040,0x58a8f8f,0x3fad9292,0x21bc9d9d,0x70483838,0xf104f5f5, 0x63dfbcbc,0x77c1b6b6,0xaf75dada,0x42632121,0x20301010,0xe51affff, 0xfd0ef3f3,0xbf6dd2d2,0x814ccdcd,0x18140c0c,0x26351313,0xc32fecec, 0xbee15f5f,0x35a29797,0x88cc4444,0x2e391717,0x9357c4c4,0x55f2a7a7, 0xfc827e7e,0x7a473d3d,0xc8ac6464,0xbae75d5d,0x322b1919,0xe6957373, 0xc0a06060,0x19988181,0x9ed14f4f,0xa37fdcdc,0x44662222,0x547e2a2a, 0x3bab9090,0xb838888,0x8cca4646,0xc729eeee,0x6bd3b8b8,0x283c1414, 0xa779dede,0xbce25e5e,0x161d0b0b,0xad76dbdb,0xdb3be0e0,0x64563232, 0x744e3a3a,0x141e0a0a,0x92db4949,0xc0a0606,0x486c2424,0xb8e45c5c, 0x9f5dc2c2,0xbd6ed3d3,0x43efacac,0xc4a66262,0x39a89191,0x31a49595, 0xd337e4e4,0xf28b7979,0xd532e7e7,0x8b43c8c8,0x6e593737,0xdab76d6d, 0x18c8d8d,0xb164d5d5,0x9cd24e4e,0x49e0a9a9,0xd8b46c6c,0xacfa5656, 0xf307f4f4,0xcf25eaea,0xcaaf6565,0xf48e7a7a,0x47e9aeae,0x10180808, 0x6fd5baba,0xf0887878,0x4a6f2525,0x5c722e2e,0x38241c1c,0x57f1a6a6, 0x73c7b4b4,0x9751c6c6,0xcb23e8e8,0xa17cdddd,0xe89c7474,0x3e211f1f, 0x96dd4b4b,0x61dcbdbd,0xd868b8b,0xf858a8a,0xe0907070,0x7c423e3e, 0x71c4b5b5,0xccaa6666,0x90d84848,0x6050303,0xf701f6f6,0x1c120e0e, 0xc2a36161,0x6a5f3535,0xaef95757,0x69d0b9b9,0x17918686,0x9958c1c1, 0x3a271d1d,0x27b99e9e,0xd938e1e1,0xeb13f8f8,0x2bb39898,0x22331111, 0xd2bb6969,0xa970d9d9,0x7898e8e,0x33a79494,0x2db69b9b,0x3c221e1e, 0x15928787,0xc920e9e9,0x8749cece,0xaaff5555,0x50782828,0xa57adfdf, 0x38f8c8c,0x59f8a1a1,0x9808989,0x1a170d0d,0x65dabfbf,0xd731e6e6, 0x84c64242,0xd0b86868,0x82c34141,0x29b09999,0x5a772d2d,0x1e110f0f, 0x7bcbb0b0,0xa8fc5454,0x6dd6bbbb,0x2c3a1616}; static const MR_WORD rtable3[]= {0x5150a7f4,0x7e536541,0x1ac3a417,0x3a965e27,0x3bcb6bab,0x1ff1459d, 0xacab58fa,0x4b9303e3,0x2055fa30,0xadf66d76,0x889176cc,0xf5254c02, 0x4ffcd7e5,0xc5d7cb2a,0x26804435,0xb58fa362,0xde495ab1,0x25671bba, 0x45980eea,0x5de1c0fe,0xc302752f,0x8112f04c,0x8da39746,0x6bc6f9d3, 0x3e75f8f,0x15959c92,0xbfeb7a6d,0x95da5952,0xd42d83be,0x58d32174, 0x492969e0,0x8e44c8c9,0x756a89c2,0xf478798e,0x996b3e58,0x27dd71b9, 0xbeb64fe1,0xf017ad88,0xc966ac20,0x7db43ace,0x63184adf,0xe582311a, 0x97603351,0x62457f53,0xb1e07764,0xbb84ae6b,0xfe1ca081,0xf9942b08, 0x70586848,0x8f19fd45,0x94876cde,0x52b7f87b,0xab23d373,0x72e2024b, 0xe3578f1f,0x662aab55,0xb20728eb,0x2f03c2b5,0x869a7bc5,0xd3a50837, 0x30f28728,0x23b2a5bf,0x2ba6a03,0xed5c8216,0x8a2b1ccf,0xa792b479, 0xf3f0f207,0x4ea1e269,0x65cdf4da,0x6d5be05,0xd11f6234,0xc48afea6, 0x349d532e,0xa2a055f3,0x532e18a,0xa475ebf6,0xb39ec83,0x40aaef60, 0x5e069f71,0xbd51106e,0x3ef98a21,0x963d06dd,0xddae053e,0x4d46bde6, 0x91b58d54,0x71055dc4,0x46fd406,0x60ff1550,0x1924fb98,0xd697e9bd, 0x89cc4340,0x67779ed9,0xb0bd42e8,0x7888b89,0xe7385b19,0x79dbeec8, 0xa1470a7c,0x7ce90f42,0xf8c91e84,0x0,0x9838680,0x3248ed2b, 0x1eac7011,0x6c4e725a,0xfdfbff0e,0xf563885,0x3d1ed5ae,0x3627392d, 0xa64d90f,0x6821a65c,0x9bd1545b,0x243a2e36,0xcb1670a,0x930fe757, 0xb4d296ee,0x1b9e919b,0x804fc5c0,0x61a220dc,0x5a694b77,0x1c161a12, 0xe20aba93,0xc0e52aa0,0x3c43e022,0x121d171b,0xe0b0d09,0xf2adc78b, 0x2db9a8b6,0x14c8a91e,0x578519f1,0xaf4c0775,0xeebbdd99,0xa3fd607f, 0xf79f2601,0x5cbcf572,0x44c53b66,0x5b347efb,0x8b762943,0xcbdcc623, 0xb668fced,0xb863f1e4,0xd7cadc31,0x42108563,0x13402297,0x842011c6, 0x857d244a,0xd2f83dbb,0xae1132f9,0xc76da129,0x1d4b2f9e,0xdcf330b2, 0xdec5286,0x77d0e3c1,0x2b6c16b3,0xa999b970,0x11fa4894,0x472264e9, 0xa8c48cfc,0xa01a3ff0,0x56d82c7d,0x22ef9033,0x87c74e49,0xd9c1d138, 0x8cfea2ca,0x98360bd4,0xa6cf81f5,0xa528de7a,0xda268eb7,0x3fa4bfad, 0x2ce49d3a,0x500d9278,0x6a9bcc5f,0x5462467e,0xf6c2138d,0x90e8b8d8, 0x2e5ef739,0x82f5afc3,0x9fbe805d,0x697c93d0,0x6fa92dd5,0xcfb31225, 0xc83b99ac,0x10a77d18,0xe86e639c,0xdb7bbb3b,0xcd097826,0x6ef41859, 0xec01b79a,0x83a89a4f,0xe6656e95,0xaa7ee6ff,0x2108cfbc,0xefe6e815, 0xbad99be7,0x4ace366f,0xead4099f,0x29d67cb0,0x31afb2a4,0x2a31233f, 0xc63094a5,0x35c066a2,0x7437bc4e,0xfca6ca82,0xe0b0d090,0x3315d8a7, 0xf14a9804,0x41f7daec,0x7f0e50cd,0x172ff691,0x768dd64d,0x434db0ef, 0xcc544daa,0xe4df0496,0x9ee3b5d1,0x4c1b886a,0xc1b81f2c,0x467f5165, 0x9d04ea5e,0x15d358c,0xfa737487,0xfb2e410b,0xb35a1d67,0x9252d2db, 0xe9335610,0x6d1347d6,0x9a8c61d7,0x377a0ca1,0x598e14f8,0xeb893c13, 0xceee27a9,0xb735c961,0xe1ede51c,0x7a3cb147,0x9c59dfd2,0x553f73f2, 0x1879ce14,0x73bf37c7,0x53eacdf7,0x5f5baafd,0xdf146f3d,0x7886db44, 0xca81f3af,0xb93ec468,0x382c3424,0xc25f40a3,0x1672c31d,0xbc0c25e2, 0x288b493c,0xff41950d,0x397101a8,0x8deb30c,0xd89ce4b4,0x6490c156, 0x7b6184cb,0xd570b632,0x48745c6c,0xd04257b8}; #endif // unsigned 4 chars to unsigned int is 4 bytes to 32-bit // MR_WORD：unsigned int // MR_BYTE：unsigned char static MR_WORD pack(const MR_BYTE *b) { /* pack bytes into a 32-bit Word */ // 4个字节全部强制转换为 MR_WORD 类型，然后分别左移3、2、1、0个字节，使得 4*byte = int return ((MR_WORD)b[3]>8); b[2]=MR_TOBYTE(a>>16); b[3]=MR_TOBYTE(a>>24); } /* static MR_BYTE xtime(MR_BYTE a) { MR_BYTE b; if (a&0x80) b=0x1B; else b=0; amode=mode; for (i=0;if[i]=0; if (mode!=MR_ECB && iv!=NULL) { for (i=0;if[i]=iv[i]; } } // 获取16字节数组 f 的全部元素 void aes_getreg(aes *a,char *ir) { int i; for (i=0;if[i]; } /* 初始化操作 a：获取AES的相关参数 mode：工作模式 nk：密钥字长度 key：密钥矩阵 iv：初始向量 */ BOOL aes_init(aes* a,int mode,int nk,char *key,char *iv) { /* Key=nk bytes */ /* currently NB.nk = 16, 24 or 32 */ /* Key Scheduler. Create expanded encryption key */ int i,j,k,N,nr; MR_WORD CipherKey[8]; // 最多有8个字长的密钥 nk/=4; // 密钥长度除以4，变成字，也就是列数 // 如果列数不是4、6、8，即不是AES-128、AES-192、AES-256 if (nk!=4 && nk!=6 && nk!=8) return FALSE; // 如果是AES-128、AES-192、AES-256，nk=4、6、8 /* nr is number of rounds */ nr=6+nk; // AES-128、AES-192、AES-256迭代的轮数 nr=10、12、14 a->Nk=nk; a->Nr=nr; // 初始化列数和轮数 aes_reset(a,mode,iv); // 初始化AES的16字节数组 f 和工作模式 N=NB*(nr+1); // 共需要的列数 // 将初始密钥16/24/32字节转换为4/6/8密钥字 for (i=j=0;ifkey[i]=CipherKey[i]; // 密钥扩充 // 列数j从nk开始，轮数k从0开始 for (j=nk,k=0;jfkey[j]=a->fkey[j-nk]^SubByte(ROTL24(a->fkey[j-1]))^rco[k]; if (nkfkey[i+j]=a->fkey[i+j-nk]^a->fkey[i+j-1]; } else { // if(nk>6) for (i=1;ifkey[i+j]=a->fkey[i+j-nk]^a->fkey[i+j-1]; if ((j+4)fkey[j+4]=a->fkey[j+4-nk]^SubByte(a->fkey[j+3]); for (i=5;ifkey[i+j]=a->fkey[i+j-nk]^a->fkey[i+j-1]; } } /* now for the expanded decrypt key in reverse order */ for (j=0;jrkey[j+N-NB]=a->fkey[j]; for (i=NB;irkey[k+j]=InvMixCol(a->fkey[i+j]); } for (j=N-NB;jrkey[j-N+NB]=a->fkey[j]; return TRUE; } /* _mm_loadu_si128 : __m128i _mm_loadu_si128 (__m128i const* mem_addr); 函数功能：加载128位的整数 mem_addr _mm_xor_si128 ： __m128i _mm_xor_si128 (__m128i a, __m128i b); 函数功能：128位整型数据a和b异或 _mm_aesenc_si128 ： __m128i _mm_aesenc_si128 (__m128i a, __m128i RoundKey); 函数功能：用 RoundKey 中的轮密钥，对 a 做一次 AES 加密 _mm_aesenclast_si128 ： __m128i _mm_aesenclast_si128 (__m128i a, __m128i RoundKey)； 函数功能：用 RoundKey 中的轮密钥，对 a 做最后一轮 AES 加密 _mm_storeu_si128 ： void _mm_storeu_si128 (__m128i* mem_addr, __m128i a)； 函数功能：将128位数据a存储到内存 */ void aes_ecb_encrypt(aes *a,MR_BYTE *buff) { int i,j,k; MR_WORD p[4],q[4],*x,*y,*t; #ifdef AES_NI_SUPPORT __m128i ky,m = _mm_loadu_si128((__m128i *) buff); ky = _mm_loadu_si128((__m128i *) &a->fkey[0]); m = _mm_xor_si128 (m, ky); k=NB; for (i=1;iNr;i++) { ky=_mm_loadu_si128((__m128i *) &a->fkey[k]); m =_mm_aesenc_si128(m, ky); k+=4; } ky=_mm_loadu_si128((__m128i *) &a->fkey[k]); m=_mm_aesenclast_si128(m, ky); _mm_storeu_si128((__m128i *)buff, m); #else for (i=j=0;ifkey[i]; } k=NB; x=p; y=q; /* State alternates between x and y */ for (i=1;iNr;i++) { /* Nr is number of rounds. May be odd. */ #ifndef MR_SMALL_AES y[0]=a->fkey[k]^ftable[MR_TOBYTE(x[0])]^ ftable1[MR_TOBYTE(x[1]>>8)]^ ftable2[MR_TOBYTE(x[2]>>16)]^ ftable3[x[3]>>24]; y[1]=a->fkey[k+1]^ftable[MR_TOBYTE(x[1])]^ ftable1[MR_TOBYTE(x[2]>>8)]^ ftable2[MR_TOBYTE(x[3]>>16)]^ ftable3[x[0]>>24]; y[2]=a->fkey[k+2]^ftable[MR_TOBYTE(x[2])]^ ftable1[MR_TOBYTE(x[3]>>8)]^ ftable2[MR_TOBYTE(x[0]>>16)]^ ftable3[x[1]>>24]; y[3]=a->fkey[k+3]^ftable[MR_TOBYTE(x[3])]^ ftable1[MR_TOBYTE(x[0]>>8)]^ ftable2[MR_TOBYTE(x[1]>>16)]^ ftable3[x[2]>>24]; #else y[0]=a->fkey[k]^ftable[MR_TOBYTE(x[0])]^ ROTL8(ftable[MR_TOBYTE(x[1]>>8)])^ ROTL16(ftable[MR_TOBYTE(x[2]>>16)])^ ROTL24(ftable[x[3]>>24]); y[1]=a->fkey[k+1]^ftable[MR_TOBYTE(x[1])]^ ROTL8(ftable[MR_TOBYTE(x[2]>>8)])^ ROTL16(ftable[MR_TOBYTE(x[3]>>16)])^ ROTL24(ftable[x[0]>>24]); y[2]=a->fkey[k+2]^ftable[MR_TOBYTE(x[2])]^ ROTL8(ftable[MR_TOBYTE(x[3]>>8)])^ ROTL16(ftable[MR_TOBYTE(x[0]>>16)])^ ROTL24(ftable[x[1]>>24]); y[3]=a->fkey[k+3]^ftable[MR_TOBYTE(x[3])]^ ROTL8(ftable[MR_TOBYTE(x[0]>>8)])^ ROTL16(ftable[MR_TOBYTE(x[1]>>16)])^ ROTL24(ftable[x[2]>>24]); #endif k+=4; t=x; x=y; y=t; /* swap pointers */ } /* Last Round */ y[0]=a->fkey[k]^(MR_WORD)fbsub[MR_TOBYTE(x[0])]^ ROTL8((MR_WORD)fbsub[MR_TOBYTE(x[1]>>8)])^ ROTL16((MR_WORD)fbsub[MR_TOBYTE(x[2]>>16)])^ ROTL24((MR_WORD)fbsub[x[3]>>24]); y[1]=a->fkey[k+1]^(MR_WORD)fbsub[MR_TOBYTE(x[1])]^ ROTL8((MR_WORD)fbsub[MR_TOBYTE(x[2]>>8)])^ ROTL16((MR_WORD)fbsub[MR_TOBYTE(x[3]>>16)])^ ROTL24((MR_WORD)fbsub[x[0]>>24]); y[2]=a->fkey[k+2]^(MR_WORD)fbsub[MR_TOBYTE(x[2])]^ ROTL8((MR_WORD)fbsub[MR_TOBYTE(x[3]>>8)])^ ROTL16((MR_WORD)fbsub[MR_TOBYTE(x[0]>>16)])^ ROTL24((MR_WORD)fbsub[x[1]>>24]); y[3]=a->fkey[k+3]^(MR_WORD)fbsub[MR_TOBYTE(x[3])]^ ROTL8((MR_WORD)fbsub[MR_TOBYTE(x[0]>>8)])^ ROTL16((MR_WORD)fbsub[MR_TOBYTE(x[1]>>16)])^ ROTL24((MR_WORD)fbsub[x[2]>>24]); for (i=j=0;irkey[0]); m = _mm_xor_si128 (m, ky); k=NB; for (i=1;iNr;i++) { ky=_mm_loadu_si128((__m128i *) &a->rkey[k]); m =_mm_aesdec_si128 (m, ky); k+=4; } ky=_mm_loadu_si128((__m128i *) &a->rkey[k]); m=_mm_aesdeclast_si128(m, ky); _mm_storeu_si128((__m128i *)buff, m); #else for (i=j=0;irkey[i]; } k=NB; x=p; y=q; /* State alternates between x and y */ for (i=1;iNr;i++) { /* Nr is number of rounds. May be odd. */ #ifndef MR_SMALL_AES y[0]=a->rkey[k]^rtable[MR_TOBYTE(x[0])]^ rtable1[MR_TOBYTE(x[3]>>8)]^ rtable2[MR_TOBYTE(x[2]>>16)]^ rtable3[x[1]>>24]; y[1]=a->rkey[k+1]^rtable[MR_TOBYTE(x[1])]^ rtable1[MR_TOBYTE(x[0]>>8)]^ rtable2[MR_TOBYTE(x[3]>>16)]^ rtable3[x[2]>>24]; y[2]=a->rkey[k+2]^rtable[MR_TOBYTE(x[2])]^ rtable1[MR_TOBYTE(x[1]>>8)]^ rtable2[MR_TOBYTE(x[0]>>16)]^ rtable3[x[3]>>24]; y[3]=a->rkey[k+3]^rtable[MR_TOBYTE(x[3])]^ rtable1[MR_TOBYTE(x[2]>>8)]^ rtable2[MR_TOBYTE(x[1]>>16)]^ rtable3[x[0]>>24]; #else y[0]=a->rkey[k]^rtable[MR_TOBYTE(x[0])]^ ROTL8(rtable[MR_TOBYTE(x[3]>>8)])^ ROTL16(rtable[MR_TOBYTE(x[2]>>16)])^ ROTL24(rtable[x[1]>>24]); y[1]=a->rkey[k+1]^rtable[MR_TOBYTE(x[1])]^ ROTL8(rtable[MR_TOBYTE(x[0]>>8)])^ ROTL16(rtable[MR_TOBYTE(x[3]>>16)])^ ROTL24(rtable[x[2]>>24]); y[2]=a->rkey[k+2]^rtable[MR_TOBYTE(x[2])]^ ROTL8(rtable[MR_TOBYTE(x[1]>>8)])^ ROTL16(rtable[MR_TOBYTE(x[0]>>16)])^ ROTL24(rtable[x[3]>>24]); y[3]=a->rkey[k+3]^rtable[MR_TOBYTE(x[3])]^ ROTL8(rtable[MR_TOBYTE(x[2]>>8)])^ ROTL16(rtable[MR_TOBYTE(x[1]>>16)])^ ROTL24(rtable[x[0]>>24]); #endif k+=4; t=x; x=y; y=t; /* swap pointers */ } /* Last Round */ y[0]=a->rkey[k]^(MR_WORD)rbsub[MR_TOBYTE(x[0])]^ ROTL8((MR_WORD)rbsub[MR_TOBYTE(x[3]>>8)])^ ROTL16((MR_WORD)rbsub[MR_TOBYTE(x[2]>>16)])^ ROTL24((MR_WORD)rbsub[x[1]>>24]); y[1]=a->rkey[k+1]^(MR_WORD)rbsub[MR_TOBYTE(x[1])]^ ROTL8((MR_WORD)rbsub[MR_TOBYTE(x[0]>>8)])^ ROTL16((MR_WORD)rbsub[MR_TOBYTE(x[3]>>16)])^ ROTL24((MR_WORD)rbsub[x[2]>>24]); y[2]=a->rkey[k+2]^(MR_WORD)rbsub[MR_TOBYTE(x[2])]^ ROTL8((MR_WORD)rbsub[MR_TOBYTE(x[1]>>8)])^ ROTL16((MR_WORD)rbsub[MR_TOBYTE(x[0]>>16)])^ ROTL24((MR_WORD)rbsub[x[3]>>24]); y[3]=a->rkey[k+3]^(MR_WORD)rbsub[MR_TOBYTE(x[3])]^ ROTL8((MR_WORD)rbsub[MR_TOBYTE(x[2]>>8)])^ ROTL16((MR_WORD)rbsub[MR_TOBYTE(x[1]>>16)])^ ROTL24((MR_WORD)rbsub[x[0]>>24]); for (i=j=0;imode) { case MR_ECB: aes_ecb_encrypt(a,(MR_BYTE *)buff); return 0; case MR_CBC: for (j=0;jf[j]; aes_ecb_encrypt(a,(MR_BYTE *)buff); for (j=0;jf[j]=buff[j]; return 0; case MR_CFB1: case MR_CFB2: case MR_CFB4: bytes=a->mode-MR_CFB1+1; for (j=0;jf[j]; for (j=0;jf[j]; for (j=bytes;jf[j-bytes]=a->f[j]; aes_ecb_encrypt(a,(MR_BYTE *)st); for (j=0;jf[16-bytes+j]=buff[j]; } return fell_off; case MR_OFB1: case MR_OFB2: case MR_OFB4: case MR_OFB8: case MR_OFB16: bytes=a->mode-MR_OFB1+1; aes_ecb_encrypt(a,(MR_BYTE *)(a->f)); for (j=0;jf[j]; return 0; case MR_PCFB1: /* error propagating CFB */ case MR_PCFB2: case MR_PCFB4: bytes=a->mode-MR_PCFB1+1; for (j=0;jf[j]; for (j=0;jf[j]; for (j=bytes;jf[j-bytes]=a->f[j]; aes_ecb_encrypt(a,(MR_BYTE *)st); for (j=0;jf[16-bytes+j]=buff[j]^st[16-bytes+j]; } return fell_off; default: return 0; } } mr_unsign32 aes_decrypt(aes *a,char *buff) { int j,bytes; char st[16]; mr_unsign32 fell_off; /* Supported modes of operation */ fell_off=0; switch (a->mode) { case MR_ECB: aes_ecb_decrypt(a,(MR_BYTE *)buff); return 0; case MR_CBC: for (j=0;jf[j]; a->f[j]=buff[j]; } aes_ecb_decrypt(a,(MR_BYTE *)buff); for (j=0;jmode-MR_CFB1+1; for (j=0;jf[j]; for (j=0;jf[j]; for (j=bytes;jf[j-bytes]=a->f[j]; aes_ecb_encrypt(a,(MR_BYTE *)st); for (j=0;jf[16-bytes+j]=buff[j]; buff[j]^=st[j]; } return fell_off; case MR_OFB1: case MR_OFB2: case MR_OFB4: case MR_OFB8: case MR_OFB16: bytes=a->mode-MR_OFB1+1; aes_ecb_encrypt(a,(MR_BYTE *)(a->f)); for (j=0;jf[j]; return 0; case MR_PCFB1: /* error propagating CFB */ case MR_PCFB2: case MR_PCFB4: bytes=a->mode-MR_PCFB1+1; for (j=0;jf[j]; for (j=0;jf[j]; for (j=bytes;jf[j-bytes]=a->f[j]; aes_ecb_encrypt(a,(MR_BYTE *)st); for (j=0;jf[16-bytes+j]=buff[j]^st[16-bytes+j]; buff[j]^=st[j]; } return fell_off; default: return 0; } } /* 函数功能：重置 aes 变量 NB : 4 Nr : 10 12 14 */ void aes_end(aes *a) { /* clean up */ int i; // 将 aes 中的密钥数组清空 for (i=0;iNr+1);i++) a->fkey[i]=a->rkey[i]=0; // 清空16字节的数组 f for (i=0;if[i]=0; } int main() { int i,j; // 下标参数 int nk; // 控制密钥的字节数 aes a; // AES 类型变量 MR_BYTE y,x,m; // #define MR_BYTE unsigned char char key[32]; char block[16]; char iv[16]; // 初始化密钥数组 for (i=0;i © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/demo/blmq.html":{"url":"miracldoc/demo/blmq.html","title":"blmq.cpp","keywords":"","body":"blmq.cpp BLMQ来自Efficient and Provably-Secure Identity-Based Signatures and Signcryption from Bilinear Maps 下面逐个测试五种曲线，建议直接从第三种曲线开始测试，解读源码，然后解析其他几种曲线。 第一种和第二种曲线，没有输出有效值； 第三种曲线输出了有效值； 第四种和第五种曲线，在编译的时候有错误。 MR_PAIRING_CP curve 准备文件 Makefile blmq.cpp ecn.h mirdef.h zzn2.cpp big.cpp cp_pair.cpp miracl.a zzn.cpp zzn2.h big.h ecn.cpp miracl.h zzn.h Makefile blmq : miracl.a big.o blmq.o cp_pair.o ecn.o zzn.o zzn2.o g++ -o blmq miracl.a big.o blmq.o cp_pair.o ecn.o zzn.o zzn2.o big.o : big.cpp g++ -c -o big.o big.cpp blmq.o : blmq.cpp g++ -c -o blmq.o blmq.cpp cp_pair.o : cp_pair.cpp g++ -c -o cp_pair.o cp_pair.cpp ecn.o : ecn.cpp g++ -c -o ecn.o ecn.cpp zzn.o : zzn.cpp g++ -c -o zzn.o zzn.cpp zzn2.o : zzn2.cpp g++ -c -o zzn2.o zzn2.cpp clean : rm -f *.o blmq 选择参数 //********* choose just one of these pairs ********** #define MR_PAIRING_CP // AES-80 security #define AES_SECURITY 80 编译之后，有错误提示信息，需要pairing_3.h文件，加入该头文件。 % make g++ -c -o big.o big.cpp g++ -c -o blmq.o blmq.cpp blmq.cpp:50:10: fatal error: 'pairing_3.h' file not found #include \"pairing_3.h\" ^~~~~~~~~~~~~ 1 error generated. make: *** [blmq.o] Error 1 再次编译，有错误提示：需要ecn2.h，加入ecn2.h和ecn2.cpp。 % make g++ -c -o big.o big.cpp g++ -c -o blmq.o blmq.cpp In file included from blmq.cpp:50: ./pairing_3.h:77:10: fatal error: 'ecn2.h' file not found #include \"ecn2.h\" // G2 ^~~~~~~~ 1 error generated. make: *** [blmq.o] Error 1 再次编译，有错误提示：需要zzn12a.h，加入zzn12a.h和zzn12a.cpp。 % make g++ -c -o big.o big.cpp g++ -c -o blmq.o blmq.cpp In file included from blmq.cpp:50: ./pairing_3.h:78:10: fatal error: 'zzn12a.h' file not found #include \"zzn12a.h\" // GT ^~~~~~~~~~ 1 error generated. make: *** [blmq.o] Error 1 再次编译，有错误提示：需要zzn4.h，加入zzn4.h和zzn4.cpp。 % make g++ -c -o big.o big.cpp g++ -c -o blmq.o blmq.cpp In file included from blmq.cpp:50: In file included from ./pairing_3.h:78: ./zzn12a.h:65:10: fatal error: 'zzn4.h' file not found #include \"zzn4.h\" ^~~~~~~~ 1 error generated. make: *** [blmq.o] Error 1 再次编译 % make g++ -c -o big.o big.cpp g++ -c -o blmq.o blmq.cpp g++ -c -o cp_pair.o cp_pair.cpp g++ -c -o ecn.o ecn.cpp g++ -c -o zzn.o zzn.cpp g++ -c -o zzn2.o zzn2.cpp g++ -o blmq miracl.a big.o blmq.o cp_pair.o ecn.o zzn.o zzn2.o 执行 % ./blmq No suitable curve available MR_PAIRING_MNT curve 准备文件 blmq.cpp mnt_pair.cpp zzn6a.cpp ecn3.cpp zzn3.cpp zzn2.cpp big.cpp zzn.cpp ecn.cpp Makefile blmq : miracl.a big.o blmq.o ecn.o zzn.o zzn2.o mnt_pair.o zzn6a.o ecn3.o zzn3.o g++ -o blmq miracl.a big.o blmq.o ecn.o zzn.o zzn2.o mnt_pair.o zzn6a.o ecn3.o zzn3.o 编译 % make g++ -c -o big.o big.cpp g++ -c -o blmq.o blmq.cpp g++ -c -o ecn.o ecn.cpp g++ -c -o zzn.o zzn.cpp g++ -c -o zzn2.o zzn2.cpp g++ -c -o mnt_pair.o mnt_pair.cpp g++ -c -o zzn6a.o zzn6a.cpp g++ -c -o ecn3.o ecn3.cpp g++ -c -o zzn3.o zzn3.cpp g++ -o blmq miracl.a big.o blmq.o ecn.o zzn.o zzn2.o mnt_pair.o zzn6a.o ecn3.o zzn3.o 执行 % ./blmq No suitable curve available MR_PAIRING_BN curve 所谓BN曲线是指Barreto和Naehrig设计的曲线，即Pairing-Friendly Elliptic Curves of Prime Order。 测试 #define MR_PAIRING_BN // AES-128 or AES-192 security #define AES_SECURITY 128 // #define AES_SECURITY 192 添加相关文件，编辑Makefile blmq : miracl.a big.o blmq.o ecn.o zzn.o zzn2.o bn_pair.o zzn12a.o ecn2.o zzn4.o g++ -o blmq miracl.a big.o blmq.o ecn.o zzn.o zzn2.o bn_pair.o zzn12a.o ecn2.o zzn4.o 编译Makefile，没有错误，只有一个警告提示，可以忽略。 % make g++ -c -o big.o big.cpp g++ -c -o blmq.o blmq.cpp g++ -c -o ecn.o ecn.cpp g++ -c -o zzn.o zzn.cpp g++ -c -o zzn2.o zzn2.cpp g++ -c -o bn_pair.o bn_pair.cpp bn_pair.cpp:1439:8: warning: assigning field to itself [-Wself-assign-field] mtbits=mtbits; ^ 1 warning generated. g++ -c -o zzn12a.o zzn12a.cpp g++ -c -o ecn2.o ecn2.cpp g++ -c -o zzn4.o zzn4.cpp g++ -o blmq miracl.a big.o blmq.o ecn.o zzn.o zzn2.o bn_pair.o zzn12a.o ecn2.o zzn4.o 执行编译结果。 % ./blmq Signed Message= test message Message is OK Verified Message= test message 解析源码 声明MR_PAIRING_BN，表示调用BN曲线。 #define MR_PAIRING_BN // AES-128 or AES-192 security #define AES_SECURITY 128 // #define AES_SECURITY 192 pairing_3.h关于BN曲线的定义：需要加入zzn2.h、ecn2.h、zzn12a.h，同时设置窗口大小和群元素类型。 //k=12 BN curve #ifdef MR_PAIRING_BN #include \"zzn2.h\" #include \"ecn2.h\" // G2 #include \"zzn12a.h\" // GT #define WINDOW_SIZE 8 // window size for precomputation #define G2_TYPE ECn2 #define G2_SUBTYPE ZZn2 #define GT_TYPE ZZn12 #define FROB_TYPE ZZn2 #endif 进入main函数的分析 pairing-friendly 的椭圆曲线是指有很好的嵌入度（favourable embedding degree）、很大的质数阶子群（large prime-order subgroup）。这种椭圆曲线很少，BLS曲线就是特地构造的符合条件的曲线。 // AES_SECURITY 为安全级别 PFC pfc(AES_SECURITY); // initialise pairing-friendly curve Big order=pfc.order(); miracl* mip=get_mip(); BN曲线配对 MR_PAIRING_KSS curve blmq : miracl.a blmq.o kss_pair.o zzn18.o zzn6.o ecn3.o zzn3.o big.o zzn.o ecn.o g++ -o blmq miracl.a blmq.o kss_pair.o zzn18.o zzn6.o ecn3.o zzn3.o big.o zzn.o ecn.o 编译之后，有大量的错误提示，都来自kss_pair.cpp，而且都在提示没有找到to_binary函数。 % make g++ -c -o big.o big.cpp g++ -c -o blmq.o blmq.cpp g++ -c -o ecn.o ecn.cpp g++ -c -o zzn.o zzn.cpp g++ -c -o kss_pair.o kss_pair.cpp kss_pair.cpp:413:3: error: use of undeclared identifier 'to_binary' to_binary(a,bytes_per_big,&bytes[j],TRUE); ^ kss_pair.cpp:415:3: error: use of undeclared identifier 'to_binary' to_binary(b,bytes_per_big,&bytes[j],TRUE); MR_PAIRING_BLS curve blmq : miracl.a blmq.o bls_pair.o zzn24.o zzn8.o zzn4.o zzn2.o ecn4.o big.o zzn.o g++ -o blmq miracl.a blmq.o bls_pair.o zzn24.o zzn8.o zzn4.o zzn2.o ecn4.o big.o zzn.o 编译之后有错误提示，问题集中在bls_pair.cpp % make g++ -c -o blmq.o blmq.cpp g++ -c -o bls_pair.o bls_pair.cpp g++ -c -o zzn24.o zzn24.cpp g++ -c -o zzn8.o zzn8.cpp g++ -c -o zzn4.o zzn4.cpp g++ -c -o zzn2.o zzn2.cpp c++ -c -o ecn4.o ecn4.cpp g++ -c -o big.o big.cpp g++ -c -o zzn.o zzn.cpp g++ -o blmq miracl.a blmq.o bls_pair.o zzn24.o zzn8.o zzn4.o zzn2.o ecn4.o big.o zzn.o Undefined symbols for architecture arm64: \"mul(Big const&, ECn const&, Big const&, ECn const&)\", referenced from: PFC::mult(G1 const&, Big const&) in bls_pair.o \"ECn::get(Big&, Big&) const\", referenced from: PFC::add_to_hash(G1 const&) in bls_pair.o G1::spill(char*&) in bls_pair.o \"ECn::iszero() const\", referenced from: extract(ECn&, ZZn&, ZZn&) in bls_pair.o \"ECn::get_point() const\", referenced from: force(ZZn&, ZZn&, ZZn&, ECn&) in bls_pair.o extract(ECn&, ZZn&, ZZn&, ZZn&) in bls_pair.o force(ZZn&, ZZn&, ECn&) in bls_pair.o extract(ECn&, ZZn&, ZZn&) in bls_pair.o endomorph(ECn&, ZZn&) in bls_pair.o \"operator-(ECn const&)\", referenced from: PFC::mult(G1 const&, Big const&) in bls_pair.o operator-(G1 const&) in bls_pair.o ld: symbol(s) not found for architecture arm64 clang: error: linker command failed with exit code 1 (use -v to see invocation) make: *** [blmq] Error 1 源码 /* Barreto, Libert, McCullagh, Quisquater Signcryption http://grouper.ieee.org/groups/1363/IBC/submissions/Libert-IEEE-P1363-submission.pdf Section 4.2 Uses Smart-Vercauteren idea for G2 http://eprint.iacr.org/2005/116.pdf Compile with modules as specified below For MR_PAIRING_CP curve cl /O2 /GX blmq.cpp cp_pair.cpp zzn2.cpp big.cpp zzn.cpp ecn.cpp miracl.lib For MR_PAIRING_MNT curve cl /O2 /GX blmq.cpp mnt_pair.cpp zzn6a.cpp ecn3.cpp zzn3.cpp zzn2.cpp big.cpp zzn.cpp ecn.cpp miracl.lib For MR_PAIRING_BN curve cl /O2 /GX blmq.cpp bn_pair.cpp zzn12a.cpp ecn2.cpp zzn4.cpp zzn2.cpp big.cpp zzn.cpp ecn.cpp miracl.lib For MR_PAIRING_KSS curve cl /O2 /GX blmq.cpp kss_pair.cpp zzn18.cpp zzn6.cpp ecn3.cpp zzn3.cpp big.cpp zzn.cpp ecn.cpp miracl.lib For MR_PAIRING_BLS curve cl /O2 /GX blmq.cpp bls_pair.cpp zzn24.cpp zzn8.cpp zzn4.cpp zzn2.cpp ecn4.cpp big.cpp zzn.cpp ecn.cpp miracl.lib Test program */ #include #include //********* choose just one of these pairs ********** //#define MR_PAIRING_CP // AES-80 security //#define AES_SECURITY 80 //#define MR_PAIRING_MNT // AES-80 security //#define AES_SECURITY 80 #define MR_PAIRING_BN // AES-128 or AES-192 security #define AES_SECURITY 128 //#define AES_SECURITY 192 //#define MR_PAIRING_KSS // AES-192 security //#define AES_SECURITY 192 //#define MR_PAIRING_BLS // AES-256 security //#define AES_SECURITY 256 //********************************************* #include \"pairing_3.h\" int main() { PFC pfc(AES_SECURITY); // initialise pairing-friendly curve Big order=pfc.order(); miracl* mip=get_mip(); Big s,x,a,b,h,c,M; G2 Q2,Q2pub,S2a,S2b; G1 Q1pub,P,S1a,S1b,S,T; GT g,r,rhs; time_t seed; time(&seed); irand((long)seed); //setup - G2 = Q = {P,Q2) pfc.random(P); pfc.random(Q2); pfc.precomp_for_mult(P); pfc.precomp_for_mult(Q2); g=pfc.pairing(Q2,P); pfc.precomp_for_power(g); pfc.random(s); Q1pub=pfc.mult(P,s); Q2pub=pfc.mult(Q2,s); //Keygen a=pfc.hash_to_group((char *)\"Alice\"); S1a=pfc.mult(P,inverse(a+s,order)); S2a=pfc.mult(Q2,inverse(a+s,order)); b=pfc.hash_to_group((char *)\"Bob\"); S1b=pfc.mult(P,inverse(b+s,order)); S2b=pfc.mult(Q2,inverse(b+s,order)); //Signcrypt mip->IOBASE=256; M=(char *)\"test message\"; // to be signcrypted from Alice to Bob cout IOBASE=16; pfc.precomp_for_mult(S1a); pfc.random(x); r=pfc.power(g,x); c=lxor(M,pfc.hash_to_aes_key(r)); pfc.start_hash(); pfc.add_to_hash(M); pfc.add_to_hash(r); h=pfc.finish_hash_to_group(); S=pfc.mult(S1a,x+h); T=pfc.mult(pfc.mult(P,b)+Q1pub,x); // Unsigncrypt pfc.precomp_for_pairing(S2b); // Bob can precompute on his private key r=pfc.pairing(S2b,T); M=lxor(c,pfc.hash_to_aes_key(r)); pfc.start_hash(); pfc.add_to_hash(M); pfc.add_to_hash(r); h=pfc.finish_hash_to_group(); rhs=pfc.pairing(pfc.mult(Q2,a)+Q2pub,S)*pfc.power(g,-h); mip->IOBASE=256; if (r==rhs) { cout © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/packgDemo/bn_pair.html":{"url":"miracldoc/packgDemo/bn_pair.html","title":"bn_pair.cpp","keywords":"","body":"bn_pair.cpp BN曲线的源码解析 bn_pair.cpp源码 /* * * bn_pair.cpp * * BN curve, ate pairing embedding degree 12, ideal for security level AES-128 * * Irreducible poly is X^3+n, where n=sqrt(w+sqrt(m)), m= {-1,-2} and w= {0,1,2} * if p=5 mod 8, n=sqrt(-2) * if p=3 mod 8, n=1+sqrt(-1) * if p=7 mod 8, p=2,3 mod 5, n=2+sqrt(-1) * * Provides high level interface to pairing functions * * GT=pairing(G2,G1) * * This is calculated on a Pairing Friendly Curve (PFC), which must first be defined. * * G1 is a point over the base field, and G2 is a point over an extension field of degree 2 * GT is a finite field point over the 12-th extension, where 12 is the embedding degree. * */ #define MR_PAIRING_BN #include \"pairing_3.h\" // BN curve parameters x,A,B static char param_128[]=\"-4080000000000001\"; // 766 - bit curve static char param_192[]=\"-4000000000000000000000000000000000000000000ABBB5\"; // Hamming weight of 6*x+2 = 8 static char curveB[]=\"2\"; void read_only_error(void) { cout pmod8) { case 5: X.set((Big)0,(Big)1); // = (sqrt(-2)^(p-1)/2 break; case 3: // = (1+sqrt(-1))^(p-1)/2 X.set((Big)1,(Big)1); break; case 7: X.set((Big)2,(Big)1); // = (2+sqrt(-1))^(p-1)/2 default: break; } X=pow(X,(p-1)/6); } // Using SHA256 as basic hash algorithm // // Hash function // #define HASH_LEN 32 Big H1(char *string) { // Hash a zero-terminated string to a number =p) break; } h%=p; return h; } void PFC::start_hash(void) { shs256_init(&SH); } Big PFC::finish_hash_to_group(void) { Big hash; char s[HASH_LEN]; shs256_hash(&SH,s); hash=from_binary(HASH_LEN,s); return hash%(*ord); } Big PFC::finish_hash_to_aes_key(void) { Big hash; char s[HASH_LEN]; shs256_hash(&SH,s); Big m=pow((Big)2,S); hash=from_binary(HASH_LEN,s); return hash%m; } void PFC::add_to_hash(const GT& x) { ZZn4 u; ZZn12 v=x.g; ZZn2 h,l; Big a; ZZn xx[6]; int i,j,m; v.get(u); u.get(l,h); l.get(xx[0],xx[1]); h.get(xx[2],xx[3]); for (i=0;i0) { m=a%256; shs256_process(&SH,m); a/=256; } } } void PFC::add_to_hash(const G2& x) { ZZn2 X,Y; ECn2 v=x.g; Big a; ZZn xx[4]; int i,m; v.get(X,Y); X.get(xx[0],xx[1]); Y.get(xx[2],xx[3]); for (i=0;i0) { m=a%256; shs256_process(&SH,m); a/=256; } } } void PFC::add_to_hash(const G1& x) { Big a,X,Y; int i,m; x.g.get(X,Y); a=X; while (a>0) { m=a%256; shs256_process(&SH,m); a/=256; } a=Y; while (a>0) { m=a%256; shs256_process(&SH,m); a/=256; } } void PFC::add_to_hash(const Big& x) { int m; Big a=x; while (a>0) { m=a%256; shs256_process(&SH,m); a/=256; } } void PFC::add_to_hash(char *x) { int i=0; while (x[i]!=0) { shs256_process(&SH,x[i]); i++; } } Big H2(ZZn12 x) { // Compress and hash an Fp12 to a big number sha256 sh; ZZn4 u; ZZn2 h,l; Big a,hash,p,xx[4]; char s[HASH_LEN]; int i,j,m; shs256_init(&sh); x.get(u); // compress to single ZZn4 u.get(l,h); xx[0]=real(l); xx[1]=imaginary(l); xx[2]=real(h); xx[3]=imaginary(h); for (i=0;i0) { m=a%256; shs256_process(&sh,m); a/=256; } } shs256_hash(&sh,s); hash=from_binary(HASH_LEN,s); return hash; } #ifndef MR_AFFINE_ONLY void force(ZZn& x,ZZn& y,ZZn& z,ECn& A) { // A=(x,y,z) copy(getbig(x),A.get_point()->X); copy(getbig(y),A.get_point()->Y); copy(getbig(z),A.get_point()->Z); A.get_point()->marker=MR_EPOINT_GENERAL; } void extract(ECn &A, ZZn& x,ZZn& y,ZZn& z) { // (x,y,z) X; y=(A.get_point())->Y; t=(A.get_point())->Z; if (A.get_status()!=MR_EPOINT_GENERAL) z=1; else z=t; } #endif void force(ZZn& x,ZZn& y,ECn& A) { // A=(x,y) copy(getbig(x),A.get_point()->X); copy(getbig(y),A.get_point()->Y); A.get_point()->marker=MR_EPOINT_NORMALIZED; } void extract(ECn& A,ZZn& x,ZZn& y) { // (x,y) X; y=(A.get_point())->Y; } // Fast multiplication of A by q (for Trace-Zero group members only) // Calculate q*P. P(X,Y) -> P(X^p,Y^p)) void q_power_frobenius(ECn2 &A,ZZn2 &F) { ZZn2 x,y,z,w,r; A.get(x,y,z); w=F*F; r=F; x=w*conj(x); y=r*w*conj(y); z.conj(); A.set(x,y,z); } // // Line from A to destination C. Let A=(x,y) // Line Y-slope.X-c=0, through A, so intercept c=y-slope.x // Line Y-slope.X-y+slope.x = (Y-y)-slope.(X-x) = 0 // Now evaluate at Q -> return (Qy-y)-slope.(Qx-x) // ZZn12 line(ECn2& A,ECn2& C,ECn2& B,ZZn2& slope,ZZn2& extra,BOOL Doubling,ZZn& Qx,ZZn& Qy) { ZZn12 w; ZZn4 nn,dd; ZZn2 X,Y; ZZn2 Z3; C.getZ(Z3); // Thanks to A. Menezes for pointing out this optimization... if (Doubling) { ZZn2 Z,ZZ; A.get(X,Y,Z); ZZ=Z; ZZ*=ZZ; nn.set((Z3*ZZ)*Qy,slope*X-extra); dd.set(-(ZZ*slope)*Qx); } else { ZZn2 X2,Y2; B.get(X2,Y2); nn.set(Z3*Qy,slope*X2-Y2*Z3); dd.set(-slope*Qx); } w.set(nn,dd); return w; } // // Add A=A+B (or A=A+A) // Return line function value // ZZn12 g(ECn2& A,ECn2& B,ZZn& Qx,ZZn& Qy) { ZZn2 lam,extra; ZZn12 r; ECn2 P=A; BOOL Doubling; // Evaluate line from A Doubling=A.add(B,lam,extra); if (A.iszero()) return (ZZn12)1; r=line(P,A,B,lam,extra,Doubling,Qx,Qy); return r; } // if multiples of G2 in e(G2,G1) can be precalculated, its a lot faster! ZZn12 gp(ZZn2* ptable,int &j,ZZn& Px,ZZn& Py) { ZZn12 w; ZZn4 nn,dd; nn.set(Py,ptable[j+1]); dd.set(ptable[j]*Px); j+=2; w.set(nn,dd); return w; } // // Spill precomputation on pairing to byte array // int PFC::spill(G2& w,char *& bytes) { int i,j,len,m; int bytes_per_big=(MIRACL/8)*(get_mip()->nib-1); Big a,b,n; Big X=*x; if (w.ptable==NULL) return 0; if (Xnib-1); Big a,b,n; Big X=*x; if (w.ptable!=NULL) return; if (Xcoord=MR_AFFINE; // switch to affine for (i=nb-2;i>=0;i--) { Q=A; // Evaluate line from A to A+A A.add(A,lam); Q.get(x1,y1); w.ptable[j++]=-lam; w.ptable[j++]=lam*x1-y1; if (bit(n,i)==1) { Q=A; A.add(B,lam); Q.get(x1,y1); w.ptable[j++]=-lam; w.ptable[j++]=lam*x1-y1; } } q_power_frobenius(KA,*frob); if (Xcoord=MR_PROJECTIVE; return len; } GT PFC::multi_miller(int n,G2** QQ,G1** PP) { GT z; ZZn *Px,*Py; int i,j,*k,nb; ECn2 *Q,*A; ECn P; ZZn12 res; Big m; Big X=*x; Px=new ZZn[n]; Py=new ZZn[n]; Q=new ECn2[n]; A=new ECn2[n]; k=new int[n]; if (Xg; normalise(P); Q[j]=QQ[j]->g; Q[j].norm(); extract(P,Px[j],Py[j]); } for (j=0;j=0;i--) { res*=res; for (j=0;jptable==NULL) res*=g(A[j],A[j],Px[j],Py[j]); else res*=gp(QQ[j]->ptable,k[j],Px[j],Py[j]); } if (bit(m,i)==1) for (j=0;jptable==NULL) res*=g(A[j],Q[j],Px[j],Py[j]); else res*=gp(QQ[j]->ptable,k[j],Px[j],Py[j]); } if (res.iszero()) return 0; } if (Xptable==NULL) { if (Xptable,k[j],Px[j],Py[j]); q_power_frobenius(Q[j],*frob); if (QQ[j]->ptable==NULL) { Q[j]=-Q[j]; res*=g(A[j],Q[j],Px[j],Py[j]); } else res*=gp(QQ[j]->ptable,k[j],Px[j],Py[j]); } delete [] k; delete [] A; delete [] Q; delete [] Py; delete [] Px; z.g=res; return z; } // // R-ate Pairing G2 x G1 -> GT // // P is a point of order q in G1. Q(x,y) is a point of order q in G2. // Note that Q is a point on the sextic twist of the curve over Fp^2, P(x,y) is a point on the // curve over the base field Fp // GT PFC::miller_loop(const G2& QQ,const G1& PP) { GT z; Big n; int i,j,nb,nbw,nzs; ECn2 A,KA,Q; ECn P; ZZn Px,Py; BOOL precomp; ZZn12 r; Big X=*x; Q=QQ.g; P=PP.g; precomp=FALSE; if (QQ.ptable!=NULL) precomp=TRUE; else Q.norm(); normalise(P); extract(P,Px,Py); if (X=0;i--) { r*=r; if (precomp) r*=gp(QQ.ptable,j,Px,Py); else r*=g(A,A,Px,Py); if (bit(n,i)) { if (precomp) r*=gp(QQ.ptable,j,Px,Py); else r*=g(A,Q,Px,Py); } } // Combining ideas due to Longa, Aranha et al. and Naehrig KA=Q; q_power_frobenius(KA,*frob); if (XIOBASE=16; #endif B=new Big; x=new Big; mod=new Big; ord=new Big; cof=new Big; npoints=new Big; trace=new Big; for (i=0;iTWIST=MR_SEXTIC_D; // map Server to point on twisted curve E(Fp2) RNG = rng; } PFC::~PFC() { int i,j; delete B; delete x; delete mod; delete ord; delete cof; delete npoints; delete trace; for (i=0;iX; x*=Beta; copy(getbig(x),(A.get_point())->X); } G1 PFC::mult(const G1& w,const Big& k) { G1 z; ECn Q; if (w.mtable!=NULL) { // we have precomputed values Big e=k; if (k=0;i--) { j=recode(e,t,WINDOW_SIZE,i); z.g+=z.g; if (j>0) z.g+=w.mtable[j]; } if (k=0;i--) { j=recode(e,t,WINDOW_SIZE,i); z.g+=z.g; if (j>0) z.g+=w.mtable[j]; } if (k=0;i--) { j=recode(e,t,WINDOW_SIZE,i); z.g*=z.g; if (j>0) z.g*=w.etable[j]; } if (k=p) break; } h%=p; return h % (*ord); } GT operator*(const GT& x,const GT& y) { GT z=x; z.g*=y.g; return z; } GT operator/(const GT& x,const GT& y) { GT z=x; z.g/=y.g; return z; } // // spill precomputation on GT to byte array // int GT::spill(char *& bytes) { int i,j,n=(1nib-1); int len=n*12*bytes_per_big+1; ZZn4 a,b,c; ZZn2 f,s; Big x,y; if (etable==NULL) return 0; bytes=new char[len]; for (i=j=0;inib-1); // int len=n*12*bytes_per_big; ZZn4 a,b,c; ZZn2 f,s; Big x,y; if (etable!=NULL) return; etable=new ZZn12[1nib-1); int len=n*2*bytes_per_big+1; Big x,y; if (mtable==NULL) return 0; bytes=new char[len]; for (i=j=0;inib-1); // int len=n*2*bytes_per_big; Big x,y; if (mtable!=NULL) return; mtable=new ECn[1nib-1); int len=n*4*bytes_per_big+1; ZZn2 a,b; Big x,y; if (mtable==NULL) return 0; bytes=new char[len]; for (i=j=0;inib-1); // int len=n*4*bytes_per_big; ZZn2 a,b; Big x,y; if (mtable!=NULL) return; mtable=new ECn2[1 © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-15 "},"miracldoc/api/cplus.html":{"url":"miracldoc/api/cplus.html","title":"C++中的函数","keywords":"","body":"C++中的函数 函数common() SSE2的常用指令（来源） _mm_loadu_si128 : __m128i _mm_loadu_si128 (__m128i const* mem_addr); 函数功能：加载128位的整数 mem_addr _mm_xor_si128 ： __m128i _mm_xor_si128 (__m128i a, __m128i b); 函数功能：128位整型数据a和b异或 _mm_aesenc_si128 ： __m128i _mm_aesenc_si128 (__m128i a, __m128i RoundKey); 函数功能：用 RoundKey 中的轮密钥，对 a 做一次 AES 加密 _mm_aesenclast_si128 ： __m128i _mm_aesenclast_si128 (__m128i a, __m128i RoundKey)； 函数功能：用 RoundKey 中的轮密钥，对 a 做最后一轮 AES 加密 _mm_storeu_si128 ： void _mm_storeu_si128 (__m128i* mem_addr, __m128i a)； 函数功能：将128位数据a存储到内存 modf() modf是C语言库math.h中提供的函数 extern double modf(double, double *); 函数功能：将浮点数分解为整数部分和小数部分 #include #include int main() { double numbers[] = {123.456, -789.012, 0.0, 3.141592}; double intPart; double fracPart; for(int i = 0; i 测试输出 Number: 123.456000 = Integer Part: 123 + Fractional Part: 0.456000 Number: -789.012000 = Integer Part: -789 + Fractional Part: -0.012000 Number: 0.000000 = Integer Part: 0 + Fractional Part: 0.000000 Number: 3.141592 = Integer Part: 3 + Fractional Part: 0.141592 © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-19 "},"miracldoc/api/dtype/big.html":{"url":"miracldoc/api/dtype/big.html","title":"big类型","keywords":"","body":"big、zzn、flash等类型 big类型定义在miracl.h #define mr_utype int // the underlying type is usually int #ifdef MR_FP typedef mr_utype mr_small; #ifdef mr_dltype typedef mr_dltype mr_large; #endif #endif /* It might be wanted to change this to unsigned long */ typedef unsigned int mr_lentype; struct bigtype { mr_lentype len; mr_small *w; }; typedef struct bigtype *big; typedef big zzn; typedef big flash; 在miracl.h中，对big、zzn、flash等类型做了定义，其实这三种类型都是struct bigtype *类型。由定义可知，big、zzn、flash等类型是两个unsigned类型成员的组合。 © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-18 "},"miracldoc/api/dtype/constants.html":{"url":"miracldoc/api/dtype/constants.html","title":"字符常量","keywords":"","body":"字符常量 项目中涉及到的字符常量。 错误提示相关的常量 /* error returns 错误提示相关的常量 */ #define MR_ERR_BASE_TOO_BIG 1 #define MR_ERR_DIV_BY_ZERO 2 #define MR_ERR_OVERFLOW 3 #define MR_ERR_NEG_RESULT 4 #define MR_ERR_BAD_FORMAT 5 #define MR_ERR_BAD_BASE 6 #define MR_ERR_BAD_PARAMETERS 7 #define MR_ERR_OUT_OF_MEMORY 8 #define MR_ERR_NEG_ROOT 9 #define MR_ERR_NEG_POWER 10 #define MR_ERR_BAD_ROOT 11 #define MR_ERR_INT_OP 12 #define MR_ERR_FLASH_OVERFLOW 13 #define MR_ERR_TOO_BIG 14 #define MR_ERR_NEG_LOG 15 #define MR_ERR_DOUBLE_FAIL 16 #define MR_ERR_IO_OVERFLOW 17 #define MR_ERR_NO_MIRSYS 18 #define MR_ERR_BAD_MODULUS 19 #define MR_ERR_NO_MODULUS 20 #define MR_ERR_EXP_TOO_BIG 21 #define MR_ERR_NOT_SUPPORTED 22 #define MR_ERR_NOT_DOUBLE_LEN 23 #define MR_ERR_NOT_IRREDUC 24 #define MR_ERR_NO_ROUNDING 25 #define MR_ERR_NOT_BINARY 26 #define MR_ERR_NO_BASIS 27 #define MR_ERR_COMPOSITE_MODULUS 28 #define MR_ERR_DEV_RANDOM 29 椭圆曲线上点的状态 /* Elliptic curve point status */ #define MR_EPOINT_GENERAL 0 #define MR_EPOINT_NORMALIZED 1 #define MR_EPOINT_INFINITY 2 #define MR_NOTSET 0 #define MR_PROJECTIVE 0 #define MR_AFFINE 1 #define MR_BEST 2 #define MR_TWIST 8 #define MR_OVER 0 #define MR_ADD 1 #define MR_DOUBLE 2 /* Twist type 扭曲类型 */ #define MR_QUADRATIC 2 #define MR_CUBIC_M 0x3A #define MR_CUBIC_D 0x3B #define MR_QUARTIC_M 0x4A #define MR_QUARTIC_D 0x4B #define MR_SEXTIC_M 0x6A #define MR_SEXTIC_D 0x6B BOOL 定义在miracl.h #ifndef TRUE #define TRUE 1 #endif #ifndef FALSE #define FALSE 0 #endif typedef int BOOL; 数值 MR_IBITS定义在mirdef.h，表示int类型数据的比特位数，32位也即4个字节，也就是int类型数据占4个字节单元。 #define MR_IBITS 32 /* bits in int 比特位数 */ typedef unsigned int mr_lentype; /* 将1左移 MR_IBITS-1 位 */ #define MR_MSBIT ((mr_lentype)1 MR_MSBIT将1强制转换为mr_lentype类型，也即00000000000000000000000000000001，然后左移31位，得到10000000000000000000000000000000。 MR_OBITS将10000000000000000000000000000000减1，得到01111111111111111111111111111111。 其他 #define MR_MAXDEPTH 24 /* max routine stack depth */ © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-18 "},"miracldoc/api/dtype/epoint.html":{"url":"miracldoc/api/dtype/epoint.html","title":"epoint类型","keywords":"","body":"epoint类型 epoint类型定义在miracl.h /* Elliptic Curve epoint structure. Uses projective (X,Y,Z) co-ordinates */ typedef struct { int marker; big X; big Y; #ifndef MR_AFFINE_ONLY big Z; #endif } epoint; © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-17 "},"miracldoc/api/dtype/int.html":{"url":"miracldoc/api/dtype/int.html","title":"与int类型相关","keywords":"","body":"与int类型相关的数据类型 mr_small、mr_large #define mr_utype int #define mr_dltype long long #ifdef MR_FP typedef mr_utype mr_small; #ifdef mr_dltype typedef mr_dltype mr_large; #endif #else typedef unsigned mr_utype mr_small; #ifdef mr_dltype typedef unsigned mr_dltype mr_large; #endif #endif union doubleword union doubleword类型中，两个mr_small类型数据构造一个mr_large类型。 union doubleword { mr_large d; mr_small h[2]; }; © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-19 "},"miracldoc/api/dtype/miracl.html":{"url":"miracldoc/api/dtype/miracl.html","title":"miracl类型","keywords":"","body":"miracl类型 miracl类型定义在miracl.h typedef struct { mr_small base; /* number base */ mr_small apbase; /* apparent base */ int pack; /* packing density */ int lg2b; /* bits in base */ mr_small base2; /* 2^mr_lg2b */ BOOL (*user)(void); /* pointer to user supplied function */ int nib; /* length of bigs */ #ifndef MR_STRIPPED_DOWN int depth; /* error tracing ..*/ int trace[MR_MAXDEPTH]; /* .. mechanism 最大深度 */ #endif BOOL check; /* overflow check */ BOOL fout; /* Output to file */ BOOL fin; /* Input from file */ BOOL active; #ifndef MR_NO_FILE_IO FILE *infile; /* Input file */ FILE *otfile; /* Output file */ #endif #ifndef MR_NO_RAND mr_unsign32 ira[NK]; /* random number... */ int rndptr; /* ...array & pointer */ mr_unsign32 borrow; #endif /* Montgomery constants */ mr_small ndash; big modulus; big pR; BOOL ACTIVE; BOOL MONTY; /* Elliptic Curve details */ #ifndef MR_NO_SS BOOL SS; /* True for Super-Singular */ #endif #ifndef MR_NOKOBLITZ BOOL KOBLITZ; /* True for a Koblitz curve */ #endif #ifndef MR_AFFINE_ONLY int coord; #endif int Asize,Bsize; int M,AA,BB,CC; /* for GF(2^m) curves */ /* mr_small pm,mask; int e,k,Me,m; for GF(p^m) curves */ #ifndef MR_STATIC int logN; /* constants for fast fourier fft multiplication */ int nprimes,degree; mr_utype *prime,*cr; mr_utype *inverse,**roots; small_chinese chin; mr_utype const1,const2,const3; mr_small msw,lsw; mr_utype **s1,**s2; /* pre-computed tables for polynomial reduction */ mr_utype **t; /* workspace */ mr_utype *wa; mr_utype *wb; mr_utype *wc; #endif BOOL same; BOOL first_one; BOOL debug; big w0; /* workspace bigs */ big w1,w2,w3,w4; big w5,w6,w7; big w8,w9,w10,w11; big w12,w13,w14,w15; big sru; big one; #ifdef MR_KCM big big_ndash; big ws,wt; #endif big A,B; /* User modifiables */ #ifndef MR_SIMPLE_IO int IOBSIZ; /* size of i/o buffer */ #endif BOOL ERCON; /* error control */ int ERNUM; /* last error code, 错误提示类型编码已定义有29种。 */ int NTRY; /* no. of tries for probablistic primality testing */ #ifndef MR_SIMPLE_IO int INPLEN; /* input length */ #ifndef MR_SIMPLE_BASE int IOBASE; /* base for input and output */ #endif #endif #ifdef MR_FLASH BOOL EXACT; /* exact flag */ BOOL RPOINT; /* =ON for radix point, =OFF for fractions in output */ #endif #ifndef MR_STRIPPED_DOWN BOOL TRACER; /* turns trace tracker on/off */ #endif #ifdef MR_STATIC const int *PRIMES; /* small primes array */ #ifndef MR_SIMPLE_IO char IOBUFF[MR_DEFAULT_BUFFER_SIZE]; /* i/o buffer */ #endif #else int *PRIMES; /* small primes array */ #ifndef MR_SIMPLE_IO char *IOBUFF; /* i/o buffer */ #endif #endif #ifdef MR_FLASH int workprec; int stprec; /* start precision */ int RS,RD; double D; double db,n,p; int a,b,c,d,r,q,oldn,ndig; mr_small u,v,ku,kv; BOOL last,carryon; flash pi; #endif #ifdef MR_FP_ROUNDING mr_large inverse_base; #endif #ifndef MR_STATIC char *workspace; #else char workspace[MR_BIG_RESERVE(MR_SPACES)]; #endif int TWIST; /* set to twisted curve */ int qnr; /* a QNR -1 for p=3 mod 4, -2 for p=5 mod 8, 0 otherwise */ int cnr; /* a cubic non-residue */ int pmod8; int pmod9; BOOL NO_CARRY; } miracl; mr_mip->ERNUM错误提示码mr_berror已定义有29种。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/mrarth0/mr_psub.html":{"url":"miracldoc/api/mrarth0/mr_psub.html","title":"mr_psub","keywords":"","body":"mr_psub mr_psub extern void mr_psub(_MIPT_ big,big,big); void mr_psub(_MIPD_ big x,big y,big z) { /* subtract two big numbers z=x-y * * where x and y are positive and x>y */ int i,lx,ly; mr_small borrow,pdiff; mr_small *gx,*gy,*gz; #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif lx = (int)x->len; ly = (int)y->len; if (ly>lx) { mr_berror(_MIPP_ MR_ERR_NEG_RESULT); return; } if (y!=z) copy(x,z); else ly=lx; z->len=lx; gx=x->w; gy=y->w; gz=z->w; borrow=0; #ifndef MR_SIMPLE_BASE if (mr_mip->base==0) { #endif for (i=0;i0;i++) { /* subtract by columns */ if (i>lx) { mr_berror(_MIPP_ MR_ERR_NEG_RESULT); return; } pdiff=gx[i]-gy[i]-borrow; if (pdiffgx[i]) borrow=1; gz[i]=pdiff; } #ifndef MR_SIMPLE_BASE } else for (i=0;i0;i++) { /* subtract by columns */ if (i>lx) { mr_berror(_MIPP_ MR_ERR_NEG_RESULT); return; } pdiff=gy[i]+borrow; borrow=0; if (gx[i]>=pdiff) pdiff=gx[i]-pdiff; else { /* set borrow */ pdiff=mr_mip->base+gx[i]-pdiff; borrow=1; } gz[i]=pdiff; } #endif mr_lzero(z); } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/mrarth1/mr_invert.html":{"url":"miracldoc/api/mrarth1/mr_invert.html","title":"mr_invert","keywords":"","body":"mr_invert mr_invert #ifdef MR_FP_ROUNDING extern mr_large mr_invert(mr_small); #endif /* Invert n and set FP rounding. * Set to round up * Calculate 1/n * set to round down (towards zero) * If rounding cannot be controlled, this function returns 0.0 */ mr_large mr_invert(mr_small n) { mr_large inn; int up= 0x1BFF; #ifdef _MSC_VER #ifdef MR_NOASM #define NO_EXTENDED #endif #endif #ifdef NO_EXTENDED int down=0x1EFF; #else int down=0x1FFF; #endif #ifdef __TURBOC__ asm { fldcw WORD PTR up fld1 fld QWORD PTR n; fdiv fstp TBYTE PTR inn; fldcw WORD PTR down; } return inn; #endif #ifdef _MSC_VER _asm { fldcw WORD PTR up fld1 fld QWORD PTR n; fdiv fstp QWORD PTR inn; fldcw WORD PTR down; } return inn; #endif #ifdef __GNUC__ #ifdef i386 __asm__ __volatile__ ( \"fldcw %2\\n\" \"fld1\\n\" \"fldl %1\\n\" \"fdivrp\\n\" \"fstpt %0\\n\" \"fldcw %3\\n\" : \"=m\"(inn) : \"m\"(n),\"m\"(up),\"m\"(down) : \"memory\" ); return inn; #else fpsetround(FP_RP); inn=(mr_large)1.0/n; fpsetround(FP_RZ); return inn; #endif #endif return 0.0L; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/mrarth1/mr_pmul.html":{"url":"miracldoc/api/mrarth1/mr_pmul.html","title":"mr_pmul","keywords":"","body":"mr_pmul mr_pmul extern void mr_pmul(_MIPT_ big,mr_small,big); void mr_pmul(_MIPD_ big x,mr_small sn,big z) { int m,xl; mr_lentype sx; mr_small carry,*xg,*zg; #ifdef MR_ITANIUM mr_small tm; #endif #ifdef MR_WIN64 mr_small tm; #endif #ifdef MR_NOASM union doubleword dble; mr_large dbled; mr_large ldres; #endif #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif if (x!=z) { zero(z); if (sn==0) return; } else if (sn==0) { zero(z); return; } m=0; carry=0; sx=x->len&MR_MSBIT; xl=(int)(x->len&MR_OBITS); #ifndef MR_SIMPLE_BASE if (mr_mip->base==0) { #endif #ifndef MR_NOFULLWIDTH xg=x->w; zg=z->w; /* inline 8086 assembly - substitutes for loop below */ #ifdef INLINE_ASM #if INLINE_ASM == 1 ASM cld ASM mov cx,xl ASM or cx,cx ASM je out1 #ifdef MR_LMM ASM push ds ASM push es ASM les di,DWORD PTR zg ASM lds si,DWORD PTR xg #else ASM mov ax,ds ASM mov es,ax ASM mov di,zg ASM mov si,xg #endif ASM mov bx,sn ASM push bp ASM xor bp,bp tcl1: ASM lodsw ASM mul bx ASM add ax,bp ASM adc dx,0 ASM stosw ASM mov bp,dx ASM loop tcl1 ASM mov ax,bp ASM pop bp #ifdef MR_LMM ASM pop es ASM pop ds #endif ASM mov carry,ax out1: #endif #if INLINE_ASM == 2 ASM cld ASM mov cx,xl ASM or cx,cx ASM je out1 #ifdef MR_LMM ASM push ds ASM push es ASM les di,DWORD PTR zg ASM lds si,DWORD PTR xg #else ASM mov ax,ds ASM mov es,ax ASM mov di,zg ASM mov si,xg #endif ASM mov ebx,sn ASM push ebp ASM xor ebp,ebp tcl1: ASM lodsd ASM mul ebx ASM add eax,ebp ASM adc edx,0 ASM stosd ASM mov ebp,edx ASM loop tcl1 ASM mov eax,ebp ASM pop ebp #ifdef MR_LMM ASM pop es ASM pop ds #endif ASM mov carry,eax out1: #endif #if INLINE_ASM == 3 ASM mov ecx,xl ASM or ecx,ecx ASM je out1 ASM mov ebx,sn ASM mov edi,zg ASM mov esi,xg ASM push ebp ASM xor ebp,ebp tcl1: ASM mov eax,[esi] ASM add esi,4 ASM mul ebx ASM add eax,ebp ASM adc edx,0 ASM mov [edi],eax ASM add edi,4 ASM mov ebp,edx ASM dec ecx ASM jnz tcl1 ASM mov eax,ebp ASM pop ebp ASM mov carry,eax out1: #endif #if INLINE_ASM == 4 ASM ( \"movl %4,%%ecx\\n\" \"orl %%ecx,%%ecx\\n\" \"je 1f\\n\" \"movl %3,%%ebx\\n\" \"movl %1,%%edi\\n\" \"movl %2,%%esi\\n\" \"pushl %%ebp\\n\" \"xorl %%ebp,%%ebp\\n\" \"0:\\n\" \"movl (%%esi),%%eax\\n\" \"addl $4,%%esi\\n\" \"mull %%ebx\\n\" \"addl %%ebp,%%eax\\n\" \"adcl $0,%%edx\\n\" \"movl %%eax,(%%edi)\\n\" \"addl $4,%%edi\\n\" \"movl %%edx,%%ebp\\n\" \"decl %%ecx\\n\" \"jnz 0b\\n\" \"movl %%ebp,%%eax\\n\" \"popl %%ebp\\n\" \"movl %%eax,%0\\n\" \"1:\" :\"=m\"(carry) :\"m\"(zg),\"m\"(xg),\"m\"(sn),\"m\"(xl) :\"eax\",\"edi\",\"esi\",\"ebx\",\"ecx\",\"edx\",\"memory\" ); #endif #endif #ifndef INLINE_ASM for (m=0;mw[m]*sn+carry; carry=dble.h[MR_TOP]; z->w[m]=dble.h[MR_BOT]; } #else carry=muldvd(x->w[m],sn,carry,&z->w[m]); #endif #endif if (carry>0) { m=xl; if (m>=mr_mip->nib && mr_mip->check) { mr_berror(_MIPP_ MR_ERR_OVERFLOW); return; } z->w[m]=carry; z->len=m+1; } else z->len=xl; #endif #ifndef MR_SIMPLE_BASE } else while (m0) { /* multiply each digit of x by n */ if (m>mr_mip->nib && mr_mip->check) { mr_berror(_MIPP_ MR_ERR_OVERFLOW); return; } #ifdef MR_NOASM dbled=(mr_large)x->w[m]*sn+carry; #ifdef MR_FP_ROUNDING carry=(mr_small)MR_LROUND(dbled*mr_mip->inverse_base); #else #ifndef MR_FP if (mr_mip->base==mr_mip->base2) carry=(mr_small)(dbled>>mr_mip->lg2b); else #endif carry=(mr_small)MR_LROUND(dbled/mr_mip->base); #endif z->w[m]=(mr_small)(dbled-(mr_large)carry*mr_mip->base); #else #ifdef MR_FP_ROUNDING carry=imuldiv(x->w[m],sn,carry,mr_mip->base,mr_mip->inverse_base,&z->w[m]); #else carry=muldiv(x->w[m],sn,carry,mr_mip->base,&z->w[m]); #endif #endif m++; z->len=m; } #endif if (z->len!=0) z->len|=sx; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/mrarth1/mr_sdiv.html":{"url":"miracldoc/api/mrarth1/mr_sdiv.html","title":"mr_sdiv","keywords":"","body":"mr_sdiv mr_sdiv定义在miracl.h #ifdef MR_FP_ROUNDING extern mr_small mr_sdiv(_MIPT_ big,mr_small,mr_large,big); #else extern mr_small mr_sdiv(_MIPT_ big,mr_small,big); #endif ```c #ifdef MR_FP_ROUNDING mr_small mr_sdiv(_MIPD_ big x,mr_small sn,mr_large isn,big z) #else mr_small mr_sdiv(_MIPD_ big x,mr_small sn,big z) #endif { int i,xl; mr_small sr,*xg,*zg; #ifdef MR_NOASM union doubleword dble; mr_large dbled; mr_large ldres; #endif #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif sr=0; xl=(int)(x->len&MR_OBITS); if (x!=z) zero(z); #ifndef MR_SIMPLE_BASE if (mr_mip->base==0) { #endif #ifndef MR_NOFULLWIDTH xg=x->w; zg=z->w; /* inline - substitutes for loop below */ #ifdef INLINE_ASM #if INLINE_ASM == 1 ASM std ASM mov cx,xl ASM or cx,cx ASM je out2 ASM mov bx,cx ASM shl bx,1 ASM sub bx,2 #ifdef MR_LMM ASM push ds ASM push es ASM les di,DWORD PTR zg ASM lds si,DWORD PTR xg #else ASM mov ax,ds ASM mov es,ax ASM mov di,zg ASM mov si,xg #endif ASM add si,bx ASM add di,bx ASM mov bx,sn ASM push bp ASM xor bp,bp tcl2: ASM mov dx,bp ASM lodsw ASM div bx ASM mov bp,dx ASM stosw ASM loop tcl2 ASM mov ax,bp ASM pop bp #ifdef MR_LMM ASM pop es ASM pop ds #endif ASM mov sr,ax out2: ASM cld #endif #if INLINE_ASM == 2 ASM std ASM mov cx,xl ASM or cx,cx ASM je out2 ASM mov bx,cx ASM shl bx,2 ASM sub bx,4 #ifdef MR_LMM ASM push ds ASM push es ASM les di,DWORD PTR zg ASM lds si,DWORD PTR xg #else ASM mov ax,ds ASM mov es,ax ASM mov di, zg ASM mov si, xg #endif ASM add si,bx ASM add di,bx ASM mov ebx,sn ASM push ebp ASM xor ebp,ebp tcl2: ASM mov edx,ebp ASM lodsd ASM div ebx ASM mov ebp,edx ASM stosd ASM loop tcl2 ASM mov eax,ebp ASM pop ebp #ifdef MR_LMM ASM pop es ASM pop ds #endif ASM mov sr,eax out2: ASM cld #endif #if INLINE_ASM == 3 ASM mov ecx,xl ASM or ecx,ecx ASM je out2 ASM mov ebx,ecx ASM shl ebx,2 ASM mov esi, xg ASM add esi,ebx ASM mov edi, zg ASM add edi,ebx ASM mov ebx,sn ASM push ebp ASM xor ebp,ebp tcl2: ASM sub esi,4 ASM mov edx,ebp ASM mov eax,[esi] ASM div ebx ASM sub edi,4 ASM mov ebp,edx ASM mov [edi],eax ASM dec ecx ASM jnz tcl2 ASM mov eax,ebp ASM pop ebp ASM mov sr,eax out2: ASM nop #endif #if INLINE_ASM == 4 ASM ( \"movl %4,%%ecx\\n\" \"orl %%ecx,%%ecx\\n\" \"je 3f\\n\" \"movl %%ecx,%%ebx\\n\" \"shll $2,%%ebx\\n\" \"movl %2,%%esi\\n\" \"addl %%ebx,%%esi\\n\" \"movl %1,%%edi\\n\" \"addl %%ebx,%%edi\\n\" \"movl %3,%%ebx\\n\" \"pushl %%ebp\\n\" \"xorl %%ebp,%%ebp\\n\" \"2:\\n\" \"subl $4,%%esi\\n\" \"movl %%ebp,%%edx\\n\" \"movl (%%esi),%%eax\\n\" \"divl %%ebx\\n\" \"subl $4,%%edi\\n\" \"movl %%edx,%%ebp\\n\" \"movl %%eax,(%%edi)\\n\" \"decl %%ecx\\n\" \"jnz 2b\\n\" \"movl %%ebp,%%eax\\n\" \"popl %%ebp\\n\" \"movl %%eax,%0\\n\" \"3:\" \"nop\" :\"=m\"(sr) :\"m\"(zg),\"m\"(xg),\"m\"(sn),\"m\"(xl) :\"eax\",\"edi\",\"esi\",\"ebx\",\"ecx\",\"edx\",\"memory\" ); #endif #endif #ifndef INLINE_ASM for (i=xl-1;i>=0;i--) { #ifdef MR_NOASM dble.h[MR_BOT]=x->w[i]; dble.h[MR_TOP]=sr; z->w[i]=(mr_small)(dble.d/sn); sr=(mr_small)(dble.d-(mr_large)z->w[i]*sn); #else z->w[i]=muldvm(sr,x->w[i],sn,&sr); #endif } #endif #endif #ifndef MR_SIMPLE_BASE } else for (i=xl-1;i>=0;i--) { /* divide each digit of x by n */ #ifdef MR_NOASM dbled=(mr_large)sr*mr_mip->base+x->w[i]; #ifdef MR_FP_ROUNDING z->w[i]=(mr_small)MR_LROUND(dbled*isn); #else z->w[i]=(mr_small)MR_LROUND(dbled/sn); #endif sr=(mr_small)(dbled-(mr_large)z->w[i]*sn); #else #ifdef MR_FP_ROUNDING z->w[i]=imuldiv(sr,mr_mip->base,x->w[i],sn,isn,&sr); #else z->w[i]=muldiv(sr,mr_mip->base,x->w[i],sn,&sr); #endif #endif } #endif z->len=x->len; mr_lzero(z); return sr; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-19 "},"miracldoc/api/mrarth1/remain.html":{"url":"miracldoc/api/mrarth1/remain.html","title":"remain","keywords":"","body":"remain remain extern int remain(_MIPT_ big,int); int remain(_MIPD_ big x,int n) { /* return integer remainder when x divided by n */ int r; mr_lentype sx; #ifdef MR_FP mr_small dres; #endif #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif if (mr_mip->ERNUM) return FALSE; MR_IN(88); sx=(x->len&MR_MSBIT); if (n==2 && MR_REMAIN(mr_mip->base,2)==0) { /* fast odd/even check if base is even */ MR_OUT if ((int)MR_REMAIN(x->w[0],2)==0) return 0; else { if (sx==0) return 1; else return (-1); } } if (n==8 && MR_REMAIN(mr_mip->base,8)==0) { /* fast check */ MR_OUT r=(int)MR_REMAIN(x->w[0],8); if (sx!=0) r=-r; return r; } copy(x,mr_mip->w0); r=subdiv(_MIPP_ mr_mip->w0,n,mr_mip->w0); MR_OUT return r; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/mrarth2/divide.html":{"url":"miracldoc/api/mrarth2/divide.html","title":"divide","keywords":"","body":"divide divide定义在miracl.h extern void divide(_MIPT_ big,big,big); 函数功能：两个数相除，如果divide(x,y,x)，返回z=x/y的商；如果divide(x,y,y)，返回x=x mod y余数。 参数_MIPD_：可能为空，非空为miracl *类型。 参数x：big类型数值。 参数y：big类型数值。 参数z：big类型数值。 源码分析 divide实现在mrarth2.c void divide(_MIPD_ big x,big y,big z) { /* divide two big numbers z=x/y : x=x mod y * * returns quotient only if divide(x,y,x) * * returns remainder only if divide(x,y,y) */ mr_small carry,attemp,ldy,sdy,ra,r,d,tst,psum; #ifdef MR_FP mr_small dres; #endif mr_lentype sx,sy,sz; mr_small borrow,dig,*w0g,*yg; int i,k,m,x0,y0,w00; big w0; #ifdef MR_ITANIUM mr_small tm; #endif #ifdef MR_WIN64 mr_small tm; #endif #ifdef MR_NOASM union doubleword dble; mr_large dbled; mr_large ldres; #endif BOOL check; #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif if (mr_mip->ERNUM) return; w0=mr_mip->w0; MR_IN(6) if (x==y) mr_berror(_MIPP_ MR_ERR_BAD_PARAMETERS); #ifdef MR_FLASH if (mr_notint(x) || mr_notint(y)) mr_berror(_MIPP_ MR_ERR_INT_OP); #endif if (y->len==0) mr_berror(_MIPP_ MR_ERR_DIV_BY_ZERO); if (mr_mip->ERNUM) { MR_OUT return; } sx=(x->len&MR_MSBIT); /* extract signs ... */ sy=(y->len&MR_MSBIT); sz=(sx^sy); // 异或运算，按位异或 x->len&=MR_OBITS; /* ... and force operands to positive */ y->len&=MR_OBITS; x0=(int)x->len; y0=(int)y->len; copy(x,w0); w00=(int)w0->len; if (mr_mip->check && (w00-y0+1>mr_mip->nib)) { mr_berror(_MIPP_ MR_ERR_OVERFLOW); MR_OUT return; } d=0; if (x0==y0) { if (x0==1) /* special case - x and y are both mr_smalls */ { d=MR_DIV(w0->w[0],y->w[0]); w0->w[0]=MR_REMAIN(w0->w[0],y->w[0]); mr_lzero(w0); } else if (MR_DIV(w0->w[x0-1],4)w[x0-1]) while (mr_compare(w0,y)>=0) { /* mr_small quotient - so do up to four subtracts instead */ mr_psub(_MIPP_ w0,y,w0); d++; } } if (mr_compare(w0,y)len!=0) x->len|=sx; } if (y!=z) { zero(z); z->w[0]=d; if (d>0) z->len=(sz|1); } y->len|=sy; MR_OUT return; } if (y0==1) { /* y is int - so use subdiv instead */ #ifdef MR_FP_ROUNDING r=mr_sdiv(_MIPP_ w0,y->w[0],mr_invert(y->w[0]),w0); #else r=mr_sdiv(_MIPP_ w0,y->w[0],w0); #endif if (y!=z) { copy(w0,z); z->len|=sz; } if (x!=z) { zero(x); x->w[0]=r; if (r>0) x->len=(sx|1); } y->len|=sy; MR_OUT return; } if (y!=z) zero(z); d=normalise(_MIPP_ y,y); check=mr_mip->check; mr_mip->check=OFF; #ifndef MR_SIMPLE_BASE if (mr_mip->base==0) { #endif #ifndef MR_NOFULLWIDTH if (d!=1) mr_pmul(_MIPP_ w0,d,w0); ldy=y->w[y0-1]; sdy=y->w[y0-2]; w0g=w0->w; yg=y->w; for (k=w00-1;k>=y0-1;k--) { /* long division */ #ifdef INLINE_ASM #if INLINE_ASM == 1 #ifdef MR_LMM ASM push ds ASM lds bx,DWORD PTR w0g #else ASM mov bx,w0g #endif ASM mov si,k ASM shl si,1 ASM add bx,si ASM mov dx,[bx+2] ASM mov ax,[bx] ASM cmp dx,ldy ASM jne tcl8 ASM mov di,0xffff ASM mov si,ax ASM add si,ldy ASM jc tcl12 ASM jmp tcl10 tcl8: ASM div WORD PTR ldy ASM mov di,ax ASM mov si,dx tcl10: ASM mov ax,sdy ASM mul di ASM cmp dx,si ASM jb tcl12 ASM jne tcl11 ASM cmp ax,[bx-2] ASM jbe tcl12 tcl11: ASM dec di ASM add si,ldy ASM jnc tcl10 tcl12: ASM mov attemp,di #ifdef MR_LMM ASM pop ds #endif #endif /* NOTE push and pop of esi/edi should not be necessary - Borland C bug * * These pushes are needed here even if register variables are disabled */ #if INLINE_ASM == 2 ASM push esi ASM push edi #ifdef MR_LMM ASM push ds ASM lds bx,DWORD PTR w0g #else ASM mov bx,w0g #endif ASM mov si,k ASM shl si,2 ASM add bx,si ASM mov edx,[bx+4] ASM mov eax,[bx] ASM cmp edx,ldy ASM jne tcl8 ASM mov edi,0xffffffff ASM mov esi,eax ASM add esi,ldy ASM jc tcl12 ASM jmp tcl10 tcl8: ASM div DWORD PTR ldy ASM mov edi,eax ASM mov esi,edx tcl10: ASM mov eax,sdy ASM mul edi ASM cmp edx,esi ASM jb tcl12 ASM jne tcl11 ASM cmp eax,[bx-4] ASM jbe tcl12 tcl11: ASM dec edi ASM add esi,ldy ASM jnc tcl10 tcl12: ASM mov attemp,edi #ifdef MR_LMM ASM pop ds #endif ASM pop edi ASM pop esi #endif #if INLINE_ASM == 3 ASM push esi ASM push edi ASM mov ebx,w0g ASM mov esi,k ASM shl esi,2 ASM add ebx,esi ASM mov edx,[ebx+4] ASM mov eax,[ebx] ASM cmp edx,ldy ASM jne tcl8 ASM mov edi,0xffffffff ASM mov esi,eax ASM add esi,ldy ASM jc tcl12 ASM jmp tcl10 tcl8: ASM div DWORD PTR ldy ASM mov edi,eax ASM mov esi,edx tcl10: ASM mov eax,sdy ASM mul edi ASM cmp edx,esi ASM jb tcl12 ASM jne tcl11 ASM cmp eax,[ebx-4] ASM jbe tcl12 tcl11: ASM dec edi ASM add esi,ldy ASM jnc tcl10 tcl12: ASM mov attemp,edi ASM pop edi ASM pop esi #endif #if INLINE_ASM == 4 ASM ( \"movl %1,%%ebx\\n\" \"movl %2,%%esi\\n\" \"shll $2,%%esi\\n\" \"addl %%esi,%%ebx\\n\" \"movl 4(%%ebx),%%edx\\n\" \"movl (%%ebx),%%eax\\n\" \"cmpl %3,%%edx\\n\" \"jne tcl8\\n\" \"movl $0xffffffff,%%edi\\n\" \"movl %%eax,%%esi\\n\" \"addl %3,%%esi\\n\" \"jc tcl12\\n\" \"jmp tcl10\\n\" \"tcl8:\\n\" \"divl %3\\n\" \"movl %%eax,%%edi\\n\" \"movl %%edx,%%esi\\n\" \"tcl10:\\n\" \"movl %4,%%eax\\n\" \"mull %%edi\\n\" \"cmpl %%esi,%%edx\\n\" \"jb tcl12\\n\" \"jne tcl11\\n\" \"cmpl -4(%%ebx),%%eax\\n\" \"jbe tcl12\\n\" \"tcl11:\\n\" \"decl %%edi\\n\" \"addl %3,%%esi\\n\" \"jnc tcl10\\n\" \"tcl12:\\n\" \"movl %%edi,%0\\n\" :\"=m\"(attemp) :\"m\"(w0g),\"m\"(k),\"m\"(ldy),\"m\"(sdy) :\"eax\",\"edi\",\"esi\",\"ebx\",\"ecx\",\"edx\",\"memory\" ); #endif #endif #ifndef INLINE_ASM carry=0; if (w0->w[k+1]==ldy) /* guess next quotient digit */ { attemp=(mr_small)(-1); ra=ldy+w0->w[k]; if (raw[k]; dble.h[MR_TOP]=w0->w[k+1]; attemp=(mr_small)(dble.d/ldy); ra=(mr_small)(dble.d-(mr_large)attemp*ldy); } #else else attemp=muldvm(w0->w[k+1],w0->w[k],ldy,&ra); #endif while (carry==0) { #ifdef MR_NOASM dble.d=(mr_large)attemp*sdy; r=dble.h[MR_BOT]; tst=dble.h[MR_TOP]; #else tst=muldvd(sdy,attemp,(mr_small)0,&r); #endif if (tstw[k-1])) break; attemp--; /* refine guess */ ra+=ldy; if (ra0) { /* do partial subtraction */ borrow=0; /* inline - substitutes for loop below */ #ifdef INLINE_ASM #if INLINE_ASM == 1 ASM cld ASM mov cx,y0 ASM mov si,m ASM shl si,1 ASM mov di,attemp #ifdef MR_LMM ASM push ds ASM push es ASM les bx,DWORD PTR w0g ASM add bx,si ASM sub bx,2 ASM lds si,DWORD PTR yg #else ASM mov bx,w0g ASM add bx,si ASM sub bx,2 ASM mov si,yg #endif ASM push bp ASM xor bp,bp tcl3: ASM lodsw ASM mul di ASM add ax,bp ASM adc dx,0 ASM inc bx ASM inc bx #ifdef MR_LMM ASM sub es:[bx],ax #else ASM sub [bx],ax #endif ASM adc dx,0 ASM mov bp,dx ASM loop tcl3 ASM mov ax,bp ASM pop bp #ifdef MR_LMM ASM pop es ASM pop ds #endif ASM mov borrow,ax #endif /* NOTE push and pop of esi/edi should not be necessary - Borland C bug * * These pushes are needed here even if register variables are disabled */ #if INLINE_ASM == 2 ASM push esi ASM push edi ASM cld ASM mov cx,y0 ASM mov si,m ASM shl si,2 ASM mov edi,attemp #ifdef MR_LMM ASM push ds ASM push es ASM les bx,DWORD PTR w0g ASM add bx,si ASM sub bx,4 ASM lds si,DWORD PTR yg #else ASM mov bx,w0g ASM add bx,si ASM sub bx,4 ASM mov si,yg #endif ASM push ebp ASM xor ebp,ebp tcl3: ASM lodsd ASM mul edi ASM add eax,ebp ASM adc edx,0 ASM add bx,4 #ifdef MR_LMM ASM sub es:[bx],eax #else ASM sub [bx],eax #endif ASM adc edx,0 ASM mov ebp,edx ASM loop tcl3 ASM mov eax,ebp ASM pop ebp #ifdef MR_LMM ASM pop es ASM pop ds #endif ASM mov borrow,eax ASM pop edi ASM pop esi #endif #if INLINE_ASM == 3 ASM push esi ASM push edi ASM mov ecx,y0 ASM mov esi,m ASM shl esi,2 ASM mov edi,attemp ASM mov ebx,w0g ASM add ebx,esi ASM mov esi,yg ASM sub ebx,esi ASM sub ebx,4 ASM push ebp ASM xor ebp,ebp tcl3: ASM mov eax,[esi] ASM add esi,4 ASM mul edi ASM add eax,ebp ASM mov ebp,[esi+ebx] ASM adc edx,0 ASM sub ebp,eax ASM adc edx,0 ASM mov [esi+ebx],ebp ASM dec ecx ASM mov ebp,edx ASM jnz tcl3 ASM mov eax,ebp ASM pop ebp ASM mov borrow,eax ASM pop edi ASM pop esi #endif #if INLINE_ASM == 4 ASM ( \"movl %1,%%ecx\\n\" \"movl %2,%%esi\\n\" \"shll $2,%%esi\\n\" \"movl %3,%%edi\\n\" \"movl %4,%%ebx\\n\" \"addl %%esi,%%ebx\\n\" \"movl %5,%%esi\\n\" \"subl %%esi,%%ebx\\n\" \"subl $4,%%ebx\\n\" \"pushl %%ebp\\n\" \"xorl %%ebp,%%ebp\\n\" \"tcl3:\\n\" \"movl (%%esi),%%eax\\n\" \"addl $4,%%esi\\n\" \"mull %%edi\\n\" \"addl %%ebp,%%eax\\n\" \"movl (%%esi,%%ebx),%%ebp\\n\" \"adcl $0,%%edx\\n\" \"subl %%eax,%%ebp\\n\" \"adcl $0,%%edx\\n\" \"movl %%ebp,(%%esi,%%ebx)\\n\" \"decl %%ecx\\n\" \"movl %%edx,%%ebp\\n\" \"jnz tcl3\\n\" \"movl %%ebp,%%eax\\n\" \"popl %%ebp\\n\" \"movl %%eax,%0\\n\" :\"=m\"(borrow) :\"m\"(y0),\"m\"(m),\"m\"(attemp),\"m\"(w0g),\"m\"(yg) :\"eax\",\"edi\",\"esi\",\"ebx\",\"ecx\",\"edx\",\"memory\" ); #endif #endif #ifndef INLINE_ASM for (i=0;iw[i]+borrow; dig=dble.h[MR_BOT]; borrow=dble.h[MR_TOP]; #else borrow=muldvd(attemp,y->w[i],borrow,&dig); #endif if (w0->w[m+i]w[m+i]-=dig; } #endif if (w0->w[k+1]w[k+1]=0; carry=0; for (i=0;iw[m+i]+y->w[i]+carry; if (psum>y->w[i]) carry=0; if (psumw[i]) carry=1; w0->w[m+i]=psum; } attemp--; /* ... and adjust guess */ } else w0->w[k+1]-=borrow; } if (k==w00-1 && attemp==0) w00--; else if (y!=z) z->w[m]=attemp; } #endif #ifndef MR_SIMPLE_BASE } else { /* have to do it the hard way */ if (d!=1) mr_pmul(_MIPP_ w0,d,w0); ldy=y->w[y0-1]; sdy=y->w[y0-2]; for (k=w00-1;k>=y0-1;k--) { /* long division */ if (w0->w[k+1]==ldy) /* guess next quotient digit */ { attemp=mr_mip->base-1; ra=ldy+w0->w[k]; } #ifdef MR_NOASM else { dbled=(mr_large)w0->w[k+1]*mr_mip->base+w0->w[k]; attemp=(mr_small)MR_LROUND(dbled/ldy); ra=(mr_small)(dbled-(mr_large)attemp*ldy); } #else else attemp=muldiv(w0->w[k+1],mr_mip->base,w0->w[k],ldy,&ra); #endif while (rabase) { #ifdef MR_NOASM dbled=(mr_large)sdy*attemp; #ifdef MR_FP_ROUNDING tst=(mr_small)MR_LROUND(dbled*mr_mip->inverse_base); #else #ifndef MR_FP if (mr_mip->base==mr_mip->base2) tst=(mr_small)(dbled>>mr_mip->lg2b); else #endif tst=(mr_small)MR_LROUND(dbled/mr_mip->base); #endif r=(mr_small)(dbled-(mr_large)tst*mr_mip->base); #else #ifdef MR_FP_ROUNDING tst=imuldiv(sdy,attemp,(mr_small)0,mr_mip->base,mr_mip->inverse_base,&r); #else tst=muldiv(sdy,attemp,(mr_small)0,mr_mip->base,&r); #endif #endif if (tstw[k-1])) break; attemp--; /* refine guess */ ra+=ldy; } m=k-y0+1; if (attemp>0) { /* do partial subtraction */ borrow=0; for (i=0;iw[i]+borrow; #ifdef MR_FP_ROUNDING borrow=(mr_small)MR_LROUND(dbled*mr_mip->inverse_base); #else #ifndef MR_FP if (mr_mip->base==mr_mip->base2) borrow=(mr_small)(dbled>>mr_mip->lg2b); else #endif borrow=(mr_small)MR_LROUND(dbled/mr_mip->base); #endif dig=(mr_small)(dbled-(mr_large)borrow*mr_mip->base); #else #ifdef MR_FP_ROUNDING borrow=imuldiv(attemp,y->w[i],borrow,mr_mip->base,mr_mip->inverse_base,&dig); #else borrow=muldiv(attemp,y->w[i],borrow,mr_mip->base,&dig); #endif #endif if (w0->w[m+i]w[m+i]+=(mr_mip->base-dig); } else w0->w[m+i]-=dig; } if (w0->w[k+1]w[k+1]=0; carry=0; for (i=0;iw[m+i]+y->w[i]+carry; carry=0; if (psum>=mr_mip->base) { carry=1; psum-=mr_mip->base; } w0->w[m+i]=psum; } attemp--; /* ... and adjust guess */ } else w0->w[k+1]-=borrow; } if (k==w00-1 && attemp==0) w00--; else if (y!=z) z->w[m]=attemp; } } #endif if (y!=z) z->len=((w00-y0+1)|sz); /* set sign and length of result */ w0->len=y0; mr_lzero(y); mr_lzero(z); if (x!=z) { mr_lzero(w0); #ifdef MR_FP_ROUNDING if (d!=1) mr_sdiv(_MIPP_ w0,d,mr_invert(d),x); #else if (d!=1) mr_sdiv(_MIPP_ w0,d,x); #endif else copy(w0,x); if (x->len!=0) x->len|=sx; } #ifdef MR_FP_ROUNDING if (d!=1) mr_sdiv(_MIPP_ y,d,mr_invert(d),y); #else if (d!=1) mr_sdiv(_MIPP_ y,d,y); #endif y->len|=sy; mr_mip->check=check; MR_OUT } union doubleword类型定义在miracl.h，两个mr_small与一个mr_large等大。 mr_notint判断参数x是否为flash类型数值，返回TRUE或者FALSE。 MR_DIV计算商，MR_REMAIN计算余数。 mr_berror根据错误类型提示，zero将对象设置位0。 mr_sdiv copy mr_compare比较两个数的大小，如果x大于 y，返回1；如果x小于 y，返回-1；否则返回0。 mr_psub mr_lzero © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/mrarth2/normalise.html":{"url":"miracldoc/api/mrarth2/normalise.html","title":"normalise","keywords":"","body":"normalise normalise extern mr_small normalise(_MIPT_ big,big); mr_small normalise(_MIPD_ big x,big y) { /* normalise divisor */ mr_small norm,r; #ifdef MR_FP mr_small dres; #endif int len; #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif MR_IN(4) if (x!=y) copy(x,y); len=(int)(y->len&MR_OBITS); #ifndef MR_SIMPLE_BASE if (mr_mip->base==0) { #endif #ifndef MR_NOFULLWIDTH if ((r=y->w[len-1]+1)==0) norm=1; #ifdef MR_NOASM else norm=(mr_small)(((mr_large)1 base,(mr_small)(y->w[len-1]+1)); if (norm!=1) mr_pmul(_MIPP_ y,norm,y); } #endif MR_OUT return norm; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/mrcomba/comba_mult.html":{"url":"miracldoc/api/mrcomba/comba_mult.html","title":"comba_mult","keywords":"","body":"comba_mult comba_mult extern void comba_mult(big,big,big); 函数功能： 参数 源码分析 comba_mult在模板文件mrcomba.tpl实现。 /* NOTE! z must be distinct from x and y */ void comba_mult(big x,big y,big z) { /* comba multiplier */ int i; mr_small *a,*b,*c; #ifdef MR_WIN64 mr_small lo,hi,sumlo,sumhi,extra; #endif #ifdef MR_ITANIUM register mr_small lo1,hi1,lo2,hi2,sumlo,sumhi,extra,ma,mb; #else #ifdef MR_NOASM #ifdef mr_qltype mr_large pp1; mr_vlarge sum; #else register mr_small extra,s0,s1; mr_large pp1,pp2,sum; #endif #endif #endif for (i=2*MR_COMBA;ilen&MR_OBITS);i++) z->w[i]=0; z->len=2*MR_COMBA; a=x->w; b=y->w; c=z->w; /*** MULTIPLY ***/ /* multiply a by b, result in c */ if (z->w[2*MR_COMBA-1]==0) mr_lzero(z); } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrcomba/comba_square.html":{"url":"miracldoc/api/mrcomba/comba_square.html","title":"comba_square","keywords":"","body":"comba_square comba_square extern void comba_square(big,big); 函数功能： 参数 源码分析 comba_square在模板文件mrcomba.tpl实现。 /* NOTE! z and x must be distinct */ void comba_square(big x,big z) { /* super comba squarer */ int i; mr_small *a,*c; #ifdef MR_WIN64 mr_small lo,hi,sumlo,sumhi,extra,cy; #endif #ifdef MR_ITANIUM register mr_small lo1,hi1,lo2,hi2,sumlo,sumhi,extra,ma,mb; #endif #ifdef MR_NOASM #ifdef mr_qltype mr_large pp1; mr_vlarge sum; #else register mr_small extra,s0,s1; mr_large pp1,pp2,sum; #endif #endif for (i=2*MR_COMBA;ilen&MR_OBITS);i++) z->w[i]=0; z->len=2*MR_COMBA; a=x->w; c=z->w; /*** SQUARE ***/ /* squares a, result in b */ if (z->w[2*MR_COMBA-1]==0) mr_lzero(z); } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrcomba/comba_redc.html":{"url":"miracldoc/api/mrcomba/comba_redc.html","title":"comba_redc","keywords":"","body":"comba_redc comba_redc extern void comba_redc(_MIPT_ big,big); 函数功能： 参数 源码分析 comba_redc在模板文件mrcomba.tpl实现。 /* NOTE! t and z must be distinct! */ void comba_redc(_MIPD_ big t,big z) { /* super comba Montgomery redc() function */ mr_small carry,su; #ifdef MR_ITANIUM register mr_small lo1,hi1,lo2,hi2,sumlo,sumhi,extra,ma,mb,sp,u; #endif #ifdef MR_WIN64 mr_small lo,hi,sumlo,sumhi,extra,ma,mb,u; #endif #ifdef MR_NOASM mr_large u; #ifndef MR_SPECIAL #ifdef mr_qltype register mr_small sp; mr_large pp1; mr_vlarge sum; #else register mr_small sp,extra,s0,s1; mr_large pp1,pp2,sum; #endif #endif #endif unsigned int i; big w,modulus; mr_small *a,*b; #ifndef MR_SPECIAL BOOL need_subtract; mr_small ndash; #endif #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif #ifdef MR_SPECIAL /* !!! Implement here a \"special\" fast method for modular reduction, for a particular modulus. Implemented here for 2^192-2^64-1 and 2^224-2^96+1 on a 32 bit processor. See for example \"Software Implementation of the NIST Elliptic Curves Over Prime Fields\", Brown et al., Report #36, 2000 available from www.cacr.math.uwaterloo.ca The generated code can be manually optimised further..... */ int overshoot; mr_small k[MR_COMBA],sn,tt,v; #ifdef MR_PSEUDO_MERSENNE_142 mr_small sh,sl; #endif mr_small *c; modulus=mr_mip->modulus; for (i=MR_COMBA;ilen&MR_OBITS);i++) z->w[i]=0; /* zero(z); */ z->len=MR_COMBA; #ifdef MR_PSEUDO_MERSENNE_142 #if MIRACL==32 /* special code for 2^142-111 */ sn=111; sh=t->w[4]>>14; t->w[4]&=0x3FFF; sl=t->w[5]>>14; t->w[5]w[5]|=sh; sh=t->w[6]>>14; t->w[6]w[6]|=sl; sl=t->w[7]>>14; t->w[7]w[7]|=sh; sh=t->w[8]>>14; t->w[8]w[8]|=sl; t->w[9]=sh; a=&(t->w[5]); b=k; c=z->w; /*** PMULT ***/ a=c; k[0]=(c[4]>>14)*111; c[4]&=0x3FFF; /*** INCREMENT ***/ b=t->w; /*** INCREMENT ***/ b=modulus->w; while (z->w[4]>>14) { /*** DECREMENT ***/ } if (z->w[MR_COMBA-1]>=modulus->w[MR_COMBA-1]) { if (mr_compare(z,modulus)>=0) { /*** DECREMENT ***/ } } if (z->w[MR_COMBA-1]==0) mr_lzero(z); #endif #if MIRACL==64 sn=111; sh=t->w[2]>>14; t->w[2]&=0x3FFF; sl=t->w[3]>>14; t->w[3]w[3]|=sh; sh=t->w[4]>>14; t->w[4]w[4]|=sl; t->w[5]=sh; a=&(t->w[3]); b=k; c=z->w; /*** PMULT ***/ a=c; k[0]=(c[2]>>14)*111; c[2]&=0x3FFF; /*** INCREMENT ***/ b=t->w; /*** INCREMENT ***/ b=modulus->w; while (z->w[2]>>14) { /*** DECREMENT ***/ } if (z->w[MR_COMBA-1]>=modulus->w[MR_COMBA-1]) { if (mr_compare(z,modulus)>=0) { /*** DECREMENT ***/ } } if (z->w[MR_COMBA-1]==0) mr_lzero(z); #endif #endif #ifdef MR_PSEUDO_MERSENNE sn=(mr_small)0-modulus->w[0]; /* Modulus is 2^{MIRACL*MR_COMBA}-c. Here we calculate c */ /* .. where c MUST be a word sized ... */ a=&(t->w[MR_COMBA]); b=k; c=z->w; /*** PMULT ***/ a=c; /*** INCREMENT ***/ overshoot=carry; b=t->w; /*** INCREMENT ***/ overshoot+=carry; b=modulus->w; while(overshoot>0) { /*** DECREMENT ***/ overshoot-=carry; } if (z->w[MR_COMBA-1]>=modulus->w[MR_COMBA-1]) { if (mr_compare(z,modulus)>=0) { /*** DECREMENT ***/ } } if (z->w[MR_COMBA-1]==0) mr_lzero(z); #endif #ifdef MR_GENERALIZED_MERSENNE #if MIRACL==64 #if MR_COMBA == 3 /* Special Code for 2^192-2^64-1 - assuming 64-bit processor */ a=t->w; b=k; c=z->w; k[0]=k[1]=a[3]; k[2]=0; /*** ADDITION ***/ overshoot=carry; a=c; c=t->w; k[0]=0;k[1]=k[2]=c[4]; /*** INCREMENT ***/ overshoot+=carry; k[0]=k[1]=k[2]=c[5]; /*** INCREMENT ***/ overshoot+=carry; b=modulus->w; while(overshoot>0) { /*** DECREMENT ***/ overshoot-=carry; } if (z->w[MR_COMBA-1]>=modulus->w[MR_COMBA-1]) { if (mr_compare(z,modulus)>=0) { /*** DECREMENT ***/ } } if (z->w[MR_COMBA-1]==0) mr_lzero(z); #endif #if MR_COMBA == 2 /* Special code for 2^127-1 - for 64-bit processor */ a=t->w; k[0]=a[2]; k[1]=a[3]; a=b=k; /*** INCREMENT ***/ a=t->w; k[0]+=(a[1]>>63); k[1]|=(a[1]&0x8000000000000000); c=z->w; /*** ADDITION ***/ a=z->w; b=modulus->w; if (z->w[1]>=modulus->w[1]) { if (mr_compare(z,modulus)>=0) { /*** DECREMENT ***/ } } if (z->w[MR_COMBA-1]==0) mr_lzero(z); #endif #if MR_COMBA == 9 /* Special Code for 2^521-1 - assuming 64-bit processor */ /* split t into 521-bit halves, low half in a, high half in b */ a=t->w; b=k; c=z->w; for (i=0;i>9)|(a[i+9]>9)w; b=modulus->w; if (z->w[MR_COMBA-1]>=modulus->w[MR_COMBA-1]) { if (mr_compare(z,modulus)>=0) { /*** DECREMENT ***/ } } if (z->w[MR_COMBA-1]==0) mr_lzero(z); #endif #endif #if MIRACL==8 #if MR_COMBA==32 a=t->w; b=k; c=z->w; k[0]=k[1]=k[2]=k[3]=k[4]=k[5]=k[6]=k[7]=k[8]=k[9]=k[10]=k[11]=0; k[12]=a[44]; k[13]=a[45]; k[14]=a[46]; k[15]=a[47]; k[16]=a[48]; k[17]=a[49]; k[18]=a[50]; k[19]=a[51]; k[20]=a[52]; k[21]=a[53]; k[22]=a[54]; k[23]=a[55]; k[24]=a[56]; k[25]=a[57]; k[26]=a[58]; k[27]=a[59]; k[28]=a[60]; k[29]=a[61]; k[30]=a[62]; k[31]=a[63]; /*** ADDITION ***/ overshoot=carry; a=c; c=t->w; /*** INCREMENT ***/ overshoot+=carry; k[0]=k[1]=k[2]=k[3]=k[4]=k[5]=k[6]=k[7]=k[8]=k[9]=k[10]=k[11]=0; k[12]=c[48]; k[13]=c[49]; k[14]=c[50]; k[15]=c[51]; k[16]=c[52]; k[17]=c[53]; k[18]=c[54]; k[19]=c[55]; k[20]=c[56]; k[21]=c[57]; k[22]=c[58]; k[23]=c[59]; k[24]=c[60]; k[25]=c[61]; k[26]=c[62]; k[27]=c[63]; k[28]=k[29]=k[30]=k[31]=0; /*** INCREMENT ***/ overshoot+=carry; /*** INCREMENT ***/ overshoot+=carry; k[0]=c[32]; k[1]=c[33]; k[2]=c[34]; k[3]=c[35]; k[4]=c[36]; k[5]=c[37]; k[6]=c[38]; k[7]=c[39]; k[8]=c[40]; k[9]=c[41]; k[10]=c[42]; k[11]=c[43]; k[12]=k[13]=k[14]=k[15]=k[16]=k[17]=k[18]=k[19]=k[20]=k[21]=k[22]=k[23]=0; k[24]=c[56]; k[25]=c[57]; k[26]=c[58]; k[27]=c[59]; k[28]=c[60]; k[29]=c[61]; k[30]=c[62]; k[31]=c[63]; /*** INCREMENT ***/ overshoot+=carry; k[0]=c[36]; k[1]=c[37]; k[2]=c[38]; k[3]=c[39]; k[4]=c[40]; k[5]=c[41]; k[6]=c[42]; k[7]=c[43]; k[8]=c[44]; k[9]=c[45]; k[10]=c[46]; k[11]=c[47]; k[12]=c[52]; k[13]=c[53]; k[14]=c[54]; k[15]=c[55]; k[16]=c[56]; k[17]=c[57]; k[18]=c[58]; k[19]=c[59]; k[20]=c[60]; k[21]=c[61]; k[22]=c[62]; k[23]=c[63]; k[24]=c[52]; k[25]=c[53]; k[26]=c[54]; k[27]=c[55]; k[28]=c[32]; k[29]=c[33]; k[30]=c[34]; k[31]=c[35]; /*** INCREMENT ***/ overshoot+=carry; k[0]=c[44]; k[1]=c[45]; k[2]=c[46]; k[3]=c[47]; k[4]=c[48]; k[5]=c[49]; k[6]=c[50]; k[7]=c[51]; k[8]=c[52]; k[9]=c[53]; k[10]=c[54]; k[11]=c[55]; k[12]=k[13]=k[14]=k[15]=k[16]=k[17]=k[18]=k[19]=k[20]=k[21]=k[22]=k[23]=0; k[24]=c[32]; k[25]=c[33]; k[26]=c[34]; k[27]=c[35]; k[28]=c[40]; k[29]=c[41]; k[30]=c[42]; k[31]=c[43]; /*** DECREMENT ***/ overshoot-=carry; k[0]=c[48]; k[1]=c[49]; k[2]=c[50]; k[3]=c[51]; k[4]=c[52]; k[5]=c[53]; k[6]=c[54]; k[7]=c[55]; k[8]=c[56]; k[9]=c[57]; k[10]=c[58]; k[11]=c[59]; k[12]=c[60]; k[13]=c[61]; k[14]=c[62]; k[15]=c[63]; k[16]=k[17]=k[18]=k[19]=k[20]=k[21]=k[22]=k[23]=0; k[24]=c[36]; k[25]=c[37]; k[26]=c[38]; k[27]=c[39]; k[28]=c[44]; k[29]=c[45]; k[30]=c[46]; k[31]=c[47]; /*** DECREMENT ***/ overshoot-=carry; k[0]=c[52]; k[1]=c[53]; k[2]=c[54]; k[3]=c[55]; k[4]=c[56]; k[5]=c[57]; k[6]=c[58]; k[7]=c[59]; k[8]=c[60]; k[9]=c[61]; k[10]=c[62]; k[11]=c[63]; k[12]=c[32]; k[13]=c[33]; k[14]=c[34]; k[15]=c[35]; k[16]=c[36]; k[17]=c[37]; k[18]=c[38]; k[19]=c[39]; k[20]=c[40]; k[21]=c[41]; k[22]=c[42]; k[23]=c[43]; k[24]=k[25]=k[26]=k[27]=0; k[28]=c[48]; k[29]=c[49]; k[30]=c[50]; k[31]=c[51]; /*** DECREMENT ***/ overshoot-=carry; k[0]=c[56]; k[1]=c[57]; k[2]=c[58]; k[3]=c[59]; k[4]=c[60]; k[5]=c[61]; k[6]=c[62]; k[7]=c[63]; k[8]=k[9]=k[10]=k[11]=0; k[12]=c[36]; k[13]=c[37]; k[14]=c[38]; k[15]=c[39]; k[16]=c[40]; k[17]=c[41]; k[18]=c[42]; k[19]=c[43]; k[20]=c[44]; k[21]=c[45]; k[22]=c[46]; k[23]=c[47]; k[24]=k[25]=k[26]=k[27]=0; k[28]=c[52]; k[29]=c[53]; k[30]=c[54]; k[31]=c[55]; /*** DECREMENT ***/ overshoot-=carry; b=modulus->w; while (overshoot>0) { /*** DECREMENT ***/ overshoot-=carry; } while (overshootw[MR_COMBA-1]>=modulus->w[MR_COMBA-1]) { if (mr_compare(z,modulus)>=0) { /*** DECREMENT ***/ } } if (z->w[MR_COMBA-1]==0) mr_lzero(z); #endif #if MR_COMBA == 16 /* Special code for 2^127-1 - for 8-bit processor */ a=t->w; k[0]=a[16]; k[1]=a[17]; k[2]=a[18]; k[3]=a[19]; k[4]=a[20]; k[5]=a[21]; k[6]=a[22]; k[7]=a[23]; k[8]=a[24]; k[9]=a[25]; k[10]=a[26]; k[11]=a[27]; k[12]=a[28]; k[13]=a[29]; k[14]=a[30]; k[15]=a[31]; a=b=k; /*** DOUBLEIT ***/ a=t->w; k[0]+=(a[15]>>7); k[15]|=(a[15]&0x80); c=z->w; /*** ADDITION ***/ a=z->w; b=modulus->w; /* if MSB is 1, try and deal with it here */ tt=(mr_small)(z->w[15]>>M1); v=z->w[0]+tt; if (v>=z->w[0]) { z->w[15]-=(mr_small)(ttw[0]=v; } /* This is probably not going to happen now... */ if (z->w[15]>=modulus->w[15]) { if (mr_compare(z,modulus)>=0) { /*** DECREMENT ***/ } } if (z->w[MR_COMBA-1]==0) mr_lzero(z); #endif #if MR_COMBA==20 /* 2^160-2^112+2^64+1 */ /* faster way - keep a[20] to a[39] in registers r2-r21. */ a=t->w; b=k; c=z->w; k[0]=k[8]=a[38]; k[2]=k[4]=k[6]=k[10]=k[12]=0; k[14]=a[20]; k[16]=a[22]; k[18]=a[24]; k[1]=k[9]=a[39]; k[3]=k[5]=k[7]=k[11]=k[13]=0; k[15]=a[21]; k[17]=a[23]; k[19]=a[25]; /*** ADDITION ***/ overshoot=carry; a=c; c=t->w; k[0]=k[2]=k[4]=k[6]=0; k[8]=k[14]=k[16]=c[34]; k[10]=c[36]; k[12]=c[24]; k[18]=0; k[1]=k[3]=k[5]=k[7]=0; k[9]=k[15]=k[17]=c[35]; k[11]=c[37]; k[13]=c[25]; k[19]=0; /*** DECREMENT ***/ overshoot-=carry; k[4]=c[24]; k[6]=k[12]=k[14]=c[32]; k[0]=k[8]=c[20]; k[2]=k[10]=c[22]; k[16]=k[18]=c[36]; k[5]=c[25]; k[7]=k[13]=k[15]=c[33]; k[1]=k[9]=c[21]; k[3]=k[11]=c[23]; k[17]=k[19]=c[37]; /*** DECREMENT ***/ overshoot-=carry; k[0]=k[6]=k[8]=c[26]; k[4]=k[10]=k[12]=c[30]; k[2]=k[14]=k[16]=k[18]=0; k[1]=k[7]=k[9]=c[27]; k[5]=k[11]=k[13]=c[31]; k[3]=k[15]=k[17]=k[19]=0; /*** DECREMENT ***/ overshoot-=carry; k[2]=k[8]=k[10]=c[28]; k[0]=k[4]=k[6]=k[16]=0; k[12]=k[14]=k[18]=c[38]; k[3]=k[9]=k[11]=c[29]; k[1]=k[5]=k[7]=k[17]=0; k[13]=k[15]=k[19]=c[39]; /*** DECREMENT ***/ overshoot-=carry; b=modulus->w; while(overshoot>0) { /*** DECREMENT ***/ overshoot-=carry; } while (overshootw[MR_COMBA-1]>=modulus->w[MR_COMBA-1]) { if (mr_compare(z,modulus)>=0) { /*** DECREMENT ***/ } } if (z->w[MR_COMBA-1]==0) mr_lzero(z); #endif #endif #if MIRACL==16 #if MR_COMBA==10 /* 2^160-2^112+2^64+1 */ a=t->w; b=k; c=z->w; k[0]=k[4]=a[19]; k[1]=k[2]=k[3]=k[5]=k[6]=0; k[7]=a[10]; k[8]=a[11]; k[9]=a[12]; /*** ADDITION ***/ overshoot=carry; a=c; c=t->w; k[0]=k[1]=k[2]=k[3]=0; k[4]=k[7]=k[8]=c[17]; k[5]=c[18]; k[6]=c[12]; k[9]=0; /*** DECREMENT ***/ overshoot-=carry; k[2]=c[12]; k[3]=k[6]=k[7]=c[16]; k[0]=k[4]=c[10]; k[1]=k[5]=c[11]; k[8]=k[9]=c[18]; /*** DECREMENT ***/ overshoot-=carry; k[0]=k[3]=k[4]=c[13]; k[2]=k[5]=k[6]=c[15]; k[1]=k[7]=k[8]=k[9]=0; /*** DECREMENT ***/ overshoot-=carry; k[1]=k[4]=k[5]=c[14]; k[0]=k[2]=k[3]=k[8]=0; k[6]=k[7]=k[9]=c[19]; /*** DECREMENT ***/ overshoot-=carry; b=modulus->w; while(overshoot>0) { /*** DECREMENT ***/ overshoot-=carry; } while (overshootw[MR_COMBA-1]>=modulus->w[MR_COMBA-1]) { if (mr_compare(z,modulus)>=0) { /*** DECREMENT ***/ } } if (z->w[MR_COMBA-1]==0) mr_lzero(z); #endif #endif #if MIRACL==32 #if MR_COMBA == 8 #ifdef MR_NOFULLWIDTH /* Modulus is 2^255-19 - Experimental - not tested! */ w->w=&(t->w[10]); w->len=9; premult(_MIPP_ w,608,w); incr(_MIPP_ w,19*(t->w[9]>>21),w); t->w[9]&=(1len++; z->len=10; for (i=0;iw[i]=t->w[i]; comba_sub(z,w,z); #endif #endif #if MR_COMBA == 4 /* Special code for 2^127-1 - for 32-bit processor */ a=t->w; k[0]=a[4]; k[1]=a[5]; k[2]=a[6]; k[3]=a[7]; a=b=k; /*** DOUBLEIT ***/ a=t->w; k[0]+=(a[3]>>31); k[3]|=(a[3]&0x80000000); c=z->w; /*** ADDITION ***/ a=z->w; b=modulus->w; if (z->w[3]>=modulus->w[3]) { if (mr_compare(z,modulus)>=0) { /*** DECREMENT ***/ } } if (z->w[MR_COMBA-1]==0) mr_lzero(z); #endif #if MR_COMBA == 6 /* Special Code for 2^192-2^64-1 - assuming 32-bit processor */ a=t->w; b=k; c=z->w; k[0]=k[2]=a[6]; k[1]=k[3]=a[7]; k[4]=k[5]=0; /*** ADDITION ***/ overshoot=carry; a=c; c=t->w; k[0]=k[1]=0; k[2]=k[4]=c[8]; k[3]=k[5]=c[9]; /*** INCREMENT ***/ overshoot+=carry; k[0]=k[2]=k[4]=c[10]; k[1]=k[3]=k[5]=c[11]; /*** INCREMENT ***/ overshoot+=carry; b=modulus->w; while(overshoot>0) { /*** DECREMENT ***/ overshoot-=carry; } if (z->w[MR_COMBA-1]>=modulus->w[MR_COMBA-1]) { if (mr_compare(z,modulus)>=0) { /*** DECREMENT ***/ } } if (z->w[MR_COMBA-1]==0) mr_lzero(z); #endif #if MR_COMBA == 7 /* Special Code for 2^224-2^96+1 - assuming 32-bit processor */ a=t->w; b=k; c=z->w; k[0]=k[1]=k[2]=0; k[3]=a[7]; k[4]=a[8]; k[5]=a[9]; k[6]=a[10]; /*** ADDITION ***/ overshoot=carry; a=c; c=t->w; k[0]=k[1]=k[2]=k[6]=0; k[3]=c[11]; k[4]=c[12]; k[5]=c[13]; /*** INCREMENT ***/ overshoot+=carry; k[0]=c[7]; k[1]=c[8]; k[2]=c[9]; k[3]=c[10]; k[4]=c[11]; k[5]=c[12]; k[6]=c[13]; /*** DECREMENT ***/ overshoot-=carry; k[0]=c[11]; k[1]=c[12]; k[2]=c[13]; k[3]=k[4]=k[5]=k[6]=0; /*** DECREMENT ***/ overshoot-=carry; b=modulus->w; while (overshoot>0) { /*** DECREMENT ***/ overshoot-=carry; } while (overshootw[MR_COMBA-1]>=modulus->w[MR_COMBA-1]) { if (mr_compare(z,modulus)>=0) { /*** DECREMENT ***/ } } if (z->w[MR_COMBA-1]==0) mr_lzero(z); #endif #if MR_COMBA == 8 #ifndef MR_NOFULLWIDTH a=t->w; b=k; c=z->w; k[0]=k[1]=k[2]=0; k[3]=a[11]; k[4]=a[12]; k[5]=a[13]; k[6]=a[14]; k[7]=a[15]; /*** ADDITION ***/ overshoot=carry; a=c; c=t->w; /*** INCREMENT ***/ overshoot+=carry; k[0]=k[1]=k[2]=0; k[3]=c[12]; k[4]=c[13]; k[5]=c[14]; k[6]=c[15]; k[7]=0; /*** INCREMENT ***/ overshoot+=carry; /*** INCREMENT ***/ overshoot+=carry; k[0]=c[8]; k[1]=c[9]; k[2]=c[10]; k[3]=k[4]=k[5]=0; k[6]=c[14]; k[7]=c[15]; /*** INCREMENT ***/ overshoot+=carry; k[0]=c[9]; k[1]=c[10]; k[2]=c[11]; k[3]=c[13]; k[4]=c[14]; k[5]=c[15]; k[6]=c[13]; k[7]=c[8]; /*** INCREMENT ***/ overshoot+=carry; k[0]=c[11]; k[1]=c[12]; k[2]=c[13]; k[3]=k[4]=k[5]=0; k[6]=c[8]; k[7]=c[10]; /*** DECREMENT ***/ overshoot-=carry; k[0]=c[12]; k[1]=c[13]; k[2]=c[14]; k[3]=c[15]; k[4]=k[5]=0; k[6]=c[9]; k[7]=c[11]; /*** DECREMENT ***/ overshoot-=carry; k[0]=c[13]; k[1]=c[14]; k[2]=c[15]; k[3]=c[8]; k[4]=c[9]; k[5]=c[10]; k[6]=0; k[7]=c[12]; /*** DECREMENT ***/ overshoot-=carry; k[0]=c[14]; k[1]=c[15]; k[2]=0; k[3]=c[9]; k[4]=c[10]; k[5]=c[11]; k[6]=0; k[7]=c[13]; /*** DECREMENT ***/ overshoot-=carry; b=modulus->w; while (overshoot>0) { /*** DECREMENT ***/ overshoot-=carry; } while (overshootw[MR_COMBA-1]>=modulus->w[MR_COMBA-1]) { if (mr_compare(z,modulus)>=0) { /*** DECREMENT ***/ } } if (z->w[MR_COMBA-1]==0) mr_lzero(z); #endif #endif #if MR_COMBA == 12 #ifndef MR_NOFULLWIDTH /* NIST P-384 curve */ a=t->w; b=k; c=z->w; k[0]=k[1]=k[2]=k[3]=0; k[4]=a[21]; k[5]=a[22]; k[6]=a[23]; k[7]=k[8]=k[9]=k[10]=k[11]=0; /*** ADDITION ***/ overshoot=carry; a=c; c=t->w; /*** INCREMENT ***/ overshoot+=carry; k[0]=c[12]; k[1]=c[13]; k[2]=c[14]; k[3]=c[15]; k[4]=c[16]; k[5]=c[17]; k[6]=c[18]; k[7]=c[19]; k[8]=c[20]; k[9]=c[21]; k[10]=c[22]; k[11]=c[23]; /*** INCREMENT ***/ overshoot+=carry; k[0]=c[21]; k[1]=c[22]; k[2]=c[23]; k[3]=c[12]; k[4]=c[13]; k[5]=c[14]; k[6]=c[15]; k[7]=c[16]; k[8]=c[17]; k[9]=c[18]; k[10]=c[19]; k[11]=c[20]; /*** INCREMENT ***/ overshoot+=carry; k[0]=k[2]=0; k[1]=c[23]; k[3]=c[20]; k[4]=c[12]; k[5]=c[13]; k[6]=c[14]; k[7]=c[15]; k[8]=c[16]; k[9]=c[17]; k[10]=c[18]; k[11]=c[19]; /*** INCREMENT ***/ overshoot+=carry; k[0]=k[1]=k[2]=k[3]=0; k[4]=c[20]; k[5]=c[21]; k[6]=c[22]; k[7]=c[23]; k[8]=k[9]=k[10]=k[11]=0; /*** INCREMENT ***/ overshoot+=carry; k[0]=c[20]; k[1]=k[2]=0; k[3]=c[21]; k[4]=c[22]; k[5]=c[23]; k[6]=k[7]=k[8]=k[9]=k[10]=k[11]=0; /*** INCREMENT ***/ overshoot+=carry; k[0]=c[23]; k[1]=c[12]; k[2]=c[13]; k[3]=c[14]; k[4]=c[15]; k[5]=c[16]; k[6]=c[17]; k[7]=c[18]; k[8]=c[19]; k[9]=c[20]; k[10]=c[21]; k[11]=c[22]; /*** DECREMENT ***/ overshoot-=carry; k[0]=0; k[1]=c[20]; k[2]=c[21]; k[3]=c[22]; k[4]=c[23]; k[5]=k[6]=k[7]=k[8]=k[9]=k[10]=k[11]=0; /*** DECREMENT ***/ overshoot-=carry; k[0]=k[1]=k[2]=0; k[3]=k[4]=c[23]; k[5]=k[6]=k[7]=k[8]=k[9]=k[10]=k[11]=0; /*** DECREMENT ***/ overshoot-=carry; b=modulus->w; while (overshoot>0) { /*** DECREMENT ***/ overshoot-=carry; } while (overshootw[MR_COMBA-1]>=modulus->w[MR_COMBA-1]) { if (mr_compare(z,modulus)>=0) { /*** DECREMENT ***/ } } if (z->w[MR_COMBA-1]==0) mr_lzero(z); #endif #endif #if MR_COMBA == 17 /* Special Code for 2^521-1 - assuming 32-bit processor */ /* split t into 521-bit halves, low half in a, high half in b */ a=t->w; b=k; c=z->w; for (i=0;i>9)|(a[i+17]>9)w; b=modulus->w; if (z->w[MR_COMBA-1]>=modulus->w[MR_COMBA-1]) { if (mr_compare(z,modulus)>=0) { /*** DECREMENT ***/ } } if (z->w[MR_COMBA-1]==0) mr_lzero(z); #endif #endif #endif #else modulus=mr_mip->modulus; ndash=mr_mip->ndash; w=mr_mip->w0; if (t!=w) copy(t,w); w->len=2*MR_COMBA+1; a=w->w; b=modulus->w; /*** REDC ***/ /* reduces a mod b */ for (i=MR_COMBA;ilen&MR_OBITS);i++) z->w[i]=0; z->len=MR_COMBA; for (i=0;iw[i]=w->w[i+MR_COMBA]; need_subtract=FALSE; if (w->w[MR_COMBA+MR_COMBA]!=0) { need_subtract=TRUE; } else { if (z->w[MR_COMBA-1]!=0) { if (z->w[MR_COMBA-1]>modulus->w[MR_COMBA-1]) need_subtract=TRUE; else { if (z->w[MR_COMBA-1]==modulus->w[MR_COMBA-1]) { if (mr_compare(z,modulus)>=0) need_subtract=TRUE; } } } else mr_lzero(z); } if (need_subtract) { a=z->w; b=modulus->w; /*** DECREMENT ***/ z->len=MR_COMBA; if (z->w[MR_COMBA-1]==0) mr_lzero(z); } #endif } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrcomba/comba_modadd.html":{"url":"miracldoc/api/mrcomba/comba_modadd.html","title":"comba_modadd","keywords":"","body":"comba_modadd comba_modadd extern void comba_modadd(_MIPT_ big,big,big); 函数功能： 参数 源码分析 comba_modadd在模板文件mrcomba.tpl实现。 void comba_modadd(_MIPD_ big x,big y,big w) { /* fast modular addition */ unsigned int i; big modulus; BOOL dodec; mr_small *a,*b,*c; mr_small carry,su; #ifdef MR_WIN64 mr_small ma,mb,u; #endif #ifdef MR_ITANIUM mr_small ma,mb,u; #endif #ifdef MR_NOASM mr_large u; #endif #ifdef MR_FAST_MOD_ADD mr_small sc,t,v; #endif #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif modulus=mr_mip->modulus; if (w!=x && w!=y) { for (i=MR_COMBA;ilen&MR_OBITS);i++) w->w[i]=0; /* zero(w); */ } a=x->w; b=y->w; c=w->w; /*** ADDITION ***/ /* add a and b, result in c */ w->len=MR_COMBA; #ifdef MR_FAST_MOD_ADD #if MR_FAST_MOD_ADD == 1 sc=(mr_small)0-modulus->w[0]; /* Modulus is 2^{MIRACL*MR_COMBA}-c. Here we calculate c */ t=MR_OP(carry)&sc; v=w->w[0]+t; if (v>=w->w[0]) { w->w[0]=v; carry=0; } #endif #if MR_FAST_MOD_ADD == 2 t=(mr_small)(w->w[MR_COMBA-1]>>M1); v=w->w[0]+t; if (v>=w->w[0]) { w->w[MR_COMBA-1]-=(mr_small)(tw[0]=v; carry=0; } #endif #endif /* if sum is greater than modulus a decrement will be required */ dodec=FALSE; if (carry) dodec=TRUE; /* possible misprediction here */ else { if (w->w[MR_COMBA-1]>modulus->w[MR_COMBA-1]) dodec=TRUE; /* possible misprediction here */ else { if (w->w[MR_COMBA-1]==modulus->w[MR_COMBA-1]) /* this will be very rare, so easily predicted */ { /* trying to avoid calling this slow function */ if (mr_compare(w,modulus)>=0) dodec=TRUE; /* do full comparison */ } } } if (dodec) /* prediction here correlated to earlier predictions, so should predict nicely */ { a=w->w; b=modulus->w; /*** DECREMENT ***/ /* decrement b from a */ } if (w->w[MR_COMBA-1]==0) mr_lzero(w); } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrcomba/comba_modsub.html":{"url":"miracldoc/api/mrcomba/comba_modsub.html","title":"comba_modsub","keywords":"","body":"comba_modsub comba_modsub extern void comba_modsub(_MIPT_ big,big,big); 函数功能： 参数 源码分析 comba_modsub在模板文件mrcomba.tpl实现。 void comba_modsub(_MIPD_ big x,big y,big w) { /* fast modular subtraction */ unsigned int i; big modulus; mr_small *a,*b,*c; mr_small carry,su; #ifdef MR_WIN64 mr_small ma,mb,u; #endif #ifdef MR_ITANIUM mr_small ma,u; #endif #ifdef MR_NOASM mr_large u; #endif #ifdef MR_FAST_MOD_ADD mr_small sc,t,v; #endif #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif modulus=mr_mip->modulus; if (x!=w && y!=w) { for (i=MR_COMBA;ilen&MR_OBITS);i++) w->w[i]=0; /* zero(w); */ } a=x->w; b=y->w; c=w->w; /*** SUBTRACTION ***/ #ifdef MR_FAST_MOD_ADD #if MR_FAST_MOD_ADD == 1 sc=(mr_small)0-modulus->w[0]; /* Modulus is 2^{MIRACL*MR_COMBA}-c. Here we calculate c */ t=MR_OP(carry)&sc; v=w->w[0]-t; if (vw[0]) { w->w[0]=v; carry=0; } #endif #if MR_FAST_MOD_ADD == 2 t=(w->w[MR_COMBA-1]>>M1); v=w->w[0]-t; if (vw[0]) { w->w[MR_COMBA-1]-=(tw[0]=v; carry=0; } #endif #endif if (carry) { a=w->w; b=modulus->w; /*** INCREMENT ***/ /* add a and b, result in c */ } w->len=MR_COMBA; if (w->w[MR_COMBA-1]==0) mr_lzero(w); } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrcomba/comba_double_modadd.html":{"url":"miracldoc/api/mrcomba/comba_double_modadd.html","title":"comba_double_modadd","keywords":"","body":"comba_double_modadd comba_double_modadd extern void comba_double_modadd(_MIPT_ big,big,big); 函数功能： 参数 源码分析 comba_double_modadd在模板文件mrcomba.tpl实现。 void comba_double_modadd(_MIPD_ big x,big y,big w) { /* fast modular addition */ unsigned int i; big modulus; BOOL dodec; mr_small *a,*b,*c; mr_small carry,su; #ifdef MR_WIN64 mr_small ma,mb,u; #endif #ifdef MR_ITANIUM mr_small ma,u; #endif #ifdef MR_NOASM mr_large u; #endif #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif modulus=mr_mip->pR; if (w!=x && w!=y) { for (i=2*MR_COMBA;ilen&MR_OBITS);i++) w->w[i]=0; /* zero(w); */ } a=x->w; b=y->w; c=w->w; /*** ADDITION2 ***/ /* add a and b, result in c */ w->len=2*MR_COMBA; /* if sum is greater than modulus a decrement will be required */ dodec=FALSE; if (carry) dodec=TRUE; /* possible misprediction here */ else { if (w->w[2*MR_COMBA-1]>modulus->w[2*MR_COMBA-1]) dodec=TRUE; /* possible misprediction here */ else { if (w->w[2*MR_COMBA-1]==modulus->w[2*MR_COMBA-1]) /* this will be very rare, so easily predicted */ { if (mr_compare(w,modulus)>=0) dodec=TRUE; /* do full comparison */ } } } if (dodec) /* prediction here correlated to earlier predictions, so should predict nicely */ { a=&(w->w[MR_COMBA]); b=&(modulus->w[MR_COMBA]); /*** DECREMENT ***/ /* decrement b from a */ } if (w->w[2*MR_COMBA-1]==0) mr_lzero(w); } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrcomba/comba_double_modsub.html":{"url":"miracldoc/api/mrcomba/comba_double_modsub.html","title":"comba_double_modsub","keywords":"","body":"comba_double_modsub comba_double_modsub extern void comba_double_modsub(_MIPT_ big,big,big); 函数功能： 参数 源码分析 comba_double_modsub在模板文件mrcomba.tpl实现。 void comba_double_modsub(_MIPD_ big x,big y,big w) { /* fast modular subtraction */ unsigned int i; big modulus; mr_small *a,*b,*c; mr_small carry,su; #ifdef MR_WIN64 mr_small ma,mb,u; #endif #ifdef MR_ITANIUM mr_small ma,u; #endif #ifdef MR_NOASM mr_large u; #endif #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif modulus=mr_mip->modulus; if (x!=w && y!=w) { for (i=2*MR_COMBA;ilen&MR_OBITS);i++) w->w[i]=0; /* zero(w); */ } a=x->w; b=y->w; c=w->w; /*** SUBTRACTION2 ***/ if (carry) { a=&(w->w[MR_COMBA]); b=modulus->w; /*** INCREMENT ***/ /* add a and b, result in c */ } w->len=2*MR_COMBA; if (w->w[2*MR_COMBA-1]==0) mr_lzero(w); } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrcomba/comba_negate.html":{"url":"miracldoc/api/mrcomba/comba_negate.html","title":"comba_negate","keywords":"","body":"comba_negate comba_negate extern void comba_negate(_MIPT_ big,big); 函数功能： 参数 源码分析 comba_negate在模板文件mrcomba.tpl实现。 void comba_negate(_MIPD_ big x,big w) { /* fast modular subtraction */ unsigned int i; big modulus; mr_small *a,*b,*c; mr_small carry,su; #ifdef MR_WIN64 mr_small ma,mb,u; #endif #ifdef MR_ITANIUM mr_small ma,u; #endif #ifdef MR_NOASM mr_large u; #endif #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif modulus=mr_mip->modulus; if (w!=x) { for (i=MR_COMBA;ilen&MR_OBITS);i++) w->w[i]=0; /* zero(w); */ } a=modulus->w; b=x->w; c=w->w; /*** SUBTRACTION ***/ w->len=MR_COMBA; if (w->w[MR_COMBA-1]==0) mr_lzero(w); } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrcomba/comba_add.html":{"url":"miracldoc/api/mrcomba/comba_add.html","title":"comba_add","keywords":"","body":"comba_add comba_add extern void comba_add(big,big,big); 函数功能： 参数 源码分析 comba_add在模板文件mrcomba.tpl实现。 void comba_add(big x,big y,big w) { /* fast addition */ unsigned int i; mr_small *a,*b,*c; mr_small carry,su; #ifdef MR_WIN64 mr_small ma,mb,u; #endif #ifdef MR_ITANIUM mr_small ma,mb,u; #endif #ifdef MR_NOASM mr_large u; #endif if (w!=x && w!=y) { for (i=MR_COMBA;ilen&MR_OBITS);i++) w->w[i]=0; /* zero(w); */ } a=x->w; b=y->w; c=w->w; /*** ADDITION ***/ /* add a and b, result in c */ w->len=MR_COMBA; if (w->w[MR_COMBA-1]==0) mr_lzero(w); } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrcomba/comba_sub.html":{"url":"miracldoc/api/mrcomba/comba_sub.html","title":"comba_sub","keywords":"","body":"comba_sub comba_sub extern void comba_sub(big,big,big); 函数功能： 参数 源码分析 comba_sub在模板文件mrcomba.tpl实现。 void comba_sub(big x,big y,big w) { /* fast subtraction */ unsigned int i; mr_small *a,*b,*c; mr_small carry,su; #ifdef MR_WIN64 mr_small ma,mb,u; #endif #ifdef MR_ITANIUM mr_small ma,u; #endif #ifdef MR_NOASM mr_large u; #endif if (x!=w && y!=w) { for (i=MR_COMBA;ilen&MR_OBITS);i++) w->w[i]=0; /* zero(w); */ } a=x->w; b=y->w; c=w->w; /*** SUBTRACTION ***/ w->len=MR_COMBA; if (w->w[MR_COMBA-1]==0) mr_lzero(w); } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrcomba/comba_double_add.html":{"url":"miracldoc/api/mrcomba/comba_double_add.html","title":"comba_double_add","keywords":"","body":"comba_double_add comba_double_add extern void comba_double_add(big,big,big); 函数功能： 参数 源码分析 comba_double_add在模板文件mrcomba.tpl实现。 void comba_double_add(big x,big y,big w) { /* fast modular addition */ unsigned int i; mr_small *a,*b,*c; mr_small carry,su; #ifdef MR_WIN64 mr_small ma,mb,u; #endif #ifdef MR_ITANIUM mr_small ma,u; #endif #ifdef MR_NOASM mr_large u; #endif if (w!=x && w!=y) { for (i=2*MR_COMBA;ilen&MR_OBITS);i++) w->w[i]=0; /* zero(w); */ } a=x->w; b=y->w; c=w->w; /*** ADDITION2 ***/ /* add a and b, result in c */ w->len=2*MR_COMBA; if (w->w[2*MR_COMBA-1]==0) mr_lzero(w); } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrcomba/comba_double_sub.html":{"url":"miracldoc/api/mrcomba/comba_double_sub.html","title":"comba_double_sub","keywords":"","body":"comba_double_sub comba_double_sub extern void comba_double_sub(big,big,big); 函数功能： 参数 源码分析 comba_double_sub在模板文件mrcomba.tpl实现。 void comba_double_sub(big x,big y,big w) { /* fast modular subtraction */ unsigned int i; mr_small *a,*b,*c; mr_small carry,su; #ifdef MR_WIN64 mr_small ma,mb,u; #endif #ifdef MR_ITANIUM mr_small ma,u; #endif #ifdef MR_NOASM mr_large u; #endif if (x!=w && y!=w) { for (i=2*MR_COMBA;ilen&MR_OBITS);i++) w->w[i]=0; /* zero(w); */ } a=x->w; b=y->w; c=w->w; /*** SUBTRACTION2 ***/ w->len=2*MR_COMBA; if (w->w[2*MR_COMBA-1]==0) mr_lzero(w); } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrcore/convert.html":{"url":"miracldoc/api/mrcore/convert.html","title":"convert","keywords":"","body":"convert convert extern void convert(_MIPT_ int,big); 函数功能：将有符号int类型数据转换为big类型数据。 参数：_MIPD_：可能为空，非空为miracl *类型。 参数n：int类型数据。 参数x：big类型数据。 源码分析 void convert(_MIPD_ int n ,big x) { /* convert signed integer n to big number format */ mr_lentype s; #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif if (n==0) {zero(x); return;} s=0; if (nlen|=s; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/mrcore/copy.html":{"url":"miracldoc/api/mrcore/copy.html","title":"copy","keywords":"","body":"copy copy定义在miracl.h extern void copy(flash,flash); 函数功能：将x轴坐标复制给y轴坐标。 参数x：x轴坐标。 参数y：y轴坐标。 源码分析 copy实现在mrcore.c void copy(flash x,flash y) { /* copy x to y: y=x */ int i,nx,ny; mr_small *gx,*gy; if (x==y || y==NULL) return; if (x==NULL) { zero(y); return; } #ifdef MR_FLASH ny=mr_lent(y); nx=mr_lent(x); #else ny=(y->len&(MR_OBITS)); nx=(x->len&(MR_OBITS)); #endif gx=x->w; gy=y->w; for (i=nx;ilen=x->len; } zero将参数设置为0。 如果是MR_FLASH，mr_lent计算低位两字节与高位两字节的和，否则MR_OBITS与参数的长度按位与运算。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/mrcore/ecp_memalloc.html":{"url":"miracldoc/api/mrcore/ecp_memalloc.html","title":"ecp_memalloc","keywords":"","body":"ecp_memalloc ecp_memalloc函数定义在miracl.h，在mrcore.c中实现。 extern void* ecp_memalloc(_MIPT_ int); 函数功能：为epoint分配堆内存。 参数num：整数。 源码分析 ecp_memalloc函数实现的相关内容如下。 void *ecp_memalloc(_MIPD_ int num) { #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif #ifndef MR_AFFINE_ONLY if (mr_mip->coord==MR_AFFINE) return mr_alloc(_MIPP_ mr_ecp_reserve_a(num,mr_mip->nib-1),1); else #endif return mr_alloc(_MIPP_ mr_ecp_reserve(num,mr_mip->nib-1),1); } get_mip返回miracl *指针，如果没有定义MR_OS_THREADS，由_MIPD_接收。 一般情况下，用mr_ecp_reserve计算需要申请的字节数，当声明MR_AFFINE_ONLY，用mr_ecp_reserve_a计算需要申请的字节数。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/mrcore/epoint_init_mem.html":{"url":"miracldoc/api/mrcore/epoint_init_mem.html","title":"epoint_init_mem","keywords":"","body":"epoint_init_mem epoint_init_mem函数定义在miracl.h，在mrcore.c中实现。 extern epoint* epoint_init_mem(_MIPT_ char *,int); 函数功能：将字符串mem初始化为椭圆曲线上的点。 参数_MIPT_：可能为空，非空为miracl *类型。 参数mem：字符串。 参数index：整数。 源码分析 epoint_init_mem相关的内容如下。 epoint* epoint_init_mem(_MIPD_ char *mem,int index) { #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif if (mr_mip->ERNUM) return NULL; return epoint_init_mem_variable(_MIPP_ mem,index,mr_mip->nib-1); } get_mip返回miracl *指针，如果没有定义MR_OS_THREADS，由_MIPD_接收。 epoint_init_mem_variable对mem初始化为椭圆曲线上的点。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/mrcore/epoint_init_mem_variable.html":{"url":"miracldoc/api/mrcore/epoint_init_mem_variable.html","title":"epoint_init_mem_variable","keywords":"","body":"epoint_init_mem_variable epoint_init_mem_variable函数定义在miracl.h，在mrcore.c中实现。 extern epoint* epoint_init_mem_variable(_MIPT_ char *,int,int); 函数功能：用字符数组mem初始化一个epoint指针，也就是椭圆曲线的一个点。 参数mem：字符数组。 参数index：下标。 参数sz：整数。 源码分析 与epoint_init_mem_variable相关的函数如下。 #ifdef MR_GENERIC_MT #define _MIPD_ miracl *mr_mip, #else #define _MIPD_ #endif /* Elliptic curve point status */ #define MR_AFFINE 1 #define MR_EPOINT_INFINITY 2 epoint* epoint_init_mem_variable(_MIPD_ char *mem,int index,int sz) { epoint *p; char *ptr; int offset,r; #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif // 字节对齐 offset=0; r=(unsigned long)mem%MR_SL; if (r>0) offset=MR_SL-r; #ifndef MR_AFFINE_ONLY if (mr_mip->coord==MR_AFFINE) p=(epoint *)&mem[offset+index*mr_esize_a(sz)]; else #endif // 取mem的第offset+index*mr_esize(sz)个元素的地址，然后强制转换为epoint类型指针 p=(epoint *)&mem[offset+index*mr_esize(sz)]; ptr=(char *)p+sizeof(epoint); p->X=mirvar_mem_variable(ptr,0,sz); p->Y=mirvar_mem_variable(ptr,1,sz); #ifndef MR_AFFINE_ONLY if (mr_mip->coord!=MR_AFFINE) p->Z=mirvar_mem_variable(ptr,2,sz); #endif p->marker=MR_EPOINT_INFINITY; return p; } 如果定义了MR_OS_THREADS，则设置mr_mip为get_mip，返回miracl *指针。 mirvar_mem_variable为字符数组mem的元素设置对齐。 MR_AFFINE和MR_EPOINT_INFINITY定义在字符常量，表示椭圆曲线上点的状态。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/mrcore/get_mip.html":{"url":"miracldoc/api/mrcore/get_mip.html","title":"get_mip","keywords":"","body":"get_mip() get_mip()在miracl.h中定义，在mrcore.c中实现。 extern miracl *get_mip(void ); 函数功能：返回miracl *指针。 参数：无。 源码分析 与get_mip()相关的定义如下：分别在4种不同环境下定义。 在MR_OPENMP_MT条件下，直接返回miracl *指针。 在MR_WINDOWS_MT条件下，返回miracl *指针。由windows.h提供的TlsGetValue函数，取出序列号中存储的数据。 在MR_UNIX_MT条件下，返回miracl *指针。由pthread.h提供的pthread_getspecific函数，取出序列号中存储的数据。 在没有定义MR_WINDOWS_MT、MR_UNIX_MT和MR_OPENMP_MT的情况下，返回miracl *指针。如果没有定义MR_STATIC，则返回的miracl *指针为空。 /*** Multi-Threaded Support ***/ #ifndef MR_GENERIC_MT #ifdef MR_OPENMP_MT #include #define MR_MIP_EXISTS miracl *mr_mip; #pragma omp threadprivate(mr_mip) miracl *get_mip() { return mr_mip; } void mr_init_threading() { } void mr_end_threading() { } #endif #ifdef MR_WINDOWS_MT #include DWORD mr_key; miracl *get_mip() { return (miracl *)TlsGetValue(mr_key); } void mr_init_threading() { mr_key=TlsAlloc(); } void mr_end_threading() { TlsFree(mr_key); } #endif #ifdef MR_UNIX_MT #include pthread_key_t mr_key; miracl *get_mip() { return (miracl *)pthread_getspecific(mr_key); } void mr_init_threading() { pthread_key_create(&mr_key,(void(*)(void *))NULL); } void mr_end_threading() { pthread_key_delete(mr_key); } #endif #ifndef MR_WINDOWS_MT #ifndef MR_UNIX_MT #ifndef MR_OPENMP_MT #ifdef MR_STATIC miracl mip; miracl *mr_mip=&mip; #else miracl *mr_mip=NULL; /* MIRACL's one and only global variable */ #endif #define MR_MIP_EXISTS miracl *get_mip() { return (miracl *)mr_mip; } #endif #endif #endif #ifdef MR_MIP_EXISTS void set_mip(miracl *mip) { mr_mip=mip; } #endif #endif 测试windows.h提供的线程局部存储（TLS） windows.h提供了TlsGetValue等函数处理线程，下面是测试案例。 #include #include using namespace std; LPVOID fun(int ind) { return TlsGetValue(ind); } DWORD WINAPI testThr(LPVOID lpThreadParameter) { int ind = (int)lpThreadParameter; cout 测试pthread.h的线程安全存储 UNIX、Linux、MacOS系统下的pthread.h，提供了线程处理方法，下面是一个简单的案例。 #include #include #include static pthread_key_t p_key; void *thread_func(void *args) { int *tmp1, *tmp2; /* 初始化键值时使用的特征值，是该线程创建时传入的特征值a/b */ pthread_setspecific(p_key, args); /* 初始化本线程的私有键值 */ printf(\"in thread %d. init specific_data to %d\\n\", *(int *)args, *(int *)args); tmp1 = (int *)pthread_getspecific(p_key); /* 获取键值 */ printf(\"get specific_data %d\\n\", *tmp1); *tmp1 = (*tmp1) * 100; /* 修改键值 */ printf(\"change specific_data to %d\\n\", *tmp1); tmp2 = (int *)pthread_getspecific(p_key); /* 重新获取本线程的键值 */ printf(\"get specific_data %d\\n\", *tmp2); return (void *)0; } int main() { int a = 10; int b = 20; pthread_t pa, pb; printf(\"at first: a = %d. b = %d\\n\", a, b); pthread_key_create(&p_key, NULL); /* 创建线程键值 */ pthread_create(&pa, NULL, thread_func, &a); /* 创建线程1 */ pthread_create(&pb, NULL, thread_func, &b); /* 创建线程2 */ // 等待线程pa结束，防止主线程提前结束 pthread_join(pa, NULL); // 等待线程pb结束，防止主线程提前结束 pthread_join(pb, NULL); printf(\"at last: a = %d. b = %d\\n\", a, b); return 0; } 测试结果如下 at first: a = 10. b = 20 in thread 10. init specific_data to 10 get specific_data 10 change specific_data to 1000 get specific_data 1000 in thread 20. init specific_data to 20 get specific_data 20 change specific_data to 2000 get specific_data 2000 at last: a = 1000. b = 2000 函数pthread_join为主线程加塞，防止主线程提前结束，pthread_join强制主线程等待列表中的子线程结束。 © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-16 "},"miracldoc/api/mrcore/imuldiv.html":{"url":"miracldoc/api/mrcore/imuldiv.html","title":"imuldiv","keywords":"","body":"imuldiv imuldiv extern mr_small imuldiv(mr_small,mr_small,mr_small,mr_small,mr_large,mr_small *); #ifdef MR_FP_ROUNDING mr_small imuldiv(mr_small a,mr_small b,mr_small c,mr_small m,mr_large im,mr_small *rp) { mr_small q; mr_large ldres,p=(mr_large)a*b+c; q=(mr_small)MR_LROUND(p*im); *rp=(mr_small)(p-(mr_large)q*m); return q; } #endif © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/mrcore/irand.html":{"url":"miracldoc/api/mrcore/irand.html","title":"irand","keywords":"","body":"irand() irand定义在miracl.h中，在mrcore.c中实现。 extern void irand(_MIPT_ mr_unsign32); void irand(_MIPD_ mr_unsign32 seed) { /* initialise random number system */ int i,in; mr_unsign32 t,m=1L; #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif mr_mip->borrow=0L; mr_mip->rndptr=0; mr_mip->ira[0]=seed; for (i=1;iira[in]=m; t=m; m=seed-m; seed=t; } for (i=0;i rand() rand定义在big.h，实现在big.cpp。 extern Big rand(int,int); Big rand(const Big& b) {Big z; bigrand(b.fn,z.fn); return z;} Big rand(int n,int b) {Big z; bigdig(n,b,z.fn); return z;} bigrand()和bigdig() bigrand和bigdig定义在big.h，实现在mrrand.c。 extern void bigrand(_MIPT_ big,big); extern void bigdig(_MIPT_ int,int,big); #ifndef MR_NO_RAND void bigrand(_MIPD_ big w,big x) { /* generate a big random number 0ERNUM) return; MR_IN(20) /* decr(_MIPP_ w,2,w); */ m=0; zero(mr_mip->w0); do { /* create big rand piece by piece */ m++; mr_mip->w0->len=m; r=brand(_MIPPO_ ); if (mr_mip->base==0) mr_mip->w0->w[m-1]=r; else mr_mip->w0->w[m-1]=MR_REMAIN(r,mr_mip->base); } while (mr_compare(mr_mip->w0,w)w0); divide(_MIPP_ mr_mip->w0,w,w); copy(mr_mip->w0,x); /* incr(_MIPP_ x,2,x); if (w!=x) incr(_MIPP_ w,2,w); */ MR_OUT } void bigdig(_MIPD_ int n,int b,big x) { /* generate random number n digits long * * to \"printable\" base b */ #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif if (mr_mip->ERNUM) return; MR_IN(19) if (b256) { mr_berror(_MIPP_ MR_ERR_BASE_TOO_BIG); MR_OUT return; } do { /* repeat if x too small */ expint(_MIPP_ b,n,mr_mip->w1); bigrand(_MIPP_ mr_mip->w1,x); subdiv(_MIPP_ mr_mip->w1,b,mr_mip->w1); } while (!mr_mip->ERNUM && mr_compare(x,mr_mip->w1) © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-15 "},"miracldoc/api/mrcore/mirvar_mem_variable.html":{"url":"miracldoc/api/mrcore/mirvar_mem_variable.html","title":"mirvar_mem_variable","keywords":"","body":"mirvar_mem_variable mirvar_mem_variable定义在miracl.h，实现在mrcore.c extern flash mirvar_mem_variable(char *,int,int); 函数功能：为字符数组mem的元素对齐设置。 参数mem：字符数组或字符指针。 参数index：下标。 参数sz：个数。 源码分析 与mirvar_mem_variable定义相关的函数如下。 struct bigtype { mr_lentype len; mr_small *w; }; typedef struct bigtype *big; typedef big flash; #define MR_INIT_ECN memset(mem,0,mr_ecp_reserve(1,ZZNS)); p=(epoint *)epoint_init_mem_variable(mem,0,ZZNS); flash mirvar_mem_variable(char *mem,int index,int sz) { flash x; int align; char *ptr; int offset,r; /* alignment */ offset=0; // 与long对齐 r=(unsigned long)mem%MR_SL; if (r>0) offset=MR_SL-r; // 偏移量 // 取第offset+mr_size(sz)*index个元素，并转换为big类型 x=(big)&mem[offset+mr_size(sz)*index]; // 指向x的w ptr=(char *)&x->w; // 对齐位置 align=(unsigned long)(ptr+sizeof(mr_small *))%sizeof(mr_small); x->w=(mr_small *)(ptr+sizeof(mr_small *)+sizeof(mr_small)-align); return x; } char类型指针mem指向一个初始化为0的存储单元，作为epoint_init_mem_variable的参数之一，epoint_init_mem_variable内部调用mirvar_mem_variable。 (unsigned long)mem对char *强制类型转换，也就是mem的地址强制转换为unsigned long。对(unsigned long)mem%MR_SL，校验r的地址余数是否与long对齐。如果没有对齐，offset纪录偏移量。 mr_size计算需要的字节数，取mem的第offset+mr_size(sz)*index个元素，并强制转换为big类型，放在x。 测试地址类型转换 (unsigned long)mem对char *强制类型转换，也就是地址常量强制类型转换。 #include #include #define N 8 int main(){ char mems[N]; char *mem = mems; memset(mems, 0, sizeof(char) * N); int i = 0; for(i = 0; i 测试输出 0 0 0 0 0 0 0 0 l = 16D4B7930 mem = 16D4B7930 mems = 16D4B7930 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/mrcore/mputs.html":{"url":"miracldoc/api/mrcore/mputs.html","title":"mputs","keywords":"","body":"mputs mputs定义和实现都在mrcore.h #ifndef MR_NO_STANDARD_IO static void mputs(char *s) { /* output a string */ int i=0; while (s[i]!=0) fputc((int)s[i++],stdout); } #endif 函数功能：在屏幕打印字符串，其中字符强制转换为整形，也就是打印字符的ASCII码。 参数s：字符串。 © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-17 "},"miracldoc/api/mrcore/mr_berror.html":{"url":"miracldoc/api/mrcore/mr_berror.html","title":"mr_berror","keywords":"","body":"mr_berror mr_berror定义在miracl.h extern void mr_berror(_MIPT_ int); 函数功能：按层级打印错误提示。 参数_MIPT_：可能为空，非空为miracl *类型。 参数nerr：整数1∼291\\sim 291∼29。错误类型有29种，分别从1到29，其他错误类型为定义。 源码分析 根据错误类型nerr，用mputs打印错误提示。 void mr_berror(_MIPD_ int nerr) { /* Big number error routine */ #ifndef MR_STRIPPED_DOWN int i; #endif #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif if (mr_mip->ERCON) { mr_mip->ERNUM=nerr; // 错误码 return; } #ifndef MR_NO_STANDARD_IO #ifndef MR_STRIPPED_DOWN mputs((char *)\"\\nMIRACL error from routine \"); if (mr_mip->depthtrace[mr_mip->depth]]); else mputs((char *)\"???\"); fputc('\\n',stdout); for (i=mr_mip->depth-1;i>=0;i--) { mputs((char *)\" called from \"); if (itrace[i]]); else mputs((char *)\"???\"); fputc('\\n',stdout); } switch (nerr) { case 1 : mputs((char *)\"Number base too big for representation\\n\"); break; case 2 : mputs((char *)\"Division by zero attempted\\n\"); break; case 3 : mputs((char *)\"Overflow - Number too big\\n\"); break; case 4 : mputs((char *)\"Internal result is negative\\n\"); break; case 5 : mputs((char *)\"Input format error\\n\"); break; case 6 : mputs((char *)\"Illegal number base\\n\"); break; case 7 : mputs((char *)\"Illegal parameter usage\\n\"); break; case 8 : mputs((char *)\"Out of space\\n\"); break; case 9 : mputs((char *)\"Even root of a negative number\\n\"); break; case 10: mputs((char *)\"Raising integer to negative power\\n\"); break; case 11: mputs((char *)\"Attempt to take illegal root\\n\"); break; case 12: mputs((char *)\"Integer operation attempted on Flash number\\n\"); break; case 13: mputs((char *)\"Flash overflow\\n\"); break; case 14: mputs((char *)\"Numbers too big\\n\"); break; case 15: mputs((char *)\"Log of a non-positive number\\n\"); break; case 16: mputs((char *)\"Flash to double conversion failure\\n\"); break; case 17: mputs((char *)\"I/O buffer overflow\\n\"); break; case 18: mputs((char *)\"MIRACL not initialised - no call to mirsys()\\n\"); break; case 19: mputs((char *)\"Illegal modulus \\n\"); break; case 20: mputs((char *)\"No modulus defined\\n\"); break; case 21: mputs((char *)\"Exponent too big\\n\"); break; case 22: mputs((char *)\"Unsupported Feature - check mirdef.h\\n\"); break; case 23: mputs((char *)\"Specified double length type isn't double length\\n\"); break; case 24: mputs((char *)\"Specified basis is NOT irreducible\\n\"); break; case 25: mputs((char *)\"Unable to control Floating-point rounding\\n\"); break; case 26: mputs((char *)\"Base must be binary (MR_ALWAYS_BINARY defined in mirdef.h ?)\\n\"); break; case 27: mputs((char *)\"No irreducible basis defined\\n\"); break; case 28: mputs((char *)\"Composite modulus\\n\"); break; case 29: mputs((char *)\"Input/output error when reading from RNG device node\\n\"); break; default: mputs((char *)\"Undefined error\\n\"); break; } exit(0); #else mputs((char *)\"MIRACL error\\n\"); exit(0); #endif #endif } © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/mrcore/mr_compare.html":{"url":"miracldoc/api/mrcore/mr_compare.html","title":"mr_compare","keywords":"","body":"mr_compare extern int mr_compare(big,big); 函数功能：比较两个数的大小，如果x大于 y，返回1；如果x小于 y，返回-1；否则返回0。 参数x：big类型数值。 参数y：big类型数值。 源码分析 int mr_compare(big x,big y) { /* compare x and y: =1 if x>y =-1 if xlen&MR_MSBIT); sy=(y->len&MR_MSBIT); if (sx==0) sig=PLUS; else sig=MINUS; if (sx!=sy) return sig; m=(int)(x->len&MR_OBITS); n=(int)(y->len&MR_OBITS); if (m>n) return sig; if (m0) { /* check digit by digit */ m--; if (x->w[m]>y->w[m]) return sig; if (x->w[m]w[m]) return -sig; } return 0; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-19 "},"miracldoc/api/mrcore/mr_lent.html":{"url":"miracldoc/api/mrcore/mr_lent.html","title":"mr_lent","keywords":"","body":"mr_lent mr_lent定义在miracl.h extern int mr_lent(flash); 函数功能：返回数值的长度。 参数x：浮点数值。 源码分析 mr_lent实现在mrcore.c #define MR_FLASH 52 // 定义在mirdef.h #ifdef MR_FLASH #define MR_EBITS (8*sizeof(double) - MR_FLASH) /* no of Bits per double exponent */ #define MR_BTS 16 #define MR_MSK 0xFFFF #endif typedef unsigned int mr_lentype; int mr_lent(flash x) { /* return length of big or flash in words */ mr_lentype lx; lx=(x->len&(MR_OBITS)); #ifdef MR_FLASH return (int)((lx&(MR_MSK))+((lx>>(MR_BTS))&(MR_MSK))); #else return (int)lx; #endif } flash类型数据x的长度与MR_OBITS做按位与运算。 如果定义了MR_FLASH，返回的是低位两字节与高位两字节的和，否则返回的是x的长度。 lx&(MR_MSK)取得lx的低位两个字节，(lx>>(MR_BTS))&(MR_MSK)取得lx的高位两个字节，低位两个字节与高位两个字节相加。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/mrcore/mr_lzero.html":{"url":"miracldoc/api/mrcore/mr_lzero.html","title":"mr_lzero","keywords":"","body":"mr_lzero mr_lzero extern void mr_lzero(big); void mr_lzero(big x) { /* strip leading zeros from big number */ mr_lentype s; int m; s=(x->len&(MR_MSBIT)); m=(int)(x->len&(MR_OBITS)); while (m>0 && x->w[m-1]==0) m--; x->len=m; if (m>0) x->len|=s; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/mrcore/mr_notint.html":{"url":"miracldoc/api/mrcore/mr_notint.html","title":"mr_notint","keywords":"","body":"mr_notint mr_notint定义在miracl.h extern BOOL mr_notint(flash); 函数功能：判断参数x是否为flash类型数值，返回TRUE或者FALSE。 参数x：flash类型数值。 源码分析 mr_notint实现在mrcore.c #define MR_FLASH 52 // 定义在mirdef.h #define MR_IBITS 32 // 定义在mirdef.h #ifdef MR_FLASH #define MR_EBITS (8*sizeof(double) - MR_FLASH) /* no of Bits per double exponent */ #define MR_BTS 16 #define MR_MSK 0xFFFF #endif #define MR_MSBIT ((mr_lentype)1len&(MR_OBITS))>>(MR_BTS))&(MR_MSK))!=0) return TRUE; #endif return FALSE; } MR_MSBIT为(mr_lentype)1，将1左移31位，得到10000000000000000000000000000000。 MR_OBITS为MR_MSBIT-1减1，得到01111111111111111111111111111111。 x->len&(MR_OBITS)>>(MR_BTS)中，x->len的4字节右移16位，得到高位两字节。如果高位两字节不为0，返回TRUE或者FALSE。 © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-19 "},"miracldoc/api/mrcore/muldiv.html":{"url":"miracldoc/api/mrcore/muldiv.html","title":"muldiv","keywords":"","body":"muldiv muldiv extern mr_small muldiv(mr_small,mr_small,mr_small,mr_small,mr_small *); /* C only versions of muldiv/muldvd/muldvd2/muldvm */ /* Note that mr_large should be twice the size of mr_small */ mr_small muldiv(mr_small a,mr_small b,mr_small c,mr_small m,mr_small *rp) { mr_small q; mr_large ldres,p=(mr_large)a*b+c; q=(mr_small)(MR_LROUND(p/m)); *rp=(mr_small)(p-(mr_large)q*m); return q; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/mrcore/muldvd.html":{"url":"miracldoc/api/mrcore/muldvd.html","title":"muldvd","keywords":"","body":"muldvd muldvd extern mr_small muldvd(mr_small,mr_small,mr_small,mr_small *); mr_small muldvd(mr_small a,mr_small b,mr_small c,mr_small *rp) { union doubleword dble; dble.d=(mr_large)a*b+c; *rp=dble.h[MR_BOT]; return dble.h[MR_TOP]; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/mrcore/muldvm.html":{"url":"miracldoc/api/mrcore/muldvm.html","title":"muldvm","keywords":"","body":"muldvm muldvm extern mr_small muldvm(mr_small,mr_small,mr_small,mr_small *); mr_small muldvm(mr_small a,mr_small c,mr_small m,mr_small *rp) { mr_small q; union doubleword dble; dble.h[MR_BOT]=c; dble.h[MR_TOP]=a; q=(mr_small)(dble.d/m); *rp=(mr_small)(dble.d-(mr_large)q*m); return q; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/mrcore/size.html":{"url":"miracldoc/api/mrcore/size.html","title":"size","keywords":"","body":"size size extern int size(big); 函数功能：将big类型数据转换为int类型数据。 参数x： 源码分析 int size(big x) { /* get size of big number; convert to * * integer - if possible */ int n,m; mr_lentype s; if (x==NULL) return 0; s=(x->len&MR_MSBIT); m=(int)(x->len&MR_OBITS); if (m==0) return 0; if (m==1 && x->w[0]w[0]; else n=MR_TOOBIG; if (s==MR_MSBIT) return (-n); return n; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/mrcore/uconvert.html":{"url":"miracldoc/api/mrcore/uconvert.html","title":"uconvert","keywords":"","body":"uconvert uconvert extern void uconvert(_MIPT_ unsigned int,big); 函数功能：将无符号int类型数据转换为big类型数据。 参数：_MIPD_：可能为空，非空为miracl *类型。 参数n：unsigned类型数据。 参数x：big类型数据。 源码分析 void uconvert(_MIPD_ unsigned int n ,big x) { /* convert unsigned integer n to big number format */ int m; #ifdef MR_FP mr_small dres; #endif #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif zero(x); if (n==0) return; m=0; #ifndef MR_SIMPLE_BASE if (mr_mip->base==0) { #endif #ifndef MR_NOFULLWIDTH #if MR_IBITS > MIRACL while (n>0) { x->w[m++]=(mr_small)(n%((mr_small)1w[m++]=(mr_small)n; #endif #endif #ifndef MR_SIMPLE_BASE } else while (n>0) { x->w[m++]=MR_REMAIN((mr_small)n,mr_mip->base); n=(unsigned int)((mr_small)n/mr_mip->base); } #endif x->len=m; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/mrcore/zero.html":{"url":"miracldoc/api/mrcore/zero.html","title":"zero","keywords":"","body":"zero zero定义在miracl.h extern void zero(flash); 函数功能：将数值设置为000。 参数x：big或者flash类型数值。 源码分析 zero实现在mrcore.c void zero(flash x) { /* set big/flash number to zero */ int i,n; mr_small *g; if (x==NULL) return; #ifdef MR_FLASH n=mr_lent(x); // 符点数长度 #else n=(x->len&MR_OBITS); #endif g=x->w; for (i=0;ilen=0; } 如果是MR_FLASH，mr_lent计算低位两字节与高位两字节的和，否则MR_OBITS与参数x的长度按位与运算。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/big/ecurve.html":{"url":"miracldoc/api/big/ecurve.html","title":"ecurve","keywords":"","body":"ecurve ecurve定义在big.h，实现在big.cpp。 friend void ecurve(const Big&,const Big&,const Big&,int); void ecurve(const Big& a,const Big& b,const Big& p,int t) { ecurve_init(a.fn,b.fn,p.fn,t); } ecurve_init定义在miracl.h，实现在mrmonty.c，ecurve_init初始化一个椭圆曲线。 extern void ecurve_init(_MIPT_ big,big,big,int); /* initialise elliptic curve */ void ecurve_init(_MIPD_ big a,big b,big p,int type) { /* Initialize the active ecurve * * Asize indicate size of A * * Bsize indicate size of B */ int as; #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif if (mr_mip->ERNUM) return; MR_IN(93) #ifndef MR_NO_SS mr_mip->SS=FALSE; /* no special support for super-singular curves */ #endif prepare_monty(_MIPP_ p); mr_mip->Asize=size(a); if (mr_abs(mr_mip->Asize)==MR_TOOBIG) { if (mr_mip->Asize>=0) { /* big positive number - check it isn't minus something small */ copy(a,mr_mip->w1); divide(_MIPP_ mr_mip->w1,p,p); subtract(_MIPP_ p,mr_mip->w1,mr_mip->w1); as=size(mr_mip->w1); if (asAsize=-as; } } nres(_MIPP_ a,mr_mip->A); mr_mip->Bsize=size(b); if (mr_abs(mr_mip->Bsize)==MR_TOOBIG) { if (mr_mip->Bsize>=0) { /* big positive number - check it isn't minus something small */ copy(b,mr_mip->w1); divide(_MIPP_ mr_mip->w1,p,p); subtract(_MIPP_ p,mr_mip->w1,mr_mip->w1); as=size(mr_mip->w1); if (asBsize=-as; } } nres(_MIPP_ b,mr_mip->B); #ifdef MR_EDWARDS mr_mip->coord=MR_PROJECTIVE; /* only type supported for Edwards curves */ #else #ifndef MR_AFFINE_ONLY if (type==MR_BEST) mr_mip->coord=MR_PROJECTIVE; else mr_mip->coord=type; #else if (type==MR_PROJECTIVE) mr_berror(_MIPP_ MR_ERR_NOT_SUPPORTED); #endif #endif MR_OUT return; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-15 "},"miracldoc/api/mr87f/fastmodmult.html":{"url":"miracldoc/api/mr87f/fastmodmult.html","title":"fastmodmult","keywords":"","body":"fastmodmult fastmodmult extern void fastmodmult(_MIPT_ big,big,big); void fastmodmult(_MIPD_ big x,big y,big z) { int ij; #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif big w0=mr_mip->w0; big modulus=mr_mip->modulus; mr_small *wg,*mg,*xg,*yg; wg=w0->w; mg=modulus->w; xg=x->w; yg=y->w; for (ij=2*MR_PENTIUM;ijlen&MR_OBITS);ij++) w0->w[ij]=0.0; w0->len=2*MR_PENTIUM; ASM { FSTEP MACRO i,j /* some fancy Pentium scheduling going on here ... */ fld POINTER [PBX+N*i] fmul POINTER [PSI+N*j] fxch st(2) fadd ENDM FRSTEP MACRO i,j fld POINTER [PDI+N*i] fmul POINTER [PSI+N*j] fxch st(2) fadd ENDM FDSTEP MACRO i,j fld POINTER [PBX+N*i] fmul POINTER [PBX+N*j] fxch st(2) fadd ENDM SELF MACRO k fld POINTER [PBX+N*k] fmul st,st(0) fadd ENDM RFINU MACRO k fld st(0) fadd st,st(2) fsub st,st(2) fsubr st,st(1) fmul st,st(4) fld st(0) fadd st,st(3) fsub st,st(3) fsub fst POINTER [PDI+N*k] fmul POINTER [PSI] fadd fmul st,st(2) ENDM RFIND MACRO k fld st(0) fadd st,st(2) fsub st,st(2) fsub st(1),st fmul st,st(3) fxch st(1) fstp POINTER [PDI+N*k] ENDM DIAG MACRO ns,ne CNT1=ns CNT2=ne fld POINTER [PBX+N*CNT1] fmul POINTER [PSI+N*CNT2] CNT1=CNT1+1 CNT2=CNT2-1 WHILE CNT1 LE ne FSTEP CNT1,CNT2 CNT1=CNT1+1 CNT2=CNT2-1 ENDM fadd ENDM SDIAG MACRO ns,ne CNT1=ns CNT2=ne IF CNT1 LT CNT2 fstp st(5) /* store carry */ fldz fld POINTER [PBX+N*CNT1] fmul POINTER [PBX+N*CNT2] CNT1=CNT1+1 CNT2=CNT2-1 WHILE CNT1 LT CNT2 FDSTEP CNT1,CNT2 CNT1=CNT1+1 CNT2=CNT2-1 ENDM fadd fld st(0) /* now double it ... */ fadd fadd st,st(5) /* add in carry */ ENDIF ENDM RDIAGU MACRO ns,ne CNT1=ns CNT2=ne IF CNT1 LT ne fld POINTER [PDI+N*CNT1] fmul POINTER [PSI+N*CNT2] CNT1=CNT1+1 CNT2=CNT2-1 WHILE CNT1 LT ne FRSTEP CNT1,CNT2 CNT1=CNT1+1 CNT2=CNT2-1 ENDM fadd ENDIF ENDM RDIAGD MACRO ns,ne CNT1=ns CNT2=ne fld POINTER [PDI+N*CNT1] fmul POINTER [PSI+N*CNT2] CNT1=CNT1+1 CNT2=CNT2-1 WHILE CNT1 LE ne FRSTEP CNT1,CNT2 CNT1=CNT1+1 CNT2=CNT2-1 ENDM fadd ENDM MODMULT MACRO CNT=0 WHILE CNT LT MR_PENTIUM DIAG 0,CNT xchg PSI,PCX RDIAGU 0,CNT RFINU CNT xchg PSI,PCX CNT=CNT+1 ENDM SCNT=0 WHILE SCNT LT (MR_PENTIUM-1) SCNT=SCNT+1 DIAG SCNT,(MR_PENTIUM-1) xchg PSI,PCX RDIAGD SCNT,(MR_PENTIUM-1) RFIND CNT xchg PSI,PCX CNT=CNT+1 ENDM RFIND CNT CNT=CNT+1 fstp POINTER [PDI+N*CNT] ENDM MODSQUARE MACRO CNT=0 WHILE CNT LT MR_PENTIUM SDIAG 0,CNT IF (CNT MOD 2) EQ 0 SELF (CNT/2) ENDIF RDIAGU 0,CNT RFINU CNT CNT=CNT+1 ENDM SCNT=0 WHILE SCNT LT (MR_PENTIUM-1) SCNT=SCNT+1 SDIAG SCNT,(MR_PENTIUM-1) IF (CNT MOD 2) EQ 0 SELF (CNT/2) ENDIF RDIAGD SCNT,(MR_PENTIUM-1) RFIND CNT CNT=CNT+1 ENDM RFIND CNT CNT=CNT+1 fstp POINTER [PDI+N*CNT] ENDM } ASM { push PDI push PSI mov PBX,xg mov PSI,yg mov PCX,mg mov PDI,wg fldz MODMULT pop PSI pop PDI } for (ij=MR_PENTIUM;ijlen&MR_OBITS);ij++) z->w[ij]=0.0; z->len=MR_PENTIUM; for (ij=0;ijw[ij]=w0->w[ij+MR_PENTIUM]; if (z->w[MR_PENTIUM-1]==0.0) mr_lzero(z); } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/mr87f/fastmodsquare.html":{"url":"miracldoc/api/mr87f/fastmodsquare.html","title":"fastmodsquare","keywords":"","body":"fastmodsquare fastmodsquare extern void fastmodsquare(_MIPT_ big,big); void fastmodsquare(_MIPD_ x,z) big x,z; { int ij; #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif big w0=mr_mip->w0; big modulus=mr_mip->modulus; mr_small *wg,*mg,*xg; wg=w0->w; mg=modulus->w; xg=x->w; for (ij=2*MR_PENTIUM;ijlen&MR_OBITS);ij++) w0->w[ij]=0.0; w0->len=2*MR_PENTIUM; ASM { push PDI push PSI mov PBX,xg mov PSI,mg mov PDI,wg fldz MODSQUARE pop PSI pop PDI } for (ij=MR_PENTIUM;ijlen&MR_OBITS);ij++) z->w[ij]=0.0; z->len=MR_PENTIUM; for (ij=0;ijw[ij]=w0->w[ij+MR_PENTIUM]; if (z->w[MR_PENTIUM-1]==0.0) mr_lzero(z); } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/mralloc/mr_alloc.html":{"url":"miracldoc/api/mralloc/mr_alloc.html","title":"mr_alloc","keywords":"","body":"mr_alloc mr_alloc定义在miracl.h，实现在mralloc.c extern void *mr_alloc(_MIPT_ int,int); 函数功能：创建一个大小为num×sizenum \\times sizenum×size字节的空间，返回void *类型指针。 参数_MIPT_：可能为空，非空为miracl *类型。 参数num：整数。 参数size：整数。 源码分析 mr_alloc实现的相关内容如下。 void *mr_alloc(_MIPD_ int num,int size) { char *p; #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif if (mr_mip==NULL) { p=(char *)calloc(num,size); return (void *)p; } if (mr_mip->ERNUM) return NULL; p=(char *)calloc(num,size); if (p==NULL) mr_berror(_MIPP_ MR_ERR_OUT_OF_MEMORY); return (void *)p; } get_mip返回miracl *指针。 mr_berror按照错误类型打印提示。 MR_ERR_OUT_OF_MEMORY为字符常量。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/mrcurve/ecurve_add.html":{"url":"miracldoc/api/mrcurve/ecurve_add.html","title":"ecurve_add","keywords":"","body":"ecurve_add ecurve_add定义在miracl.h extern int ecurve_add(_MIPT_ epoint *,epoint *); 函数功能：椭圆曲线上的两个点相加，pa=pa+p。 参数_MIPD_：可能为空，非空为miracl *类型。 参数p：椭圆曲线上的点。 参数pa：椭圆曲线上的点。 源码分析 ecurve_add实现在mrcurve.c int ecurve_add(_MIPD_ epoint *p,epoint *pa) { /* pa=pa+p; */ #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif if (mr_mip->ERNUM) return MR_OVER; MR_IN(94) if (p==pa) { ecurve_double(_MIPP_ pa); MR_OUT if (pa->marker==MR_EPOINT_INFINITY) return MR_OVER; return MR_DOUBLE; } if (pa->marker==MR_EPOINT_INFINITY) { epoint_copy(p,pa); MR_OUT return MR_ADD; } if (p->marker==MR_EPOINT_INFINITY) { MR_OUT return MR_ADD; } if (!ecurve_padd(_MIPP_ p,pa)) { ecurve_double(_MIPP_ pa); MR_OUT return MR_DOUBLE; } MR_OUT if (pa->marker==MR_EPOINT_INFINITY) return MR_OVER; return MR_ADD; } int ecurve_add(_MIPD_ epoint *p,epoint *pa) { /* pa=pa+p; */ #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif if (mr_mip->ERNUM) return MR_OVER; MR_IN(94) if (p==pa) { ecurve_double(_MIPP_ pa); MR_OUT if (pa->marker==MR_EPOINT_INFINITY) return MR_OVER; return MR_DOUBLE; } if (pa->marker==MR_EPOINT_INFINITY) { epoint_copy(p,pa); MR_OUT return MR_ADD; } if (p->marker==MR_EPOINT_INFINITY) { MR_OUT return MR_ADD; } if (!ecurve_padd(_MIPP_ p,pa)) { ecurve_double(_MIPP_ pa); MR_OUT return MR_DOUBLE; } MR_OUT if (pa->marker==MR_EPOINT_INFINITY) return MR_OVER; return MR_ADD; } get_mip ecurve_double ecurve_padd © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/mrcurve/ecurve_double.html":{"url":"miracldoc/api/mrcurve/ecurve_double.html","title":"ecurve_double","keywords":"","body":"ecurve_double ecurve_double定义在miracl.h extern void ecurve_double(_MIPT_ epoint*); 函数功能： 参数_MIPD_：可能为空，非空为miracl *类型。 参数p：椭圆曲线上的点。 源码分析 void ecurve_double(_MIPD_ epoint *p) { /* double epoint on active ecurve */ #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif if (mr_mip->ERNUM) return; // 如果是无穷远点，直接返回 if (p->marker==MR_EPOINT_INFINITY) { /* 2 times infinity == infinity ! */ return; } #ifndef MR_AFFINE_ONLY if (mr_mip->coord==MR_AFFINE) { /* 2 sqrs, 1 mul, 1 div */ #endif if (size(p->Y)==0) { /* set to point at infinity */ epoint_set(_MIPP_ NULL,NULL,0,p); return; } nres_modmult(_MIPP_ p->X,p->X,mr_mip->w8); /* w8=x^2 */ nres_premult(_MIPP_ mr_mip->w8,3,mr_mip->w8); /* w8=3*x^2 */ if (mr_abs(mr_mip->Asize) == MR_TOOBIG) nres_modadd(_MIPP_ mr_mip->w8,mr_mip->A,mr_mip->w8); else { convert(_MIPP_ mr_mip->Asize,mr_mip->w2); nres(_MIPP_ mr_mip->w2,mr_mip->w2); nres_modadd(_MIPP_ mr_mip->w8,mr_mip->w2,mr_mip->w8); } /* w8=3*x^2+A */ nres_premult(_MIPP_ p->Y,2,mr_mip->w6); /* w6=2y */ if (nres_moddiv(_MIPP_ mr_mip->w8,mr_mip->w6,mr_mip->w8)>1) { epoint_set(_MIPP_ NULL,NULL,0,p); mr_berror(_MIPP_ MR_ERR_COMPOSITE_MODULUS); return; } /* w8 is slope m on exit */ nres_modmult(_MIPP_ mr_mip->w8,mr_mip->w8,mr_mip->w2); /* w2=m^2 */ nres_premult(_MIPP_ p->X,2,mr_mip->w1); nres_modsub(_MIPP_ mr_mip->w2,mr_mip->w1,mr_mip->w1); /* w1=m^2-2x */ nres_modsub(_MIPP_ p->X,mr_mip->w1,mr_mip->w2); nres_modmult(_MIPP_ mr_mip->w2,mr_mip->w8,mr_mip->w2); nres_modsub(_MIPP_ mr_mip->w2,p->Y,p->Y); copy(mr_mip->w1,p->X); return; #ifndef MR_AFFINE_ONLY } if (size(p->Y)==0) // 如果Y转换后等于0，设置为无穷远点 { /* set to point at infinity */ epoint_set(_MIPP_ NULL,NULL,0,p); return; } convert(_MIPP_ 1,mr_mip->w1); // 将1转换为`big`类型数据。 if (mr_abs(mr_mip->Asize) Asize!=0) { if (p->marker==MR_EPOINT_NORMALIZED) nres(_MIPP_ mr_mip->w1,mr_mip->w6); else nres_modmult(_MIPP_ p->Z,p->Z,mr_mip->w6); } if (mr_mip->Asize==(-3)) { /* a is -3. Goody. 4 sqrs, 4 muls */ nres_modsub(_MIPP_ p->X,mr_mip->w6,mr_mip->w3); nres_modadd(_MIPP_ p->X,mr_mip->w6,mr_mip->w8); nres_modmult(_MIPP_ mr_mip->w3,mr_mip->w8,mr_mip->w3); nres_modadd(_MIPP_ mr_mip->w3,mr_mip->w3,mr_mip->w8); nres_modadd(_MIPP_ mr_mip->w8,mr_mip->w3,mr_mip->w8); } else { /* a is small */ if (mr_mip->Asize!=0) { /* a is non zero! */ nres_modmult(_MIPP_ mr_mip->w6,mr_mip->w6,mr_mip->w3); nres_premult(_MIPP_ mr_mip->w3,mr_mip->Asize,mr_mip->w3); } nres_modmult(_MIPP_ p->X,p->X,mr_mip->w1); nres_modadd(_MIPP_ mr_mip->w1,mr_mip->w1,mr_mip->w8); nres_modadd(_MIPP_ mr_mip->w8,mr_mip->w1,mr_mip->w8); if (mr_mip->Asize!=0) nres_modadd(_MIPP_ mr_mip->w8,mr_mip->w3,mr_mip->w8); } } else { /* a is not special */ if (p->marker==MR_EPOINT_NORMALIZED) nres(_MIPP_ mr_mip->w1,mr_mip->w6); else nres_modmult(_MIPP_ p->Z,p->Z,mr_mip->w6); nres_modmult(_MIPP_ mr_mip->w6,mr_mip->w6,mr_mip->w3); nres_modmult(_MIPP_ mr_mip->w3,mr_mip->A,mr_mip->w3); nres_modmult(_MIPP_ p->X,p->X,mr_mip->w1); nres_modadd(_MIPP_ mr_mip->w1,mr_mip->w1,mr_mip->w8); nres_modadd(_MIPP_ mr_mip->w8,mr_mip->w1,mr_mip->w8); nres_modadd(_MIPP_ mr_mip->w8,mr_mip->w3,mr_mip->w8); } /* w8 contains numerator of slope 3x^2+A.z^4 * * denominator is now placed in Z */ nres_modmult(_MIPP_ p->Y,p->Y,mr_mip->w2); nres_modmult(_MIPP_ p->X,mr_mip->w2,mr_mip->w3); nres_modadd(_MIPP_ mr_mip->w3,mr_mip->w3,mr_mip->w3); nres_modadd(_MIPP_ mr_mip->w3,mr_mip->w3,mr_mip->w3); nres_modmult(_MIPP_ mr_mip->w8,mr_mip->w8,p->X); nres_modsub(_MIPP_ p->X,mr_mip->w3,p->X); nres_modsub(_MIPP_ p->X,mr_mip->w3,p->X); if (p->marker==MR_EPOINT_NORMALIZED) copy(p->Y,p->Z); else nres_modmult(_MIPP_ p->Z,p->Y,p->Z); nres_modadd(_MIPP_ p->Z,p->Z,p->Z); nres_modadd(_MIPP_ mr_mip->w2,mr_mip->w2,mr_mip->w7); nres_modmult(_MIPP_ mr_mip->w7,mr_mip->w7,mr_mip->w2); nres_modadd(_MIPP_ mr_mip->w2,mr_mip->w2,mr_mip->w2); nres_modsub(_MIPP_ mr_mip->w3,p->X,mr_mip->w3); nres_modmult(_MIPP_ mr_mip->w8,mr_mip->w3,p->Y); nres_modsub(_MIPP_ p->Y,mr_mip->w2,p->Y); /* alternative method nres_modadd(_MIPP_ p->Y,p->Y,mr_mip->w2); if (p->marker==MR_EPOINT_NORMALIZED) copy(mr_mip->w2,p->Z); else nres_modmult(_MIPP_ mr_mip->w2,p->Z,p->Z); nres_modmult(_MIPP_ mr_mip->w2,mr_mip->w2,mr_mip->w2); nres_modmult(_MIPP_ p->X,mr_mip->w2,mr_mip->w3); nres_modadd(_MIPP_ mr_mip->w3,mr_mip->w3,p->X); nres_modmult(_MIPP_ mr_mip->w8,mr_mip->w8,mr_mip->w1); nres_modsub(_MIPP_ mr_mip->w1,p->X,p->X); nres_modmult(_MIPP_ mr_mip->w2,mr_mip->w2,mr_mip->w2); if (remain(_MIPP_ mr_mip->w2,2)!=0) mr_padd(_MIPP_ mr_mip->w2,mr_mip->modulus,mr_mip->w2); subdiv(_MIPP_ mr_mip->w2,2,mr_mip->w2); nres_modsub(_MIPP_ mr_mip->w3,p->X,mr_mip->w3); nres_modmult(_MIPP_ mr_mip->w3,mr_mip->w8,mr_mip->w3); nres_modsub(_MIPP_ mr_mip->w3,mr_mip->w2,p->Y); */ /* Observe that when finished w8 contains the line slope, w7 has 2y^2 and w6 has z^2 This is useful for calculating line functions in pairings */ p->marker=MR_EPOINT_GENERAL; return; #endif } size convert将有符号int类型数据转换为big类型数据。 nres_modmult © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/mrcurve/ecurve_mult.html":{"url":"miracldoc/api/mrcurve/ecurve_mult.html","title":"ecurve_mult","keywords":"","body":"ecurve_mult extern int ecurve_mult(_MIPT_ big,epoint *,epoint *); int ecurve_mult(_MIPD_ big e,epoint *pa,epoint *pt) { /* pt=e*pa; */ int i,j,n,nb,nbs,nzs,nadds; epoint *table[MR_ECC_STORE_N]; #ifndef MR_AFFINE_ONLY big work[MR_ECC_STORE_N]; #endif #ifdef MR_STATIC char mem[MR_ECP_RESERVE(MR_ECC_STORE_N)]; #ifndef MR_AFFINE_ONLY char mem1[MR_BIG_RESERVE(MR_ECC_STORE_N)]; #endif #else char *mem; #ifndef MR_AFFINE_ONLY char *mem1; #endif #endif #ifndef MR_ALWAYS_BINARY epoint *p; int ce,ch; #endif #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif if (mr_mip->ERNUM) return 0; MR_IN(95) if (size(e)==0) { /* multiplied by 0 */ epoint_set(_MIPP_ NULL,NULL,0,pt); MR_OUT return 0; } copy(e,mr_mip->w9); /* epoint_norm(_MIPP_ pa); */ epoint_copy(pa,pt); if (size(mr_mip->w9)w9,mr_mip->w9); epoint_negate(_MIPP_ pt); } if (size(mr_mip->w9)==1) { MR_OUT return 0; } premult(_MIPP_ mr_mip->w9,3,mr_mip->w10); /* h=3*e */ #ifndef MR_STATIC #ifndef MR_ALWAYS_BINARY if (mr_mip->base==mr_mip->base2) { #endif #endif #ifdef MR_STATIC memset(mem,0,MR_ECP_RESERVE(MR_ECC_STORE_N)); #ifndef MR_AFFINE_ONLY memset(mem1,0,MR_BIG_RESERVE(MR_ECC_STORE_N)); #endif #else mem=(char *)ecp_memalloc(_MIPP_ MR_ECC_STORE_N); #ifndef MR_AFFINE_ONLY mem1=(char *)memalloc(_MIPP_ MR_ECC_STORE_N); #endif #endif for (i=0;iw10); nadds=0; epoint_set(_MIPP_ NULL,NULL,0,pt); for (i=nb-1;i>=1;) { /* add/subtract */ if (mr_mip->user!=NULL) (*mr_mip->user)(); n=mr_naf_window(_MIPP_ mr_mip->w9,mr_mip->w10,i,&nbs,&nzs,MR_ECC_STORE_N); for (j=0;j0) {ecurve_add(_MIPP_ table[n/2],pt); nadds++;} if (nw10)-1,mr_mip->w11); mr_psub(_MIPP_ mr_mip->w10,mr_mip->w11,mr_mip->w10); subdiv(_MIPP_ mr_mip->w11,2,mr_mip->w11); while (size(mr_mip->w11) > 1) { /* add/subtract method */ if (mr_mip->user!=NULL) (*mr_mip->user)(); ecurve_double(_MIPP_ pt); ce=mr_compare(mr_mip->w9,mr_mip->w11); /* e(i)=1? */ ch=mr_compare(mr_mip->w10,mr_mip->w11); /* h(i)=1? */ if (ch>=0) { /* h(i)=1 */ if (cew10,mr_mip->w11,mr_mip->w10); } if (ce>=0) { /* e(i)=1 */ if (chw9,mr_mip->w11,mr_mip->w9); } subdiv(_MIPP_ mr_mip->w11,2,mr_mip->w11); } ecp_memkill(_MIPP_ mem,1); } #endif #endif MR_OUT return nadds; } int ecurve_mult(_MIPD_ big e,epoint *pa,epoint *pt) { /* pt=e*pa; */ int i,j,n,nb,nbs,nzs,nadds; epoint *table[MR_ECC_STORE_N]; #ifdef MR_STATIC char mem[MR_ECP_RESERVE(MR_ECC_STORE_N)]; #else char *mem; #endif #ifndef MR_ALWAYS_BINARY epoint *p; int ce,ch; #endif #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif if (mr_mip->ERNUM) return 0; MR_IN(95) if (size(e)==0) { /* multiplied by 0 */ epoint_set(_MIPP_ NULL,NULL,0,pt); MR_OUT return 0; } copy(e,mr_mip->w9); epoint_copy(pa,pt); if (size(mr_mip->w9)w9,mr_mip->w9); epoint_negate(_MIPP_ pt); } if (size(mr_mip->w9)==1) { MR_OUT return 0; } premult(_MIPP_ mr_mip->w9,3,mr_mip->w10); /* h=3*e */ #ifndef MR_STATIC #ifndef MR_ALWAYS_BINARY if (mr_mip->base==mr_mip->base2) { #endif #endif #ifdef MR_STATIC memset(mem,0,MR_ECP_RESERVE(MR_ECC_STORE_N)); #else mem=(char *)ecp_memalloc(_MIPP_ MR_ECC_STORE_N); #endif for (i=0;iw10); nadds=0; epoint_set(_MIPP_ NULL,NULL,0,pt); for (i=nb-1;i>=1;) { /* add/subtract */ if (mr_mip->user!=NULL) (*mr_mip->user)(); n=mr_naf_window(_MIPP_ mr_mip->w9,mr_mip->w10,i,&nbs,&nzs,MR_ECC_STORE_N); for (j=0;j0) {ecurve_add(_MIPP_ table[n/2],pt); nadds++;} if (nw10)-1,mr_mip->w11); mr_psub(_MIPP_ mr_mip->w10,mr_mip->w11,mr_mip->w10); subdiv(_MIPP_ mr_mip->w11,2,mr_mip->w11); while (size(mr_mip->w11) > 1) { /* add/subtract method */ if (mr_mip->user!=NULL) (*mr_mip->user)(); ecurve_double(_MIPP_ pt); ce=mr_compare(mr_mip->w9,mr_mip->w11); /* e(i)=1? */ ch=mr_compare(mr_mip->w10,mr_mip->w11); /* h(i)=1? */ if (ch>=0) { /* h(i)=1 */ if (cew10,mr_mip->w11,mr_mip->w10); } if (ce>=0) { /* e(i)=1 */ if (chw9,mr_mip->w11,mr_mip->w9); } subdiv(_MIPP_ mr_mip->w11,2,mr_mip->w11); } ecp_memkill(_MIPP_ mem,1); } #endif #endif MR_OUT return nadds; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-14 "},"miracldoc/api/mrcurve/ecurve_padd.html":{"url":"miracldoc/api/mrcurve/ecurve_padd.html","title":"ecurve_padd","keywords":"","body":"ecurve_padd ecurve_padd static BOOL ecurve_padd(_MIPD_ epoint *p,epoint *pa) { /* primitive add two epoints on the active ecurve - pa+=p; * * note that if p is normalized, its Z coordinate isn't used */ #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif #ifndef MR_AFFINE_ONLY if (mr_mip->coord==MR_AFFINE) { /* 1 sqr, 1 mul, 1 div */ #endif nres_modsub(_MIPP_ p->Y,pa->Y,mr_mip->w8); nres_modsub(_MIPP_ p->X,pa->X,mr_mip->w6); if (size(mr_mip->w6)==0) { /* divide by 0 */ if (size(mr_mip->w8)==0) { /* should have doubled ! */ return FALSE; } else { /* point at infinity */ epoint_set(_MIPP_ NULL,NULL,0,pa); return TRUE; } } if (nres_moddiv(_MIPP_ mr_mip->w8,mr_mip->w6,mr_mip->w8)>1) { epoint_set(_MIPP_ NULL,NULL,0,pa); mr_berror(_MIPP_ MR_ERR_COMPOSITE_MODULUS); return TRUE; } nres_modmult(_MIPP_ mr_mip->w8,mr_mip->w8,mr_mip->w2); /* w2=m^2 */ nres_modsub(_MIPP_ mr_mip->w2,p->X,mr_mip->w1); /* w1=m^2-x1-x2 */ nres_modsub(_MIPP_ mr_mip->w1,pa->X,mr_mip->w1); nres_modsub(_MIPP_ pa->X,mr_mip->w1,mr_mip->w2); nres_modmult(_MIPP_ mr_mip->w2,mr_mip->w8,mr_mip->w2); nres_modsub(_MIPP_ mr_mip->w2,pa->Y,pa->Y); copy(mr_mip->w1,pa->X); pa->marker=MR_EPOINT_NORMALIZED; return TRUE; #ifndef MR_AFFINE_ONLY } if (p->marker!=MR_EPOINT_NORMALIZED) { nres_modmult(_MIPP_ p->Z,p->Z,mr_mip->w6); nres_modmult(_MIPP_ pa->X,mr_mip->w6,mr_mip->w1); nres_modmult(_MIPP_ mr_mip->w6,p->Z,mr_mip->w6); nres_modmult(_MIPP_ pa->Y,mr_mip->w6,mr_mip->w8); } else { copy(pa->X,mr_mip->w1); copy(pa->Y,mr_mip->w8); } if (pa->marker==MR_EPOINT_NORMALIZED) copy(mr_mip->one,mr_mip->w6); else nres_modmult(_MIPP_ pa->Z,pa->Z,mr_mip->w6); nres_modmult(_MIPP_ p->X,mr_mip->w6,mr_mip->w4); if (pa->marker!=MR_EPOINT_NORMALIZED) nres_modmult(_MIPP_ mr_mip->w6,pa->Z,mr_mip->w6); nres_modmult(_MIPP_ p->Y,mr_mip->w6,mr_mip->w5); nres_modsub(_MIPP_ mr_mip->w1,mr_mip->w4,mr_mip->w1); nres_modsub(_MIPP_ mr_mip->w8,mr_mip->w5,mr_mip->w8); /* w8 contains the numerator of the slope */ if (size(mr_mip->w1)==0) { if (size(mr_mip->w8)==0) { /* should have doubled ! */ return FALSE; } else { /* point at infinity */ epoint_set(_MIPP_ NULL,NULL,0,pa); return TRUE; } } nres_modadd(_MIPP_ mr_mip->w4,mr_mip->w4,mr_mip->w6); nres_modadd(_MIPP_ mr_mip->w1,mr_mip->w6,mr_mip->w4); nres_modadd(_MIPP_ mr_mip->w5,mr_mip->w5,mr_mip->w6); nres_modadd(_MIPP_ mr_mip->w8,mr_mip->w6,mr_mip->w5); if (p->marker!=MR_EPOINT_NORMALIZED) { if (pa->marker!=MR_EPOINT_NORMALIZED) nres_modmult(_MIPP_ pa->Z,p->Z,mr_mip->w3); else copy(p->Z,mr_mip->w3); nres_modmult(_MIPP_ mr_mip->w3,mr_mip->w1,pa->Z); } else { if (pa->marker!=MR_EPOINT_NORMALIZED) nres_modmult(_MIPP_ pa->Z,mr_mip->w1,pa->Z); else copy(mr_mip->w1,pa->Z); } nres_modmult(_MIPP_ mr_mip->w1,mr_mip->w1,mr_mip->w6); nres_modmult(_MIPP_ mr_mip->w1,mr_mip->w6,mr_mip->w1); nres_modmult(_MIPP_ mr_mip->w6,mr_mip->w4,mr_mip->w6); nres_modmult(_MIPP_ mr_mip->w8,mr_mip->w8,mr_mip->w4); nres_modsub(_MIPP_ mr_mip->w4,mr_mip->w6,pa->X); nres_modsub(_MIPP_ mr_mip->w6,pa->X,mr_mip->w6); nres_modsub(_MIPP_ mr_mip->w6,pa->X,mr_mip->w6); nres_modmult(_MIPP_ mr_mip->w8,mr_mip->w6,mr_mip->w2); nres_modmult(_MIPP_ mr_mip->w1,mr_mip->w5,mr_mip->w1); nres_modsub(_MIPP_ mr_mip->w2,mr_mip->w1,mr_mip->w5); /* divide by 2 */ nres_div2(_MIPP_ mr_mip->w5,pa->Y); pa->marker=MR_EPOINT_GENERAL; return TRUE; #endif } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/mrcurve/ecurve_sub.html":{"url":"miracldoc/api/mrcurve/ecurve_sub.html","title":"ecurve_sub","keywords":"","body":"ecurve_sub extern int ecurve_sub(_MIPT_ epoint *,epoint *); 函数功能：减法运算。 参数_MIPD_：可能为空，非空为miracl *类型。 参数p：epoint类型数据。 参数pa：epoint类型数据。 源码分析 int ecurve_sub(_MIPD_ epoint *p,epoint *pa) { int r; #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif if (mr_mip->ERNUM) return MR_OVER; MR_IN(104) if (p==pa) { epoint_set(_MIPP_ NULL,NULL,0,pa); MR_OUT return MR_OVER; } if (p->marker==MR_EPOINT_INFINITY) { MR_OUT return MR_ADD; } epoint_negate(_MIPP_ p); // 更新坐标 r=ecurve_add(_MIPP_ p,pa); // pa=pa+p epoint_negate(_MIPP_ p); MR_OUT return r; } ecurve_add完成椭圆曲线上的两个点相加，pa=pa+p。 epoint_negate做两个数的减法运算，更新p的坐标。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/mrcurve/epoint_copy.html":{"url":"miracldoc/api/mrcurve/epoint_copy.html","title":"epoint_copy","keywords":"","body":"epoint_copy epoint_copy定义在miracl.h extern void epoint_copy(epoint *,epoint *); mrcurve.c void epoint_copy(epoint *a,epoint *b) { if (a==b || b==NULL) return; copy(a->X,b->X); copy(a->Y,b->Y); copy(a->Z,b->Z); b->marker=a->marker; return; } void epoint_copy(epoint *a,epoint *b) { if (a==b || b==NULL) return; copy(a->X,b->X); copy(a->Y,b->Y); #ifndef MR_AFFINE_ONLY if (a->marker==MR_EPOINT_GENERAL) copy(a->Z,b->Z); #endif b->marker=a->marker; return; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-14 "},"miracldoc/api/mrcurve/epoint_getrhs.html":{"url":"miracldoc/api/mrcurve/epoint_getrhs.html","title":"epoint_getrhs","keywords":"","body":"epoint_getrhs epoint_getrhs ```c ifndef MR_EDWARDS static void epointgetrhs(_MIPD big x,big y) { / x and y must be different / / find x^3+Ax+B / ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); endif nres_modmult(_MIPP_ x,x,y); nres_modmult(_MIPP_ y,x,y); if (mr_abs(mr_mip->Asize)==MR_TOOBIG) nres_modmult(_MIPP_ x,mr_mip->A,mr_mip->w1); else nres_premult(_MIPP_ x,mr_mip->Asize,mr_mip->w1); nres_modadd(_MIPP_ y,mr_mip->w1,y); if (mr_abs(mr_mip->Bsize)==MR_TOOBIG) nres_modadd(_MIPP_ y,mr_mip->B,y); else { convert(_MIPP_ mr_mip->Bsize,mr_mip->w1); nres(_MIPP_ mr_mip->w1,mr_mip->w1); nres_modadd(_MIPP_ y,mr_mip->w1,y); } } else /* Twisted Inverted Edwards curves Assumes Twisted Inverted Edward's equation x^2+Ay^2 = x^2.y^2 + B Assumes points are not of order 2 or 4 */ static void epointgetrhs(_MIPD big x,big y) { / find RHS=(x^2-B)/(x^2-A) / ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); endif nres_modmult(_MIPP_ x,x,mr_mip->w6); nres_modsub(_MIPP_ mr_mip->w6,mr_mip->B,y); nres_modsub(_MIPP_ mr_mip->w6,mr_mip->A,mr_mip->w6); nres_moddiv(_MIPP_ y,mr_mip->w6,y); } endif © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/mrcurve/epoint_negate.html":{"url":"miracldoc/api/mrcurve/epoint_negate.html","title":"epoint_negate","keywords":"","body":"epoint_negate epoint_negate extern void epoint_negate(_MIPT_ epoint *); 函数功能：两个big类型数据的减法运算，减去的值为p中的一个坐标。 参数_MIPD_：可能为空，非空为miracl *类型。 参数p：epoint类型值。 源码分析 void epoint_negate(_MIPD_ epoint *p) { /* negate a point */ #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif if (mr_mip->ERNUM) return; if (p->marker==MR_EPOINT_INFINITY) return; MR_IN(121) if (size(p->Y)!=0) mr_psub(_MIPP_ mr_mip->modulus,p->Y,p->Y); MR_OUT } mr_psub做两个数的减法运算，即p->Y = mr_mip->modulus - p->Y。 void epoint_negate(_MIPD_ epoint *p) { /* negate a point */ #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif if (mr_mip->ERNUM) return; if (p->marker==MR_EPOINT_INFINITY) return; MR_IN(121) if (size(p->X)!=0) mr_psub(_MIPP_ mr_mip->modulus,p->X,p->X); MR_OUT } © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/mrcurve/epoint_set.html":{"url":"miracldoc/api/mrcurve/epoint_set.html","title":"epoint_set","keywords":"","body":"epoint_set epoint_set定义在miracl.h extern BOOL epoint_set(_MIPT_ big,big,int,epoint*); 函数功能：初始化椭圆曲线上的一个点，如果x或者y为NULL，直接设置为无穷点。如果x==y，（如果可能的话）计算y，根据cb确定y的LSB 0/1；否则忽略cb，检验坐标(x,y)。 返回值：如果坐标设置成功，返回TRUE；否则返回FALSE。 参数_MIPT_：可能为空，非空为miracl *类型。 参数x： 参数y： 参数cb： 参数p： 源码分析 epoint_set实现在mrcurve.c BOOL epoint_set(_MIPD_ big x,big y,int cb,epoint *p) { /* initialise a point on active ecurve * * if x or y == NULL, set to point at infinity * * if x==y, a y co-ordinate is calculated - if * * possible - and cb suggests LSB 0/1 of y * * (which \"decompresses\" y). Otherwise, check * * validity of given (x,y) point, ignoring cb. * * Returns TRUE for valid point, otherwise FALSE. */ BOOL valid; #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif if (mr_mip->ERNUM) return FALSE; // 设置`MIRACL`线程的深度 MR_IN(97) // 只要x或y有一个为空， if (x==NULL || y==NULL) { copy(mr_mip->one,p->X); // 将one复制给X zero(p->Y); p->marker=MR_EPOINT_INFINITY; // 状态设置为无穷大 MR_OUT return TRUE; } valid=FALSE; nres(_MIPP_ x,p->X); if (x!=y) { /* Check directly that x^2+Ay^2 == x^2.y^2+B */ nres(_MIPP_ y,p->Y); nres_modmult(_MIPP_ p->X,p->X,mr_mip->w1); nres_modmult(_MIPP_ p->Y,p->Y,mr_mip->w2); nres_modmult(_MIPP_ mr_mip->w1,mr_mip->w2,mr_mip->w3); nres_modadd(_MIPP_ mr_mip->w3,mr_mip->B,mr_mip->w3); if (mr_abs(mr_mip->Asize)==MR_TOOBIG) nres_modmult(_MIPP_ mr_mip->w2,mr_mip->A,mr_mip->w2); else nres_premult(_MIPP_ mr_mip->w2,mr_mip->Asize,mr_mip->w2); nres_modadd(_MIPP_ mr_mip->w2,mr_mip->w1,mr_mip->w2); if (mr_compare(mr_mip->w2,mr_mip->w3)==0) valid=TRUE; } else { /* find RHS */ epoint_getrhs(_MIPP_ p->X,mr_mip->w7); /* no y supplied - calculate one. Find square root */ #ifndef MR_NOSUPPORT_COMPRESSION valid=nres_sqroot(_MIPP_ mr_mip->w7,p->Y); /* check LSB - have we got the right root? */ redc(_MIPP_ p->Y,mr_mip->w1); if (remain(_MIPP_ mr_mip->w1,2)!=cb) mr_psub(_MIPP_ mr_mip->modulus,p->Y,p->Y); #else mr_berror(_MIPP_ MR_ERR_NOT_SUPPORTED); MR_OUT return FALSE; #endif } if (valid) { p->marker=MR_EPOINT_NORMALIZED; MR_OUT return TRUE; } MR_OUT return FALSE; } 关于BOOL类型的定义和可选值，参考字符常量。 get_mip返回miracl *指针，如果没有定义MR_OS_THREADS，由_MIPD_接收。 MR_EPOINT_INFINITY表示无穷大，其值参考字符常量。 copy将x轴坐标复制给y轴坐标。 MR_IN和MR_OUT设置线程的进退码。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/mrkcm/kcm_mul.html":{"url":"miracldoc/api/mrkcm/kcm_mul.html","title":"kcm_mul","keywords":"","body":"kcm_mul kcm_mul extern void kcm_mul(_MIPT_ big,big,big); 函数功能： 参数： 源码分析 kcm_mul在模板文件mrkcm.tpl中实现。 void kcm_mul(_MIPD_ big x,big y,big z) { /* fast karatsuba multiplication */ unsigned int i; #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif int ml=(int)mr_mip->modulus->len; zero(mr_mip->w0); for (i=2*ml;iwt->len&MR_OBITS);i++) mr_mip->wt->w[i]=0; mr_karmul(ml,mr_mip->wt->w,x->w,y->w,mr_mip->w0->w); mr_mip->w0->len=mr_mip->wt->len=2*ml; copy(mr_mip->w0,z); } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrkcm/kcm_multiply.html":{"url":"miracldoc/api/mrkcm/kcm_multiply.html","title":"kcm_multiply","keywords":"","body":"kcm_multiply kcm_multiply extern void kcm_multiply(_MIPT_ int,big,big,big); 函数功能： 参数： 源码分析 kcm_multiply在模板文件mrkcm.tpl中实现。 void kcm_multiply(_MIPD_ int n,big x,big y,big z) { /* n *must* be MR_KCM*2^m for m>=0 */ unsigned int i; #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif zero(mr_mip->w0); for (i=2*n;iwt->len&MR_OBITS);i++) mr_mip->wt->w[i]=0; mr_karmul(n,mr_mip->wt->w,x->w,y->w,mr_mip->w0->w); mr_mip->w0->len=mr_mip->wt->len=2*n; copy(mr_mip->w0,z); } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrkcm/kcm_redc.html":{"url":"miracldoc/api/mrkcm/kcm_redc.html","title":"kcm_redc","keywords":"","body":"kcm_redc kcm_redc extern void kcm_redc(_MIPT_ big,big); 函数功能： 参数： 源码分析 kcm_redc在模板文件mrkcm.tpl中实现。 void kcm_redc(_MIPD_ big z,big w) { /* fast karatsuba Montgomery reduction */ #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif int m,ml=(int)mr_mip->modulus->len; unsigned int i; m=ml/MR_KCM; copy(z,mr_mip->w0); for (i=2*ml;iwt->len&MR_OBITS);i++) mr_mip->wt->w[i]=0; mr_cpy(&(mr_mip->w0->w[ml]),w->w,m); mr_karmul_lower(ml,mr_mip->wt->w,mr_mip->w0->w,mr_mip->big_ndash->w,mr_mip->ws->w); for (i=ml;ilen&MR_OBITS);i++) w->w[i]=0; mr_mip->ws->len=w->len=ml; mr_karmul_upper(ml,mr_mip->wt->w,mr_mip->ws->w,mr_mip->modulus->w,mr_mip->w0->w); mr_mip->w0->len=mr_mip->wt->len=2*ml; if (mr_decn(&(mr_mip->w0->w[ml]),w->w,m)) mr_incn(mr_mip->modulus->w,w->w,m); mr_lzero(w); } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrkcm/kcm_sqr.html":{"url":"miracldoc/api/mrkcm/kcm_sqr.html","title":"kcm_sqr","keywords":"","body":"kcm_sqr kcm_sqr extern void kcm_sqr(_MIPT_ big,big); 函数功能： 参数： 源码分析 kcm_sqr在模板文件mrkcm.tpl中实现。 void kcm_sqr(_MIPD_ big x,big z) { /* fast karatsuba squaring */ #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif unsigned int i; int ml=(int)mr_mip->modulus->len; zero(mr_mip->w0); for (i=2*ml;iwt->len&MR_OBITS);i++) mr_mip->wt->w[i]=0; mr_karsqr(ml,mr_mip->wt->w,x->w,mr_mip->w0->w); mr_mip->w0->len=mr_mip->wt->len=2*ml; copy(mr_mip->w0,z); } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrkcm/kcm_square.html":{"url":"miracldoc/api/mrkcm/kcm_square.html","title":"kcm_square","keywords":"","body":"kcm_square kcm_square extern void kcm_square(_MIPT_ int,big,big); 函数功能： 参数： 源码分析 kcm_square在模板文件mrkcm.tpl中实现。 void kcm_square(_MIPD_ int n,big x,big z) { /* n *must* be MR_KCM*2^m for m>=0 */ unsigned int i; #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif zero(mr_mip->w0); for (i=2*n;iwt->len&MR_OBITS);i++) mr_mip->wt->w[i]=0; mr_karsqr(n,mr_mip->wt->w,x->w,mr_mip->w0->w); mr_mip->w0->len=mr_mip->wt->len=2*n; copy(mr_mip->w0,z); } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrkcm/kcm_top.html":{"url":"miracldoc/api/mrkcm/kcm_top.html","title":"kcm_top","keywords":"","body":"kcm_top kcm_top extern BOOL kcm_top(_MIPT_ int,big,big,big); 函数功能： 参数： 源码分析 kcm_top在模板文件mrkcm.tpl中实现。 BOOL kcm_top(_MIPD_ int n,big x,big y,big z) { /* to support floating-point - see float.cpp and fmth function in big.cpp */ #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif unsigned int i; int len; zero(mr_mip->w0); if (ncheck=OFF; multiply(_MIPP_ x,y,mr_mip->w0); mr_mip->check=ON; } else { for (i=2*n;iwt->len&MR_OBITS);i++) mr_mip->wt->w[i]=0; if (x==y) mr_karsqr(n,mr_mip->wt->w,x->w,mr_mip->w0->w); else mr_karmul(n,mr_mip->wt->w,x->w,y->w,mr_mip->w0->w); mr_mip->w0->len=mr_mip->wt->len=2*n; mr_lzero(mr_mip->w0); } len=mr_lent(mr_mip->w0); mr_shift(_MIPP_ mr_mip->w0,n-len,mr_mip->w0); copy(mr_mip->w0,z); if (len © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrkcm/mr_addn.html":{"url":"miracldoc/api/mrkcm/mr_addn.html","title":"mr_addn","keywords":"","body":"mr_addn mr_addn 函数功能： 参数： static int mr_addn(mr_small *x,mr_small *y,mr_small *z,int n) { /* add two arrays of length n*MR_KCM */ /* first some macros */ mr_small *a,*b,*c; mr_small carry; #ifdef MR_ITANIUM register mr_small ma,u; #endif #ifdef MR_WIN64 mr_small ma,u; #endif #ifdef MR_NOASM mr_large u; #endif a=x; b=y; c=z; /*** SUMMATION ***/ return (int)carry; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrkcm/mr_comba_halfm.html":{"url":"miracldoc/api/mrkcm/mr_comba_halfm.html","title":"mr_comba_halfm","keywords":"","body":"mr_comba_halfm mr_comba_halfm 函数功能： 参数： static void mr_comba_halfm(mr_small *x,mr_small *y,mr_small *z) { /* multiply two arrays, but only return lower half */ mr_small *a,*b,*c; #ifdef MR_ITANIUM register mr_small lo1,hi1,lo2,hi2,ma,mb,sumlo,sumhi,extra; #endif #ifdef MR_WIN64 mr_small lo,hi,sumlo,sumhi,extra; #endif #ifdef MR_NOASM #ifdef mr_qltype mr_large pp1; mr_vlarge sum; #else register mr_small extra,s0,s1; mr_large pp1,pp2,sum; #endif #endif a=x; b=y; c=z; /*** MULTUP ***/ } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrkcm/mr_comba_mul.html":{"url":"miracldoc/api/mrkcm/mr_comba_mul.html","title":"mr_comba_mul","keywords":"","body":"mr_comba_mul mr_comba_mul 函数功能： 参数： static void mr_comba_mul(mr_small *x,mr_small *y,mr_small *z) { /* multiply two arrays of length MR_KCM */ mr_small *a,*b,*c; #ifdef MR_WIN64 mr_small lo,hi,sumlo,sumhi,extra; #endif #ifdef MR_ITANIUM register mr_small lo1,hi1,lo2,hi2,ma,mb,sumlo,sumhi,extra; #endif #ifdef MR_NOASM #ifdef mr_qltype mr_large pp1; mr_vlarge sum; #else register mr_small extra,s0,s1; mr_large pp1,pp2,sum; #endif #endif a=x; b=y; c=z; /*** MULTIPLY ***/ } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrkcm/mr_comba_sqr.html":{"url":"miracldoc/api/mrkcm/mr_comba_sqr.html","title":"mr_comba_sqr","keywords":"","body":"mr_comba_sqr mr_comba_sqr 函数功能： 参数： static void mr_comba_sqr(mr_small *x,mr_small *z) { /* square an array of length MR_KCM */ mr_small *a,*c; #ifdef MR_ITANIUM register mr_small lo1,hi1,lo2,hi2,ma,mb,sumlo,sumhi,extra; #endif #ifdef MR_WIN64 mr_small lo,hi,sumlo,sumhi,extra,cy; #endif #ifdef MR_NOASM #ifdef mr_qltype mr_large pp1; mr_vlarge sum; #else register mr_small extra,s0,s1; mr_large pp1,pp2,sum; #endif #endif a=x; c=z; /*** SQUARE ***/ } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrkcm/mr_cpy.html":{"url":"miracldoc/api/mrkcm/mr_cpy.html","title":"mr_cpy","keywords":"","body":"mr_cpy mr_cpy 函数功能： 参数： static void mr_cpy(mr_small *x,mr_small *z,int n) { /* copy an array of length n*MR_KCM */ int m; for (m=0;m © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrkcm/mr_decn.html":{"url":"miracldoc/api/mrkcm/mr_decn.html","title":"mr_decn","keywords":"","body":"mr_decn mr_decn 函数功能： 参数： static int mr_decn(mr_small *y,mr_small *z,int n) { /* subtract from an array of length n*MR_KCM */ mr_small *a,*b; mr_small carry; #ifdef MR_WIN64 mr_small ma,u; #endif #ifdef MR_ITANIUM register mr_small ma,u; #endif #ifdef MR_NOASM mr_large u; #endif a=z; b=y; /*** DECREMENTATION */ return (int)carry; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrkcm/mr_incn.html":{"url":"miracldoc/api/mrkcm/mr_incn.html","title":"mr_incn","keywords":"","body":"mr_incn mr_incn 函数功能： 参数： static int mr_incn(mr_small *y,mr_small *z,int n) { /* add to an array of length n*MR_KCM */ mr_small *a,*b; mr_small carry; #ifdef MR_WIN64 mr_small ma,u; #endif #ifdef MR_ITANIUM register mr_small ma,u; #endif #ifdef MR_NOASM mr_large u; #endif a=z; b=y; /*** INCREMENTATION */ return (int)carry; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrkcm/mr_karmul.html":{"url":"miracldoc/api/mrkcm/mr_karmul.html","title":"mr_karmul","keywords":"","body":"mr_karmul mr_karmul 函数功能： 参数： static void mr_karmul(int n,mr_small *t,mr_small *x,mr_small *y,mr_small *z) { /* full multiplication z=x*y */ int i,nd2,m,md2; mr_small c1,c2,c=0; if (n==MR_KCM) { /* reached the bottom... */ mr_comba_mul(x,y,z); return; } nd2=n/2; m=n/MR_KCM; md2=m/2; c1=mr_addn(x,&x[nd2],z,md2); c2=mr_addn(y,&y[nd2],&z[nd2],md2); mr_karmul(nd2,&t[n],z,&z[nd2],t); if (c1) c+=mr_incn(&z[nd2],&t[nd2],md2); if (c2) c+=mr_incn(z,&t[nd2],md2); if (c1&c2) c++; /* form (a0+a1).(b0+b1), carry in c */ mr_karmul(nd2,&t[n],x,y,z); c-=mr_decn(z,t,m); /* subtract a0.b0 */ mr_karmul(nd2,&t[n],&x[nd2],&y[nd2],&z[n]); c-=mr_decn(&z[n],t,m); /* subtract a1.b1 */ c+=mr_incn(t,&z[nd2],m); /* combine results */ i=n+nd2; z[i]+=c; if (z[i] © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrkcm/mr_karmul_lower.html":{"url":"miracldoc/api/mrkcm/mr_karmul_lower.html","title":"mr_karmul_lower","keywords":"","body":"mr_karmul_lower mr_karmul_lower 函数功能： 参数： static void mr_karmul_lower(int n,mr_small *t,mr_small *x,mr_small *y,mr_small *z) { /* Calculates Least Significant bottom half of x*y */ int nd2,m,md2; if (n==MR_KCM) { /* only calculate bottom half of product */ mr_comba_halfm(x,y,z); return; } nd2=n/2; m=n/MR_KCM; md2=m/2; mr_karmul(nd2,&t[n],x,y,z); mr_karmul_lower(nd2,&t[n],&x[nd2],y,t); mr_incn(t,&z[nd2],md2); mr_karmul_lower(nd2,&t[n],x,&y[nd2],t); mr_incn(t,&z[nd2],md2); } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrkcm/mr_karmul_upper.html":{"url":"miracldoc/api/mrkcm/mr_karmul_upper.html","title":"mr_karmul_upper","keywords":"","body":"mr_karmul_upper mr_karmul_upper 函数功能： 参数： static void mr_karmul_upper(int n,mr_small *t,mr_small *x,mr_small *y,mr_small *z) { /* Calculates Most Significant upper half of x*y, given lower part */ int i,nd2,m,md2; mr_small c1,c2,c=0; if (n==MR_KCM) { mr_comba_mul(x,y,z); return; } nd2=n/2; m=n/MR_KCM; md2=m/2; c1=mr_addn(x,&x[nd2],&z[n],md2); c2=mr_addn(y,&y[nd2],&z[n+nd2],md2); mr_karmul(nd2,&t[n],&z[n],&z[n+nd2],t); if (c1) c+=mr_incn(&z[n+nd2],&t[nd2],md2); if (c2) c+=mr_incn(&z[n],&t[nd2],md2); if (c1&c2) c++; /* form (a0+a1)(b0+b1), carry in c */ mr_karmul(nd2,&t[n],&x[nd2],&y[nd2],&z[n]); c-=mr_decn(&z[n],t,m); /* subtract a1.b1 */ /* recreate a0.b0 in z */ mr_incn(z,&z[nd2],md2); mr_decn(t,&z[nd2],md2); c-=mr_decn(z,t,m); /* subtract a0.b0 */ c+=mr_incn(t,&z[nd2],m); i=n+nd2; z[i]+=c; if (z[i] © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/mrkcm/mr_karsqr.html":{"url":"miracldoc/api/mrkcm/mr_karsqr.html","title":"mr_karsqr","keywords":"","body":"mr_karsqr mr_karsqr 函数功能： 参数： static void mr_karsqr(int n,mr_small *t,mr_small *x,mr_small *z) { /* Squaring z=x*x */ int i,nd2,m; mr_small c; if (n==MR_KCM) { mr_comba_sqr(x,z); return; } nd2=n/2; m=n/MR_KCM; mr_karsqr(nd2,&t[n],x,z); mr_karsqr(nd2,&t[n],&x[nd2],&z[n]); mr_karmul(nd2,&t[n],x,&x[nd2],t); c=mr_incn(t,&z[nd2],m); c+=mr_incn(t,&z[nd2],m); i=n+nd2; z[i]+=c; if (z[i] © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-21 "},"miracldoc/api/miracl/mr_abs.html":{"url":"miracldoc/api/miracl/mr_abs.html","title":"mr_abs","keywords":"","body":"mr_abs mr_abs #define mr_abs(x) ((x) © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/miracl/mr_big_reserve.html":{"url":"miracldoc/api/miracl/mr_big_reserve.html","title":"mr_big_reserve","keywords":"","body":"mr_big_reserve mr_big_reserve定义在miracl.h /* useful macro to convert size of big in words, to size of required structure */ #define mr_big_reserve(n,m) ((n)*mr_size(m)+MR_SL) 函数功能：计算得到(n)*mr_size(m)+sizeof(long)个字节。 参数n：整数。 参数m：整数。 MR_SL为long类型数据占用的字节数，mr_size计算返回字节数。 #define MR_SL sizeof(long) © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/miracl/MR_DIV.html":{"url":"miracldoc/api/miracl/MR_DIV.html","title":"MR_DIV","keywords":"","body":"MR_DIV MR_DIV定义在miracl.h，返回商。 #ifdef MR_FP #define MR_DIV(a,b) (modf((a)/(b),&dres),dres) #else #define MR_DIV(a,b) ((a)/(b)) #endif modf((a)/(b),&dres)将浮点数分解为整数部分和小数部分，(modf((a)/(b),&dres),dres)为逗号表达式，返回最后一项。 modf() modf是C语言库math.h中提供的函数 extern double modf(double x, double *intptr); 函数功能：将浮点数分解为整数部分和小数部分，提取浮点数 x 的整数部分和小数部分，整数部分被存到参数 intptr，小数部分被放入返回值中。 参数x：想要分解的浮点数。 参数intptr：一个指向double类型的指针，用于存储x的整数部分（也就是商），符号与x相同。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/miracl/mr_ecp_reserve.html":{"url":"miracldoc/api/miracl/mr_ecp_reserve.html","title":"mr_ecp_reserve","keywords":"","body":"mr_ecp_reserve() mr_ecp_reserve函数定义在miracl.h。 #define mr_ecp_reserve(n,m) ((n)*mr_esize(m)+MR_SL) 函数功能：返回字节数。计算得到(n)*mr_esize(m)+sizeof(long)个字符。 参数n：整数。 参数m：整数。 函数实现中，用到mr_esize。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/miracl/mr_ecp_reserve_a.html":{"url":"miracldoc/api/miracl/mr_ecp_reserve_a.html","title":"mr_ecp_reserve_a","keywords":"","body":"mr_ecp_reserve_a mr_ecp_reserve_a定义在miracl.h #define mr_ecp_reserve_a(n,m) ((n)*mr_esize_a(m)+MR_SL) 函数功能：返回字节数。 参数n：整数。 参数m：整数。 函数实现中用mr_esize_a计算字节数。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/miracl/mr_esize.html":{"url":"miracldoc/api/miracl/mr_esize.html","title":"mr_esize","keywords":"","body":"mr_esize mr_esize定义在miracl.h 如果定义了MR_AFFINE_ONLY， #ifdef MR_AFFINE_ONLY #define mr_esize(n) (((sizeof(epoint)+mr_big_reserve(2,(n)))-1)/MR_SL+1)*MR_SL #else #define mr_esize(n) (((sizeof(epoint)+mr_big_reserve(3,(n)))-1)/MR_SL+1)*MR_SL #endif 函数功能：返回字节数。计算得到的字节数 ((sizeof(epoint)+mr_big_reserve)-1)/sizeof(long)+1)*sizeof(long) 参数n：整数。 源码分析 与实现mr_esize相关的定义和函数如下。 /* Elliptic Curve epoint structure. Uses projective (X,Y,Z) co-ordinates */ typedef struct { int marker; big X; big Y; #ifndef MR_AFFINE_ONLY big Z; #endif } epoint; #ifdef MR_FP typedef mr_utype mr_small; #ifdef mr_dltype typedef mr_dltype mr_large; #endif struct bigtype{ mr_lentype len; mr_small *w; }; #define MR_SL sizeof(long) // 计算所需字节数 #define mr_size(n) (((sizeof(struct bigtype)+((n)+2)*sizeof(mr_utype))-1)/MR_SL+1)*MR_SL #define mr_big_reserve(n,m) ((n)*mr_size(m)+MR_SL) #ifdef MR_AFFINE_ONLY #define mr_esize(n) (((sizeof(epoint)+mr_big_reserve(2,(n)))-1)/MR_SL+1)*MR_SL #else #define mr_esize(n) (((sizeof(epoint)+mr_big_reserve(3,(n)))-1)/MR_SL+1)*MR_SL #endif mr_size计算返回字节数。 mr_big_reserve计算得到(n)*mr_size(m)+sizeof(long)个字节。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/miracl/mr_esize_a.html":{"url":"miracldoc/api/miracl/mr_esize_a.html","title":"mr_esize_a","keywords":"","body":"mr_esize_a() mr_esize_a定义在miracl.h #define mr_esize_a(n) (((sizeof(epoint)+mr_big_reserve(2,(n)))-1)/MR_SL+1)*MR_SL 函数功能：返回字节数。计算得到的字节数 ((sizeof(epoint)+mr_big_reserve)-1)/sizeof(long)+1)*sizeof(long) 参数n：整数。 源码分析 与实现mr_esize_a相关的定义和函数如下。 /* Elliptic Curve epoint structure. Uses projective (X,Y,Z) co-ordinates */ typedef struct { int marker; big X; big Y; #ifndef MR_AFFINE_ONLY big Z; #endif } epoint; #ifdef MR_FP typedef mr_utype mr_small; #ifdef mr_dltype typedef mr_dltype mr_large; #endif struct bigtype{ mr_lentype len; mr_small *w; }; #define MR_SL sizeof(long) mr_big_reserve计算得到(n)*mr_size(m)+sizeof(long)个字节。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/miracl/MR_IN-MR_OUT.html":{"url":"miracldoc/api/miracl/MR_IN-MR_OUT.html","title":"MR_IN和MR_OUT","keywords":"","body":"MR_IN和MR_OUT MIRACL线程的进退码。如果定义了MR_STRIPPED_DOWN，线程的进退码为空。 #define MR_MAXDEPTH 24 /* max routine stack depth */ /* Preamble and exit code for MIRACL routines. Not used if MR_STRIPPED_DOWN is defined */ #ifdef MR_STRIPPED_DOWN #define MR_OUT #define MR_IN(N) #else #define MR_OUT mr_mip->depth--; #define MR_IN(N) mr_mip->depth++; if (mr_mip->depthtrace[mr_mip->depth]=(N); if (mr_mip->TRACER) mr_track(_MIPPO_); } #endif MIRACL线程最大深度为24，只要不超过最大值，都会被记录。 如果定义MR_GENERIC_MT，则_MIPPO_表示一个MIRACL线程实例，否则为空。 #ifdef MR_GENERIC_MT #define _MIPPO_ mr_mip #else #define _MIPPO_ #endif © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-18 "},"miracldoc/api/miracl/MR_LROUND.html":{"url":"miracldoc/api/miracl/MR_LROUND.html","title":"MR_LROUND","keywords":"","body":"MR_LROUND MR_LROUND #ifdef MR_FP #ifdef MR_FP_ROUNDING /* slightly dicey - for example the optimizer might remove the MAGIC ! */ #define MR_LROUND(a) ( ( (a) + MR_MAGIC ) - MR_MAGIC ) #else /* modfl()：提取浮点数 x 的整数部分和小数部分，整数部分被存入参数 intptr 中，小数部分被放入返回值中。 函数原型：long double modfl( long double arg, long double* iptr ); */ #define MR_LROUND(a) (modfl((a),&ldres),ldres) #endif #else #define MR_LROUND(a) ((a)) #endif © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/miracl/MR_REMAIN.html":{"url":"miracldoc/api/miracl/MR_REMAIN.html","title":"MR_REMAIN","keywords":"","body":"MR_REMAIN MR_REMAIN定义在miracl.h，计算余数。 #ifdef MR_FP #define MR_REMAIN(a,b) ((a)-(b)*MR_DIV((a),(b))) #else #define MR_REMAIN(a,b) ((a)%(b)) #endif MR_DIV计算商，(a)-(b)*MR_DIV((a),(b))就是余数。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/miracl/mr_size.html":{"url":"miracldoc/api/miracl/mr_size.html","title":"mr_size","keywords":"","body":"mr_size mr_size定义在miracl.h #define mr_size(n) (((sizeof(struct bigtype)+((n)+2)*sizeof(mr_utype))-1)/MR_SL+1)*MR_SL 函数功能：返回字节数。若struct bigtype类型数据占8个字节，long类型数据占8个字节，则总共申请(((8+(n+2)∗4)−1)/8+1)∗8=15+4n+8(((8+(n+2)*4)-1)/8+1)*8=15+4n+8(((8+(n+2)∗4)−1)/8+1)∗8=15+4n+8个字节。 参数n：整型变量。 函数分析 为实现mr_size，所需要的相关数据类型定义如下。 #define mr_utype int /* the underlying type is usually int, but see mrmuldv.any */ #ifdef MR_FP typedef mr_utype mr_small; #else typedef unsigned mr_utype mr_small; /* It might be wanted to change this to unsigned long */ typedef unsigned int mr_lentype; struct bigtype { mr_lentype len; mr_small *w; }; typedef struct bigtype *big; #define MR_SL sizeof(long) mr_utype在mirdef.h定义，一般定义为int。 mr_small定义为mr_utype或者unsigned mr_utype，根据mr_utype的定义，一般为int或者unsigned int。 struct bigtype类型由mr_lentype和mr_small类型数据成员，一般情况下与下面的定义等价。big是struct bigtype *的别名。 struct bigtype { unsigned int len; int *w; }; MR_SL在miracl.h定义，计算long类型数据占用内存字节数。 © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-15 "},"miracldoc/api/ecn/operator-.html":{"url":"miracldoc/api/ecn/operator-.html","title":"operator-","keywords":"","body":"ECn::operator- friend ECn operator-(const ECn&); ECn operator-(const ECn& e) { ECn t=e; epoint_negate(t.p); return t;} © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-14 "},"miracldoc/api/ecn/add.html":{"url":"miracldoc/api/ecn/add.html","title":"add","keywords":"","body":"ECn::add add定义在ecn.h，实现在ecn.cpp int add(const ECn&,big *,big *ex1=NULL,big *ex2=NULL) const; 函数功能：椭圆曲线上两点之和。 参数b：ECn类型数据。 参数lam：big类型数据。 参数ex1：big类型数据。 参数ex2：big类型数据。 源码分析 int ECn::add(const ECn& b,big *lam,big *ex1,big *ex2) const { // p为epoint*，来源于外部调用 int r=ecurve_add(b.p,p); *lam=get_mip()->w8; if (ex1!=NULL) *ex1=get_mip()->w7; if (ex2!=NULL) *ex2=get_mip()->w6; return r; } ecurve_add完成椭圆曲线上的两个点相加，pa=pa+p。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/ecn/double_add.html":{"url":"miracldoc/api/ecn/double_add.html","title":"double_add","keywords":"","body":"ECn::double_add friend void double_add(ECn&,ECn&,ECn&,ECn&,big&,big&); #ifndef MR_EDWARDS void double_add(ECn& A,ECn& B,ECn& C,ECn& D,big& s1,big& s2) { ecurve_double_add(A.p,B.p,C.p,D.p,&s1,&s2); } #endif © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-14 "},"miracldoc/api/ecn/get.html":{"url":"miracldoc/api/ecn/get.html","title":"get","keywords":"","body":"ECn::get int get(Big& x,Big& y) const; // This gets the point in compressed form. Return value is LSB of y-coordinate int get(Big& x) const; int ECn::get(Big& x,Big& y) const {return epoint_get(p,x.getbig(),y.getbig());} int ECn::get(Big& x) const {return epoint_get(p,x.getbig(),x.getbig());} © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-14 "},"miracldoc/api/ecn/getx.html":{"url":"miracldoc/api/ecn/getx.html","title":"getx","keywords":"","body":"ECn::getx void getx(Big &x) const; void ECn::getx(Big &x) const {epoint_getxyz(p,x.getbig(),NULL,NULL);} © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-14 "},"miracldoc/api/ecn/getxy.html":{"url":"miracldoc/api/ecn/getxy.html","title":"getxy","keywords":"","body":"ECn::getxy void getxy(Big &x,Big &y) const; void ECn::getxy(Big &x,Big &y) const {epoint_getxyz(p,x.getbig(),y.getbig(),NULL);} © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-15 "},"miracldoc/api/ecn/getxyz.html":{"url":"miracldoc/api/ecn/getxyz.html","title":"getxyz","keywords":"","body":"ECn::getxyz void getxyz(Big &x,Big &y,Big &z) const; void ECn::getxyz(Big &x,Big &y, Big &z) const {epoint_getxyz(p,x.getbig(),y.getbig(),z.getbig());} © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-14 "},"miracldoc/api/ecn/is_on_curve.html":{"url":"miracldoc/api/ecn/is_on_curve.html","title":"is_on_curve","keywords":"","body":"ECn::is_on_curve #ifndef MR_NOSUPPORT_COMPRESSION #ifndef MR_NOTESTXONCURVE BOOL is_on_curve(const Big& a) { return epoint_x(a.fn);} #endif #endif © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-14 "},"miracldoc/api/ecn/iszero.html":{"url":"miracldoc/api/ecn/iszero.html","title":"iszero","keywords":"","body":"ECn::iszero BOOL iszero() const; BOOL ECn::iszero() const {if (p->marker==MR_EPOINT_INFINITY) return TRUE; return FALSE;} © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-14 "},"miracldoc/api/ecn/operator-lb.html":{"url":"miracldoc/api/ecn/operator-lb.html","title":"operator<<","keywords":"","body":"ECn::operator friend ostream& operator #ifndef MR_NO_STANDARD_IO ostream& operator © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-14 "},"miracldoc/api/ecn/mul.html":{"url":"miracldoc/api/ecn/mul.html","title":"mul","keywords":"","body":"ECn::mul friend ECn mul(const Big&, const ECn&, const Big&, const ECn&); friend ECn mul(int, const Big *, ECn *); #ifndef MR_NO_ECC_MULTIADD ECn mul(const Big& e1,const ECn& p1,const Big& e2,const ECn& p2) { ECn t; ecurve_mult2(e1.getbig(),p1.get_point(),e2.getbig(),p2.get_point(),t.get_point()); return t; } #ifndef MR_STATIC ECn mul(int n,const Big *y,ECn *x) { ECn w; int i; big *a=(big *)mr_alloc(n,sizeof(big)); epoint **b=(epoint **)mr_alloc(n,sizeof(epoint *)); for (i=0;i © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-14 "},"miracldoc/api/ecn/multi_add.html":{"url":"miracldoc/api/ecn/multi_add.html","title":"multi_add","keywords":"","body":"ECn::multi_add friend void multi_add(int,ECn *,ECn *); void multi_add(int m,ECn *x, ECn *w) { int i; epoint **xp=(epoint **)mr_alloc(m,sizeof(epoint *)); epoint **wp=(epoint **)mr_alloc(m,sizeof(epoint *)); for (i=0;i © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-14 "},"miracldoc/api/ecn/multi_norm.html":{"url":"miracldoc/api/ecn/multi_norm.html","title":"multi_norm","keywords":"","body":"ECn::multi_norm friend void multi_norm(int,ECn *); #ifndef MR_EDWARDS void multi_norm(int m,ECn* e) { int i; Big w[20]; big a[20]; epoint *b[20]; for (i=0;i © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-14 "},"miracldoc/api/ecn/sub.html":{"url":"miracldoc/api/ecn/sub.html","title":"sub","keywords":"","body":"ECn::sub sub定义在ecn.h，实现在ecn.cpp int sub(const ECn&,big *,big *ex1=NULL,big *ex2=NULL) const; 函数功能：椭圆曲线上两点之和。 参数b：ECn类型数据。 参数lam：big类型数据。 参数ex1：big类型数据。 参数ex2：big类型数据。 源码分析 int ECn::sub(const ECn& b,big *lam,big *ex1,big *ex2) const { int r=ecurve_sub(b.p,p); *lam=get_mip()->w8; if (ex1!=NULL) *ex1=get_mip()->w7; if (ex2!=NULL) *ex2=get_mip()->w6; return r; } ecurve_sub减法运算。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/ecn/get_point.html":{"url":"miracldoc/api/ecn/get_point.html","title":"get_point","keywords":"","body":"get_point get_point定义在ecn.h epoint *get_point() const; get_point在ecn.cpp中实现 epoint * ECn::get_point() const { return p; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-13 "},"miracldoc/api/ecn/operator-x.html":{"url":"miracldoc/api/ecn/operator-x.html","title":"operator*","keywords":"","body":"ECn::operator* friend ECn operator*(const Big &,const ECn&); ECn operator*(const Big& e,const ECn& b) { ECn t; ecurve_mult(e.getbig(),b.p,t.p); return t; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-14 "},"miracldoc/api/ecn/get_status.html":{"url":"miracldoc/api/ecn/get_status.html","title":"get_status","keywords":"","body":"get_status get_status定义在ecn.h int get_status() {return p->marker;} 函数功能：返回点的状态，记录在epoint的marker。 参数：无。 源码分析 与get_status相关的内容如下。 /* Elliptic Curve epoint structure. Uses projective (X,Y,Z) co-ordinates */ typedef struct { int marker; big X; big Y; #ifndef MR_AFFINE_ONLY big Z; #endif } epoint; epoint *p; int get_status() {return p->marker;} 可参考epoint类型的描述。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/mrmonty/nres.html":{"url":"miracldoc/api/mrmonty/nres.html","title":"nres","keywords":"","body":"nres nres定义在miracl.h extern void nres(_MIPT_ big,big); 函数功能： 参数_MIPD_：可能为空，非空为miracl *类型。 参数x： 参数y： 源码分析 nres实现在mrmonty.c void nres(_MIPD_ big x,big y) { /* convert x to n-residue format */ #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); // 返回`miracl *`实例 #endif if (mr_mip->ERNUM) return; // 有错误直接返回 MR_IN(81) // 线程进入码 if (size(mr_mip->modulus)==0) { mr_berror(_MIPP_ MR_ERR_NO_MODULUS); MR_OUT // 线程退出码 return; } copy(x,y); // 将x轴坐标复制给y轴坐标。 divide(_MIPP_ y,mr_mip->modulus,mr_mip->modulus); if (size(y)modulus,y); if (!mr_mip->MONTY) { MR_OUT return; } mr_mip->check=OFF; mr_shift(_MIPP_ y,(int)mr_mip->modulus->len,mr_mip->w0); divide(_MIPP_ mr_mip->w0,mr_mip->modulus,mr_mip->modulus); mr_mip->check=ON; copy(mr_mip->w0,y); MR_OUT } miracl类型 get_mip返回miracl *指针，如果没有定义MR_OS_THREADS，由_MIPD_接收。 ERNUM错误码，如果非零，表示有错误。 MR_IN设置线程的进入码，MR_OUT设置线程的退出码。 mr_berror的错误码为MR_ERR_NO_MODULUS。 copy将x轴坐标复制给y轴坐标。 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/api/mrmonty/nres_modmult.html":{"url":"miracldoc/api/mrmonty/nres_modmult.html","title":"nres_modmult","keywords":"","body":"nres_modmult nres_modmult extern void nres_modmult(_MIPT_ big,big,big); 函数功能：取模运算，计算w=x*y mod n。 参数_MIPD_：可能为空，非空为miracl *类型。 参数x：big类型数据。 参数y：big类型数据。 参数w：big类型数据。 源码分析 void nres_modmult(_MIPD_ big x,big y,big w) { /* Modular multiplication using n-residues w=x*y mod n */ #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif if ((x==NULL || x->len==0) && x==w) return; if ((y==NULL || y->len==0) && y==w) return; if (y==NULL || x==NULL || x->len==0 || y->len==0) { zero(w); return; } #ifdef MR_COUNT_OPS fpc++; #endif #ifdef MR_COMBA if (mr_mip->ACTIVE) { if (x==y) comba_square(x,mr_mip->w0); else comba_mult(x,y,mr_mip->w0); comba_redc(_MIPP_ mr_mip->w0,w); } else { #endif #ifdef MR_KCM if (mr_mip->ACTIVE) { if (x==y) kcm_sqr(_MIPP_ x,mr_mip->w0); else kcm_mul(_MIPP_ x,y,mr_mip->w0); kcm_redc(_MIPP_ mr_mip->w0,w); } else { #endif #ifdef MR_PENTIUM if (mr_mip->ACTIVE) { if (x==y) fastmodsquare(_MIPP_ x,w); else fastmodmult(_MIPP_ x,y,w); } else { #endif if (mr_mip->ERNUM) return; MR_IN(83) mr_mip->check=OFF; multiply(_MIPP_ x,y,mr_mip->w0); redc(_MIPP_ mr_mip->w0,w); mr_mip->check=ON; MR_OUT #ifdef MR_COMBA } #endif #ifdef MR_KCM } #endif #ifdef MR_PENTIUM } #endif } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/mrmonty/nres_modadd.html":{"url":"miracldoc/api/mrmonty/nres_modadd.html","title":"nres_modadd","keywords":"","body":"nres_modadd nres_modadd extern void nres_modadd(_MIPT_ big,big,big); void nres_modadd(_MIPD_ big x,big y,big w) { /* modular addition */ #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif #ifdef MR_COUNT_OPS fpa++; #endif #ifdef MR_COMBA if (mr_mip->ACTIVE) { comba_modadd(_MIPP_ x,y,w); return; } else { #endif if (mr_mip->ERNUM) return; MR_IN(90) mr_padd(_MIPP_ x,y,w); if (mr_compare(w,mr_mip->modulus)>=0) mr_psub(_MIPP_ w,mr_mip->modulus,w); MR_OUT #ifdef MR_COMBA } #endif } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/mrmonty/nres_premult.html":{"url":"miracldoc/api/mrmonty/nres_premult.html","title":"nres_premult","keywords":"","body":"nres_premult nres_premult extern void nres_premult(_MIPT_ big,int,big); void nres_premult(_MIPD_ big x,int k,big w) { /* multiply n-residue by small ordinary integer */ #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif int sign=0; if (k==0) { zero(w); return; } if (kERNUM) return; MR_IN(102) if (kw0); nres_modadd(_MIPP_ x,mr_mip->w0,w); break; case 4: nres_modadd(_MIPP_ x,x,w); nres_modadd(_MIPP_ w,w,w); break; case 5: nres_modadd(_MIPP_ x,x,mr_mip->w0); nres_modadd(_MIPP_ mr_mip->w0,mr_mip->w0,mr_mip->w0); nres_modadd(_MIPP_ x,mr_mip->w0,w); break; case 6: nres_modadd(_MIPP_ x,x,w); nres_modadd(_MIPP_ w,w,mr_mip->w0); nres_modadd(_MIPP_ w,mr_mip->w0,w); break; } if (sign==1) nres_negate(_MIPP_ w,w); MR_OUT return; } mr_pmul(_MIPP_ x,(mr_small)k,mr_mip->w0); #ifdef MR_COMBA #ifdef MR_SPECIAL comba_redc(_MIPP_ mr_mip->w0,w); #else divide(_MIPP_ mr_mip->w0,mr_mip->modulus,mr_mip->modulus); copy(mr_mip->w0,w); #endif #else divide(_MIPP_ mr_mip->w0,mr_mip->modulus,mr_mip->modulus); copy(mr_mip->w0,w); #endif if (sign==1) nres_negate(_MIPP_ w,w); MR_OUT } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/mrsroot/nres_sqroot.html":{"url":"miracldoc/api/mrsroot/nres_sqroot.html","title":"nres_sqroot","keywords":"","body":"nres_sqroot nres_sqroot extern BOOL nres_sqroot(_MIPT_ big,big); BOOL nres_sqroot(_MIPD_ big x,big w) { /* w=sqrt(x) mod p. This depends on p being prime! */ int t,js; #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif if (mr_mip->ERNUM) return FALSE; copy(x,w); if (size(w)==0) return TRUE; MR_IN(100) redc(_MIPP_ w,w); /* get it back into normal form */ if (size(w)==1) /* square root of 1 is 1 */ { nres(_MIPP_ w,w); MR_OUT return TRUE; } if (size(w)==4) /* square root of 4 is 2 */ { convert(_MIPP_ 2,w); nres(_MIPP_ w,w); MR_OUT return TRUE; } if (jack(_MIPP_ w,mr_mip->modulus)!=1) { /* Jacobi test */ zero(w); MR_OUT return FALSE; } js=mr_mip->pmod8%4-2; /* 1 mod 4 or 3 mod 4 prime? */ incr(_MIPP_ mr_mip->modulus,js,mr_mip->w10); subdiv(_MIPP_ mr_mip->w10,4,mr_mip->w10); /* (p+/-1)/4 */ if (js==1) { /* 3 mod 4 primes - do a quick and dirty sqrt(x)=x^(p+1)/4 mod p */ nres(_MIPP_ w,mr_mip->w2); copy(mr_mip->one,w); forever { /* Simple Right-to-Left exponentiation */ if (mr_mip->user!=NULL) (*mr_mip->user)(); if (subdiv(_MIPP_ mr_mip->w10,2,mr_mip->w10)!=0) nres_modmult(_MIPP_ w,mr_mip->w2,w); if (mr_mip->ERNUM || size(mr_mip->w10)==0) break; nres_modmult(_MIPP_ mr_mip->w2,mr_mip->w2,mr_mip->w2); } /* nres_moddiv(_MIPP_ mr_mip->one,w,mr_mip->w11); nres_modadd(_MIPP_ mr_mip->w11,w,mr_mip->w3); nres_lucas(_MIPP_ mr_mip->w3,mr_mip->w10,w,w); nres_modadd(_MIPP_ mr_mip->w11,mr_mip->one,mr_mip->w11); nres_moddiv(_MIPP_ w,mr_mip->w11,w); */ } else { /* 1 mod 4 primes */ for (t=1; ;t++) { /* t=1.5 on average */ if (t==1) copy(w,mr_mip->w4); else { premult(_MIPP_ w,t,mr_mip->w4); divide(_MIPP_ mr_mip->w4,mr_mip->modulus,mr_mip->modulus); premult(_MIPP_ mr_mip->w4,t,mr_mip->w4); divide(_MIPP_ mr_mip->w4,mr_mip->modulus,mr_mip->modulus); } decr(_MIPP_ mr_mip->w4,4,mr_mip->w1); if (jack(_MIPP_ mr_mip->w1,mr_mip->modulus)==js) break; if (mr_mip->ERNUM) break; } decr(_MIPP_ mr_mip->w4,2,mr_mip->w3); nres(_MIPP_ mr_mip->w3,mr_mip->w3); nres_lucas(_MIPP_ mr_mip->w3,mr_mip->w10,w,w); /* heavy lifting done here */ if (t!=1) { convert(_MIPP_ t,mr_mip->w11); nres(_MIPP_ mr_mip->w11,mr_mip->w11); nres_moddiv(_MIPP_ w,mr_mip->w11,w); } } MR_OUT return TRUE; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/api/mrsroot/sqroot.html":{"url":"miracldoc/api/mrsroot/sqroot.html","title":"sqroot","keywords":"","body":"sqroot sqroot extern BOOL sqroot(_MIPT_ big,big,big); BOOL sqroot(_MIPD_ big x,big p,big w) { /* w = sqrt(x) mod p */ #ifdef MR_OS_THREADS miracl *mr_mip=get_mip(); #endif if (mr_mip->ERNUM) return FALSE; MR_IN(101) if (subdivisible(_MIPP_ p,2)) { /* p must be odd */ zero(w); MR_OUT return FALSE; } prepare_monty(_MIPP_ p); nres(_MIPP_ x,w); if (nres_sqroot(_MIPP_ w,w)) { redc(_MIPP_ w,w); MR_OUT return TRUE; } zero(w); MR_OUT return FALSE; } © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-20 "},"miracldoc/packg/big.html":{"url":"miracldoc/packg/big.html","title":"big","keywords":"","body":"big.cpp/big.h © phdlisl all right reserved，powered by GitbookUpdate in 2024-05-03 "},"miracldoc/packg/ecn.html":{"url":"miracldoc/packg/ecn.html","title":"ecn","keywords":"","body":"ecn.h 和 ecn.cpp 定义ECn类，其中“ECn”表示“Arithmetic on an Elliptic Curve, mod n”。 如果没有定义ECN_H，则定义ECN_H，防止重复定义引发冲突。包含头文件cstring和big.h，其中是C语言中的C++版本，主要提供了一些操作C风格字符串（即以空字符 '\\0' 结尾的字符数组）的函数和工具，如strcpy、strlen、strcat、strcmp等函数都在这个头文件中声明，更适合用在C语言库的兼容或性能优化；big.h详解参考big.h。 #ifndef ECN_H #define ECN_H #include #include \"big.h\" MR_INIT_ECN 如果定义了ZZNS，则定义MR_INIT_ECN为memset，否则定义为mem。 #ifdef ZZNS #define MR_INIT_ECN memset(mem,0,mr_ecp_reserve(1,ZZNS)); p=(epoint *)epoint_init_mem_variable(mem,0,ZZNS); #else #define MR_INIT_ECN mem=(char *)ecp_memalloc(1); p=(epoint *)epoint_init_mem(mem,0); #endif 如果定义ZZNS，把mem指向的mr_ecp_reserve个字节空间初始化为0，mem为char类型数组。 epoint_init_mem_variable用字符数组mem初始化一个epoint类型指针，也就是得到椭圆曲线的一个点。 如果没有定义ZZNS，mem指向ecp_memalloc分配的内存， epoint_init_mem将字符串mem初始化为椭圆曲线上的点。 #ifdef ZZNS char mem[mr_ecp_reserve(1,ZZNS)]; #else char *mem; #endif ECn类 如果定义ZZNS，则设置mem的大小为mr_ecp_reserve的数组，否则mem作为char *类型指针。 定义ECn类的构造函数，其构造函数有4个，在构造函数中用MR_INIT_ECN完成对ECn初始化，MR_INIT_ECN就定义在这个文件中。 epoint_set在椭圆曲线上初始化一个点，epoint_copy实现椭圆曲线上两个点的复制。 get_point取出点p，get_status取出当前的状态。 ecurve_add实现椭圆曲线上的两个点相加，pa=pa+p。 class ECn { epoint *p; #ifdef ZZNS char mem[mr_ecp_reserve(1,ZZNS)]; // 设置一个数组 #else char *mem; #endif public: ECn() {MR_INIT_ECN } ECn(const Big &x,const Big& y) {MR_INIT_ECN epoint_set(x.getbig(),y.getbig(),0,p); } // This next constructor restores a point on the curve from \"compressed\" // data, that is the full x co-ordinate, and the LSB of y (0 or 1) #ifndef MR_SUPPORT_COMPRESSION ECn(const Big& x,int cb) {MR_INIT_ECN epoint_set(x.getbig(),x.getbig(),cb,p); } #endif ECn(const ECn &b) {MR_INIT_ECN epoint_copy(b.p,p);} epoint *get_point() const; int get_status() {return p->marker;} ECn& operator=(const ECn& b) {epoint_copy(b.p,p);return *this;} ECn& operator+=(const ECn& b) {ecurve_add(b.p,p); return *this;} int add(const ECn&,big *,big *ex1=NULL,big *ex2=NULL) const; // returns line slope as a big int sub(const ECn&,big *,big *ex1=NULL,big *ex2=NULL) const; ECn& operator-=(const ECn& b) {ecurve_sub(b.p,p); return *this;} // Multiplication of a point by an integer. ECn& operator*=(const Big& k) {ecurve_mult(k.getbig(),p,p); return *this;} void clear() {epoint_set(NULL,NULL,0,p);} BOOL set(const Big& x,const Big& y) {return epoint_set(x.getbig(),y.getbig(),0,p);} #ifndef MR_AFFINE_ONLY // use with care if at all void setz(const Big& z) {nres(z.getbig(),p->Z); p->marker=MR_EPOINT_GENERAL;} #endif BOOL iszero() const; int get(Big& x,Big& y) const; // This gets the point in compressed form. Return value is LSB of y-coordinate int get(Big& x) const; // get raw coordinates void getx(Big &x) const; void getxy(Big &x,Big &y) const; void getxyz(Big &x,Big &y,Big &z) const; // point compression // This sets the point from compressed form. cb is LSB of y coordinate #ifndef MR_SUPPORT_COMPRESSION BOOL set(const Big& x,int cb=0) {return epoint_set(x.getbig(),x.getbig(),cb,p);} #endif friend ECn operator-(const ECn&); friend void multi_add(int,ECn *,ECn *); friend void double_add(ECn&,ECn&,ECn&,ECn&,big&,big&); friend ECn mul(const Big&, const ECn&, const Big&, const ECn&); friend ECn mul(int, const Big *, ECn *); friend void normalise(ECn &e) {epoint_norm(e.p);} friend void multi_norm(int,ECn *); friend BOOL operator==(const ECn& a,const ECn& b) {return epoint_comp(a.p,b.p);} friend BOOL operator!=(const ECn& a,const ECn& b) {return (!epoint_comp(a.p,b.p));} friend ECn operator*(const Big &,const ECn&); #ifndef MR_NO_STANDARD_IO friend ostream& operator ECn实现的函数 add椭圆曲线上两点之和。 sub减法运算。 operator- double_add get getx getxy getxyz is_on_curve iszero operator mul multi_add multi_norm get_point operator* get_status © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "},"miracldoc/packg/pairing3h.html":{"url":"miracldoc/packg/pairing3h.html","title":"pairing_3.h","keywords":"","body":"pairing_3.h 如果没有定义PAIRING_3_H，则定义PAIRING_3_H。 #ifndef PAIRING_3_H #define PAIRING_3_H 包含头文件ecn.h，设置群元素。ecn #include \"ecn.h\" // G1 © phdlisl all right reserved，powered by GitbookUpdate in 2025-10-11 "}}